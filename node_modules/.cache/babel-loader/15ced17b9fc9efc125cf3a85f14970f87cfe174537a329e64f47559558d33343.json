{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"./Misc/tools.js\";\nimport { PrecisionDate } from \"./Misc/precisionDate.js\";\nimport { Observable } from \"./Misc/observable.js\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray.js\";\nimport { StringDictionary } from \"./Misc/stringDictionary.js\";\nimport { Tags } from \"./Misc/tags.js\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector.js\";\nimport { AbstractScene } from \"./abstractScene.js\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration.js\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer.js\";\nimport { PickingInfo } from \"./Collisions/pickingInfo.js\";\nimport { ActionEvent } from \"./Actions/actionEvent.js\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"./Rendering/renderingManager.js\";\nimport { Stage } from \"./sceneComponent.js\";\nimport { IsWindowObjectExist } from \"./Misc/domManagement.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\nimport { _WarnImport } from \"./Misc/devTools.js\";\nimport { InputManager } from \"./Inputs/scene.inputManager.js\";\nimport { PerfCounter } from \"./Misc/perfCounter.js\";\nimport { Color4, Color3 } from \"./Maths/math.color.js\";\nimport { Frustum } from \"./Maths/math.frustum.js\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator.js\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools.js\";\nimport { LightConstants } from \"./Lights/lightConstants.js\";\nimport { _ObserveArray } from \"./Misc/arrayTools.js\";\nimport { PointerPickingConfiguration } from \"./Inputs/pointerPickingConfiguration.js\";\n/**\n * Define how the scene should favor performance over ease of use\n */\nexport var ScenePerformancePriority;\n(function (ScenePerformancePriority) {\n  /** Default mode. No change. Performance will be treated as less important than backward compatibility */\n  ScenePerformancePriority[ScenePerformancePriority[\"BackwardCompatible\"] = 0] = \"BackwardCompatible\";\n  /** Some performance options will be turned on trying to strike a balance between perf and ease of use */\n  ScenePerformancePriority[ScenePerformancePriority[\"Intermediate\"] = 1] = \"Intermediate\";\n  /** Performance will be top priority */\n  ScenePerformancePriority[ScenePerformancePriority[\"Aggressive\"] = 2] = \"Aggressive\";\n})(ScenePerformancePriority || (ScenePerformancePriority = {}));\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene\n */\nexport class Scene extends AbstractScene {\n  /**\n   * Factory used to create the default material.\n   * @param scene The scene to create the material for\n   * @returns The default material\n   */\n  static DefaultMaterialFactory(scene) {\n    throw _WarnImport(\"StandardMaterial\");\n  }\n  /**\n   * Factory used to create the a collision coordinator.\n   * @returns The collision coordinator\n   */\n  static CollisionCoordinatorFactory() {\n    throw _WarnImport(\"DefaultCollisionCoordinator\");\n  }\n  /**\n   * Texture used in all pbr material as the reflection texture.\n   * As in the majority of the scene they are the same (exception for multi room and so on),\n   * this is easier to reference from here than from all the materials.\n   */\n  get environmentTexture() {\n    return this._environmentTexture;\n  }\n  /**\n   * Texture used in all pbr material as the reflection texture.\n   * As in the majority of the scene they are the same (exception for multi room and so on),\n   * this is easier to set here than in all the materials.\n   */\n  set environmentTexture(value) {\n    if (this._environmentTexture === value) {\n      return;\n    }\n    this._environmentTexture = value;\n    this.markAllMaterialsAsDirty(1);\n  }\n  /**\n   * Default image processing configuration used either in the rendering\n   * Forward main pass or through the imageProcessingPostProcess if present.\n   * As in the majority of the scene they are the same (exception for multi camera),\n   * this is easier to reference from here than from all the materials and post process.\n   *\n   * No setter as we it is a shared configuration, you can set the values instead.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility\n   */\n  get performancePriority() {\n    return this._performancePriority;\n  }\n  set performancePriority(value) {\n    if (value === this._performancePriority) {\n      return;\n    }\n    this._performancePriority = value;\n    switch (value) {\n      case ScenePerformancePriority.BackwardCompatible:\n        this.skipFrustumClipping = false;\n        this._renderingManager.maintainStateBetweenFrames = false;\n        this.skipPointerMovePicking = false;\n        this.autoClear = true;\n        break;\n      case ScenePerformancePriority.Intermediate:\n        this.skipFrustumClipping = false;\n        this._renderingManager.maintainStateBetweenFrames = false;\n        this.skipPointerMovePicking = true;\n        this.autoClear = false;\n        break;\n      case ScenePerformancePriority.Aggressive:\n        this.skipFrustumClipping = true;\n        this._renderingManager.maintainStateBetweenFrames = true;\n        this.skipPointerMovePicking = true;\n        this.autoClear = false;\n        break;\n    }\n    this.onScenePerformancePriorityChangedObservable.notifyObservers(value);\n  }\n  /**\n   * Gets or sets a boolean indicating if all rendering must be done in wireframe\n   */\n  set forceWireframe(value) {\n    if (this._forceWireframe === value) {\n      return;\n    }\n    this._forceWireframe = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get forceWireframe() {\n    return this._forceWireframe;\n  }\n  /**\n   * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n   */\n  set skipFrustumClipping(value) {\n    if (this._skipFrustumClipping === value) {\n      return;\n    }\n    this._skipFrustumClipping = value;\n  }\n  get skipFrustumClipping() {\n    return this._skipFrustumClipping;\n  }\n  /**\n   * Gets or sets a boolean indicating if all rendering must be done in point cloud\n   */\n  set forcePointsCloud(value) {\n    if (this._forcePointsCloud === value) {\n      return;\n    }\n    this._forcePointsCloud = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get forcePointsCloud() {\n    return this._forcePointsCloud;\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /** Sets a function to be executed when this scene is disposed. */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /** Sets a function to be executed before rendering this scene */\n  set beforeRender(callback) {\n    if (this._onBeforeRenderObserver) {\n      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n    }\n    if (callback) {\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    }\n  }\n  /** Sets a function to be executed after rendering this scene */\n  set afterRender(callback) {\n    if (this._onAfterRenderObserver) {\n      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    }\n    if (callback) {\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    }\n  }\n  /** Sets a function to be executed before rendering a camera*/\n  set beforeCameraRender(callback) {\n    if (this._onBeforeCameraRenderObserver) {\n      this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    }\n    this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n  }\n  /** Sets a function to be executed after rendering a camera*/\n  set afterCameraRender(callback) {\n    if (this._onAfterCameraRenderObserver) {\n      this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n    }\n    this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer down event\n   */\n  get pointerDownPredicate() {\n    return this._pointerPickingConfiguration.pointerDownPredicate;\n  }\n  set pointerDownPredicate(value) {\n    this._pointerPickingConfiguration.pointerDownPredicate = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer up event\n   */\n  get pointerUpPredicate() {\n    return this._pointerPickingConfiguration.pointerUpPredicate;\n  }\n  set pointerUpPredicate(value) {\n    this._pointerPickingConfiguration.pointerUpPredicate = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer move event\n   */\n  get pointerMovePredicate() {\n    return this._pointerPickingConfiguration.pointerMovePredicate;\n  }\n  set pointerMovePredicate(value) {\n    this._pointerPickingConfiguration.pointerMovePredicate = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer down event\n   */\n  get pointerDownFastCheck() {\n    return this._pointerPickingConfiguration.pointerDownFastCheck;\n  }\n  set pointerDownFastCheck(value) {\n    this._pointerPickingConfiguration.pointerDownFastCheck = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer up event\n   */\n  get pointerUpFastCheck() {\n    return this._pointerPickingConfiguration.pointerUpFastCheck;\n  }\n  set pointerUpFastCheck(value) {\n    this._pointerPickingConfiguration.pointerUpFastCheck = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer move event\n   */\n  get pointerMoveFastCheck() {\n    return this._pointerPickingConfiguration.pointerMoveFastCheck;\n  }\n  set pointerMoveFastCheck(value) {\n    this._pointerPickingConfiguration.pointerMoveFastCheck = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n   */\n  get skipPointerMovePicking() {\n    return this._pointerPickingConfiguration.skipPointerMovePicking;\n  }\n  set skipPointerMovePicking(value) {\n    this._pointerPickingConfiguration.skipPointerMovePicking = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n   */\n  get skipPointerDownPicking() {\n    return this._pointerPickingConfiguration.skipPointerDownPicking;\n  }\n  set skipPointerDownPicking(value) {\n    this._pointerPickingConfiguration.skipPointerDownPicking = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.\n   */\n  get skipPointerUpPicking() {\n    return this._pointerPickingConfiguration.skipPointerUpPicking;\n  }\n  set skipPointerUpPicking(value) {\n    this._pointerPickingConfiguration.skipPointerUpPicking = value;\n  }\n  /**\n   * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n   */\n  get unTranslatedPointer() {\n    return this._inputManager.unTranslatedPointer;\n  }\n  /**\n   * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n   */\n  static get DragMovementThreshold() {\n    return InputManager.DragMovementThreshold;\n  }\n  static set DragMovementThreshold(value) {\n    InputManager.DragMovementThreshold = value;\n  }\n  /**\n   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n   */\n  static get LongPressDelay() {\n    return InputManager.LongPressDelay;\n  }\n  static set LongPressDelay(value) {\n    InputManager.LongPressDelay = value;\n  }\n  /**\n   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n   */\n  static get DoubleClickDelay() {\n    return InputManager.DoubleClickDelay;\n  }\n  static set DoubleClickDelay(value) {\n    InputManager.DoubleClickDelay = value;\n  }\n  /** If you need to check double click without raising a single click at first click, enable this flag */\n  static get ExclusiveDoubleClickMode() {\n    return InputManager.ExclusiveDoubleClickMode;\n  }\n  static set ExclusiveDoubleClickMode(value) {\n    InputManager.ExclusiveDoubleClickMode = value;\n  }\n  /**\n   * Bind the current view position to an effect.\n   * @param effect The effect to be bound\n   * @param variableName name of the shader variable that will hold the eye position\n   * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n   * @returns the computed eye position\n   */\n  bindEyePosition(effect, variableName = \"vEyePosition\", isVector3 = false) {\n    const eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : this.activeCamera.globalPosition;\n    const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n    TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n    if (effect) {\n      if (isVector3) {\n        effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n      } else {\n        effect.setVector4(variableName, TmpVectors.Vector4[0]);\n      }\n    }\n    return TmpVectors.Vector4[0];\n  }\n  /**\n   * Update the scene ubo before it can be used in rendering processing\n   * @returns the scene UniformBuffer\n   */\n  finalizeSceneUbo() {\n    const ubo = this.getSceneUniformBuffer();\n    const eyePosition = this.bindEyePosition(null);\n    ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n    ubo.update();\n    return ubo;\n  }\n  /**\n   * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n   */\n  set useRightHandedSystem(value) {\n    if (this._useRightHandedSystem === value) {\n      return;\n    }\n    this._useRightHandedSystem = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get useRightHandedSystem() {\n    return this._useRightHandedSystem;\n  }\n  /**\n   * Sets the step Id used by deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @param newStepId defines the step Id\n   */\n  setStepId(newStepId) {\n    this._currentStepId = newStepId;\n  }\n  /**\n   * Gets the step Id used by deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns the step Id\n   */\n  getStepId() {\n    return this._currentStepId;\n  }\n  /**\n   * Gets the internal step used by deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns the internal step\n   */\n  getInternalStep() {\n    return this._currentInternalStep;\n  }\n  /**\n   * Gets or sets a boolean indicating if fog is enabled on this scene\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n   * (Default is true)\n   */\n  set fogEnabled(value) {\n    if (this._fogEnabled === value) {\n      return;\n    }\n    this._fogEnabled = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get fogEnabled() {\n    return this._fogEnabled;\n  }\n  /**\n   * Gets or sets the fog mode to use\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n   * | mode | value |\n   * | --- | --- |\n   * | FOGMODE_NONE | 0 |\n   * | FOGMODE_EXP | 1 |\n   * | FOGMODE_EXP2 | 2 |\n   * | FOGMODE_LINEAR | 3 |\n   */\n  set fogMode(value) {\n    if (this._fogMode === value) {\n      return;\n    }\n    this._fogMode = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get fogMode() {\n    return this._fogMode;\n  }\n  /**\n   * Flag indicating that the frame buffer binding is handled by another component\n   */\n  get prePass() {\n    return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n  }\n  /**\n   * Gets or sets a boolean indicating if shadows are enabled on this scene\n   */\n  set shadowsEnabled(value) {\n    if (this._shadowsEnabled === value) {\n      return;\n    }\n    this._shadowsEnabled = value;\n    this.markAllMaterialsAsDirty(2);\n  }\n  get shadowsEnabled() {\n    return this._shadowsEnabled;\n  }\n  /**\n   * Gets or sets a boolean indicating if lights are enabled on this scene\n   */\n  set lightsEnabled(value) {\n    if (this._lightsEnabled === value) {\n      return;\n    }\n    this._lightsEnabled = value;\n    this.markAllMaterialsAsDirty(2);\n  }\n  get lightsEnabled() {\n    return this._lightsEnabled;\n  }\n  /** All of the active cameras added to this scene. */\n  get activeCameras() {\n    return this._activeCameras;\n  }\n  set activeCameras(cameras) {\n    if (this._unObserveActiveCameras) {\n      this._unObserveActiveCameras();\n      this._unObserveActiveCameras = null;\n    }\n    if (cameras) {\n      this._unObserveActiveCameras = _ObserveArray(cameras, () => {\n        this.onActiveCamerasChanged.notifyObservers(this);\n      });\n    }\n    this._activeCameras = cameras;\n  }\n  /** Gets or sets the current active camera */\n  get activeCamera() {\n    return this._activeCamera;\n  }\n  set activeCamera(value) {\n    if (value === this._activeCamera) {\n      return;\n    }\n    this._activeCamera = value;\n    this.onActiveCameraChanged.notifyObservers(this);\n  }\n  /** The default material used on meshes when no material is affected */\n  get defaultMaterial() {\n    if (!this._defaultMaterial) {\n      this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n    }\n    return this._defaultMaterial;\n  }\n  /** The default material used on meshes when no material is affected */\n  set defaultMaterial(value) {\n    this._defaultMaterial = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if textures are enabled on this scene\n   */\n  set texturesEnabled(value) {\n    if (this._texturesEnabled === value) {\n      return;\n    }\n    this._texturesEnabled = value;\n    this.markAllMaterialsAsDirty(1);\n  }\n  get texturesEnabled() {\n    return this._texturesEnabled;\n  }\n  /**\n   * Gets or sets a boolean indicating if skeletons are enabled on this scene\n   */\n  set skeletonsEnabled(value) {\n    if (this._skeletonsEnabled === value) {\n      return;\n    }\n    this._skeletonsEnabled = value;\n    this.markAllMaterialsAsDirty(8);\n  }\n  get skeletonsEnabled() {\n    return this._skeletonsEnabled;\n  }\n  /** @internal */\n  get collisionCoordinator() {\n    if (!this._collisionCoordinator) {\n      this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n      this._collisionCoordinator.init(this);\n    }\n    return this._collisionCoordinator;\n  }\n  /**\n   * Gets the scene's rendering manager\n   */\n  get renderingManager() {\n    return this._renderingManager;\n  }\n  /**\n   * Gets the list of frustum planes (built from the active camera)\n   */\n  get frustumPlanes() {\n    return this._frustumPlanes;\n  }\n  /**\n   * Registers the transient components if needed.\n   */\n  _registerTransientComponents() {\n    // Register components that have been associated lately to the scene.\n    if (this._transientComponents.length > 0) {\n      for (const component of this._transientComponents) {\n        component.register();\n      }\n      this._transientComponents.length = 0;\n    }\n  }\n  /**\n   * @internal\n   * Add a component to the scene.\n   * Note that the ccomponent could be registered on th next frame if this is called after\n   * the register component stage.\n   * @param component Defines the component to add to the scene\n   */\n  _addComponent(component) {\n    this._components.push(component);\n    this._transientComponents.push(component);\n    const serializableComponent = component;\n    if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n      this._serializableComponents.push(serializableComponent);\n    }\n  }\n  /**\n   * @internal\n   * Gets a component from the scene.\n   * @param name defines the name of the component to retrieve\n   * @returns the component or null if not present\n   */\n  _getComponent(name) {\n    for (const component of this._components) {\n      if (component.name === name) {\n        return component;\n      }\n    }\n    return null;\n  }\n  /**\n   * Creates a new Scene\n   * @param engine defines the engine to use to render this scene\n   * @param options defines the scene options\n   */\n  constructor(engine, options) {\n    super();\n    // Members\n    /** @internal */\n    this._inputManager = new InputManager(this);\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n    this.cameraToUseForPointers = null;\n    /** @internal */\n    this._isScene = true;\n    /** @internal */\n    this._blockEntityCollection = false;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n     */\n    this.autoClear = true;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n     */\n    this.autoClearDepthAndStencil = true;\n    /**\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n     */\n    this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n     */\n    this.ambientColor = new Color3(0, 0, 0);\n    /**\n     * Intensity of the environment in all pbr material.\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    this.environmentIntensity = 1;\n    this._performancePriority = ScenePerformancePriority.BackwardCompatible;\n    /**\n     * Observable triggered when the performance priority is changed\n     */\n    this.onScenePerformancePriorityChangedObservable = new Observable();\n    this._forceWireframe = false;\n    this._skipFrustumClipping = false;\n    this._forcePointsCloud = false;\n    /**\n     * Gets or sets a boolean indicating if animations are enabled\n     */\n    this.animationsEnabled = true;\n    this._animationPropertiesOverride = null;\n    /**\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n     */\n    this.useConstantAnimationDeltaTime = false;\n    /**\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n     * Please note that it requires to run a ray cast through the scene on every frame\n     */\n    this.constantlyUpdateMeshUnderPointer = false;\n    /**\n     * Defines the HTML cursor to use when hovering over interactive elements\n     */\n    this.hoverCursor = \"pointer\";\n    /**\n     * Defines the HTML default cursor to use (empty by default)\n     */\n    this.defaultCursor = \"\";\n    /**\n     * Defines whether cursors are handled by the scene.\n     */\n    this.doNotHandleCursors = false;\n    /**\n     * This is used to call preventDefault() on pointer down\n     * in order to block unwanted artifacts like system double clicks\n     */\n    this.preventDefaultOnPointerDown = true;\n    /**\n     * This is used to call preventDefault() on pointer up\n     * in order to block unwanted artifacts like system double clicks\n     */\n    this.preventDefaultOnPointerUp = true;\n    // Metadata\n    /**\n     * Gets or sets user defined metadata\n     */\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    this.reservedDataStore = null;\n    /**\n     * Use this array to add regular expressions used to disable offline support for specific urls\n     */\n    this.disableOfflineSupportExceptionRules = new Array();\n    /**\n     * An event triggered when the scene is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._onDisposeObserver = null;\n    /**\n     * An event triggered before rendering the scene (right after animations and physics)\n     */\n    this.onBeforeRenderObservable = new Observable();\n    this._onBeforeRenderObserver = null;\n    /**\n     * An event triggered after rendering the scene\n     */\n    this.onAfterRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n     * This is triggered for each \"sub\" camera in a Camera Rig unlike onAfterCameraRenderObservable\n     */\n    this.onAfterRenderCameraObservable = new Observable();\n    this._onAfterRenderObserver = null;\n    /**\n     * An event triggered before animating the scene\n     */\n    this.onBeforeAnimationsObservable = new Observable();\n    /**\n     * An event triggered after animations processing\n     */\n    this.onAfterAnimationsObservable = new Observable();\n    /**\n     * An event triggered before draw calls are ready to be sent\n     */\n    this.onBeforeDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered after draw calls have been sent\n     */\n    this.onAfterDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered when the scene is ready\n     */\n    this.onReadyObservable = new Observable();\n    /**\n     * An event triggered before rendering a camera\n     */\n    this.onBeforeCameraRenderObservable = new Observable();\n    this._onBeforeCameraRenderObserver = null;\n    /**\n     * An event triggered after rendering a camera\n     * This is triggered for the full rig Camera only unlike onAfterRenderCameraObservable\n     */\n    this.onAfterCameraRenderObservable = new Observable();\n    this._onAfterCameraRenderObserver = null;\n    /**\n     * An event triggered when active meshes evaluation is about to start\n     */\n    this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when active meshes evaluation is done\n     */\n    this.onAfterActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is about to start\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    this.onBeforeParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is done\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    this.onAfterParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n     */\n    this.onDataLoadedObservable = new Observable();\n    /**\n     * An event triggered when a camera is created\n     */\n    this.onNewCameraAddedObservable = new Observable();\n    /**\n     * An event triggered when a camera is removed\n     */\n    this.onCameraRemovedObservable = new Observable();\n    /**\n     * An event triggered when a light is created\n     */\n    this.onNewLightAddedObservable = new Observable();\n    /**\n     * An event triggered when a light is removed\n     */\n    this.onLightRemovedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is created\n     */\n    this.onNewGeometryAddedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is removed\n     */\n    this.onGeometryRemovedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is created\n     */\n    this.onNewTransformNodeAddedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is removed\n     */\n    this.onTransformNodeRemovedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is created\n     */\n    this.onNewMeshAddedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is removed\n     */\n    this.onMeshRemovedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is created\n     */\n    this.onNewSkeletonAddedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is removed\n     */\n    this.onSkeletonRemovedObservable = new Observable();\n    /**\n     * An event triggered when a material is created\n     */\n    this.onNewMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is created\n     */\n    this.onNewMultiMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a material is removed\n     */\n    this.onMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is removed\n     */\n    this.onMultiMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a texture is created\n     */\n    this.onNewTextureAddedObservable = new Observable();\n    /**\n     * An event triggered when a texture is removed\n     */\n    this.onTextureRemovedObservable = new Observable();\n    /**\n     * An event triggered when render targets are about to be rendered\n     * Can happen multiple times per frame.\n     */\n    this.onBeforeRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered when render targets were rendered.\n     * Can happen multiple times per frame.\n     */\n    this.onAfterRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered before calculating deterministic simulation step\n     */\n    this.onBeforeStepObservable = new Observable();\n    /**\n     * An event triggered after calculating deterministic simulation step\n     */\n    this.onAfterStepObservable = new Observable();\n    /**\n     * An event triggered when the activeCamera property is updated\n     */\n    this.onActiveCameraChanged = new Observable();\n    /**\n     * An event triggered when the activeCameras property is updated\n     */\n    this.onActiveCamerasChanged = new Observable();\n    /**\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    this.onBeforeRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    this.onAfterRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will when a mesh has been imported into the scene.\n     */\n    this.onMeshImportedObservable = new Observable();\n    /**\n     * This Observable will when an animation file has been imported into the scene.\n     */\n    this.onAnimationFileImportedObservable = new Observable();\n    // Animations\n    /** @internal */\n    this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n    // Pointers\n    this._pointerPickingConfiguration = new PointerPickingConfiguration();\n    /**\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n     */\n    this.onPrePointerObservable = new Observable();\n    /**\n     * Observable event triggered each time an input event is received from the rendering canvas\n     */\n    this.onPointerObservable = new Observable();\n    // Keyboard\n    /**\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n     */\n    this.onPreKeyboardObservable = new Observable();\n    /**\n     * Observable event triggered each time an keyboard event is received from the hosting window\n     */\n    this.onKeyboardObservable = new Observable();\n    // Coordinates system\n    this._useRightHandedSystem = false;\n    // Deterministic lockstep\n    this._timeAccumulator = 0;\n    this._currentStepId = 0;\n    this._currentInternalStep = 0;\n    // Fog\n    this._fogEnabled = true;\n    this._fogMode = Scene.FOGMODE_NONE;\n    /**\n     * Gets or sets the fog color to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is Color3(0.2, 0.2, 0.3))\n     */\n    this.fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\n     * Gets or sets the fog density to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 0.1)\n     */\n    this.fogDensity = 0.1;\n    /**\n     * Gets or sets the fog start distance to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 0)\n     */\n    this.fogStart = 0;\n    /**\n     * Gets or sets the fog end distance to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 1000)\n     */\n    this.fogEnd = 1000.0;\n    /**\n     * Flag indicating if we need to store previous matrices when rendering\n     */\n    this.needsPreviousWorldMatrices = false;\n    // Lights\n    this._shadowsEnabled = true;\n    this._lightsEnabled = true;\n    this._unObserveActiveCameras = null;\n    // Textures\n    this._texturesEnabled = true;\n    // Physics\n    /**\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\n     */\n    this.physicsEnabled = true;\n    // Particles\n    /**\n     * Gets or sets a boolean indicating if particles are enabled on this scene\n     */\n    this.particlesEnabled = true;\n    // Sprites\n    /**\n     * Gets or sets a boolean indicating if sprites are enabled on this scene\n     */\n    this.spritesEnabled = true;\n    // Skeletons\n    this._skeletonsEnabled = true;\n    // Lens flares\n    /**\n     * Gets or sets a boolean indicating if lens flares are enabled on this scene\n     */\n    this.lensFlaresEnabled = true;\n    // Collisions\n    /**\n     * Gets or sets a boolean indicating if collisions are enabled on this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    this.collisionsEnabled = true;\n    /**\n     * Defines the gravity applied to this scene (used only for collisions)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    this.gravity = new Vector3(0, -9.807, 0);\n    // Postprocesses\n    /**\n     * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n     */\n    this.postProcessesEnabled = true;\n    // Customs render targets\n    /**\n     * Gets or sets a boolean indicating if render targets are enabled on this scene\n     */\n    this.renderTargetsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n     * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n     */\n    this.dumpNextRenderTargets = false;\n    /**\n     * The list of user defined render targets added to the scene\n     */\n    this.customRenderTargets = new Array();\n    /**\n     * Gets the list of meshes imported to the scene through SceneLoader\n     */\n    this.importedMeshesFiles = new Array();\n    // Probes\n    /**\n     * Gets or sets a boolean indicating if probes are enabled on this scene\n     */\n    this.probesEnabled = true;\n    this._meshesForIntersections = new SmartArrayNoDuplicate(256);\n    // Procedural textures\n    /**\n     * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n     */\n    this.proceduralTexturesEnabled = true;\n    // Performance counters\n    this._totalVertices = new PerfCounter();\n    /** @internal */\n    this._activeIndices = new PerfCounter();\n    /** @internal */\n    this._activeParticles = new PerfCounter();\n    /** @internal */\n    this._activeBones = new PerfCounter();\n    /** @internal */\n    this._animationTime = 0;\n    /**\n     * Gets or sets a general scale for animation speed\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\n     */\n    this.animationTimeScale = 1;\n    this._renderId = 0;\n    this._frameId = 0;\n    this._executeWhenReadyTimeoutId = null;\n    this._intermediateRendering = false;\n    this._defaultFrameBufferCleared = false;\n    this._viewUpdateFlag = -1;\n    this._projectionUpdateFlag = -1;\n    /** @internal */\n    this._toBeDisposed = new Array(256);\n    this._activeRequests = new Array();\n    /** @internal */\n    this._pendingData = new Array();\n    this._isDisposed = false;\n    /**\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n     */\n    this.dispatchAllSubMeshesOfActiveMeshes = false;\n    this._activeMeshes = new SmartArray(256);\n    this._processedMaterials = new SmartArray(256);\n    this._renderTargets = new SmartArrayNoDuplicate(256);\n    this._materialsRenderTargets = new SmartArrayNoDuplicate(256);\n    /** @internal */\n    this._activeParticleSystems = new SmartArray(256);\n    this._activeSkeletons = new SmartArrayNoDuplicate(32);\n    this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n    /** @internal */\n    this._activeAnimatables = new Array();\n    this._transformMatrix = Matrix.Zero();\n    /**\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n     * This is useful if there are more lights that the maximum simulteanous authorized\n     */\n    this.requireLightSorting = false;\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n    this._components = [];\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n    this._serializableComponents = [];\n    /**\n     * List of components to register on the next registration step.\n     */\n    this._transientComponents = [];\n    /**\n     * @internal\n     * Defines the actions happening before camera updates.\n     */\n    this._beforeCameraUpdateStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n    this._beforeClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n    this._beforeRenderTargetClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions when collecting render targets for the frame.\n     */\n    this._gatherRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening for one camera in the frame.\n     */\n    this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per mesh ready checks.\n     */\n    this._isReadyForMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before evaluate active mesh checks.\n     */\n    this._beforeEvaluateActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the evaluate sub mesh checks.\n     */\n    this._evaluateSubMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the active mesh stage.\n     */\n    this._preActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per camera render target step.\n     */\n    this._cameraDrawRenderTargetStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before the active camera is drawing.\n     */\n    this._beforeCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a render target is drawing.\n     */\n    this._beforeRenderTargetDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a rendering group is drawing.\n     */\n    this._beforeRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a mesh is drawing.\n     */\n    this._beforeRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a mesh has been drawn.\n     */\n    this._afterRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a rendering group has been drawn.\n     */\n    this._afterRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after the active camera has been drawn.\n     */\n    this._afterCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after the post processing\n     */\n    this._afterCameraPostProcessStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a render target has been drawn.\n     */\n    this._afterRenderTargetDrawStage = Stage.Create();\n    /**\n     * Defines the actions happening just after the post processing on a render target\n     */\n    this._afterRenderTargetPostProcessStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after rendering all cameras and computing intersections.\n     */\n    this._afterRenderStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer move event happens.\n     */\n    this._pointerMoveStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer down event happens.\n     */\n    this._pointerDownStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer up event happens.\n     */\n    this._pointerUpStage = Stage.Create();\n    /**\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\n     */\n    this._geometriesByUniqueId = null;\n    this._defaultMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    this._defaultSubMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    this._preventFreeActiveMeshesAndRenderingGroups = false;\n    /** @internal */\n    this._activeMeshesFrozen = false;\n    /** @internal */\n    this._activeMeshesFrozenButKeepClipping = false;\n    this._skipEvaluateActiveMeshesCompletely = false;\n    /** @internal */\n    this._allowPostProcessClearColor = true;\n    /**\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n     */\n    this.getDeterministicFrameTime = () => {\n      return this._engine.getTimeStep();\n    };\n    /** @internal */\n    this._registeredActions = 0;\n    this._blockMaterialDirtyMechanism = false;\n    /**\n     * Internal perfCollector instance used for sharing between inspector and playground.\n     * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n     */\n    this._perfCollector = null;\n    this.activeCameras = new Array();\n    const fullOptions = Object.assign({\n      useGeometryUniqueIdsMap: true,\n      useMaterialMeshMap: true,\n      useClonedMeshMap: true,\n      virtual: false\n    }, options);\n    this._engine = engine || EngineStore.LastCreatedEngine;\n    if (!fullOptions.virtual) {\n      EngineStore._LastCreatedScene = this;\n      this._engine.scenes.push(this);\n    } else {\n      this._engine._virtualScenes.push(this);\n    }\n    this._uid = null;\n    this._renderingManager = new RenderingManager(this);\n    if (PostProcessManager) {\n      this.postProcessManager = new PostProcessManager(this);\n    }\n    if (IsWindowObjectExist()) {\n      this.attachControl();\n    }\n    // Uniform Buffer\n    this._createUbo();\n    // Default Image processing definition\n    if (ImageProcessingConfiguration) {\n      this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n    }\n    this.setDefaultCandidateProviders();\n    if (fullOptions.useGeometryUniqueIdsMap) {\n      this._geometriesByUniqueId = {};\n    }\n    this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n    this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n    if (!options || !options.virtual) {\n      this._engine.onNewSceneAddedObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"Scene\" string\n   */\n  getClassName() {\n    return \"Scene\";\n  }\n  /**\n   * @internal\n   */\n  _getDefaultMeshCandidates() {\n    this._defaultMeshCandidates.data = this.meshes;\n    this._defaultMeshCandidates.length = this.meshes.length;\n    return this._defaultMeshCandidates;\n  }\n  /**\n   * @internal\n   */\n  _getDefaultSubMeshCandidates(mesh) {\n    this._defaultSubMeshCandidates.data = mesh.subMeshes;\n    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n    return this._defaultSubMeshCandidates;\n  }\n  /**\n   * Sets the default candidate providers for the scene.\n   * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n   * and getCollidingSubMeshCandidates to their default function\n   */\n  setDefaultCandidateProviders() {\n    this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates();\n    this.getActiveSubMeshCandidates = mesh => this._getDefaultSubMeshCandidates(mesh);\n    this.getIntersectingSubMeshCandidates = (mesh, localRay) => this._getDefaultSubMeshCandidates(mesh);\n    this.getCollidingSubMeshCandidates = (mesh, collider) => this._getDefaultSubMeshCandidates(mesh);\n  }\n  /**\n   * Gets the mesh that is currently under the pointer\n   */\n  get meshUnderPointer() {\n    return this._inputManager.meshUnderPointer;\n  }\n  /**\n   * Gets or sets the current on-screen X position of the pointer\n   */\n  get pointerX() {\n    return this._inputManager.pointerX;\n  }\n  set pointerX(value) {\n    this._inputManager.pointerX = value;\n  }\n  /**\n   * Gets or sets the current on-screen Y position of the pointer\n   */\n  get pointerY() {\n    return this._inputManager.pointerY;\n  }\n  set pointerY(value) {\n    this._inputManager.pointerY = value;\n  }\n  /**\n   * Gets the cached material (ie. the latest rendered one)\n   * @returns the cached material\n   */\n  getCachedMaterial() {\n    return this._cachedMaterial;\n  }\n  /**\n   * Gets the cached effect (ie. the latest rendered one)\n   * @returns the cached effect\n   */\n  getCachedEffect() {\n    return this._cachedEffect;\n  }\n  /**\n   * Gets the cached visibility state (ie. the latest rendered one)\n   * @returns the cached visibility state\n   */\n  getCachedVisibility() {\n    return this._cachedVisibility;\n  }\n  /**\n   * Gets a boolean indicating if the current material / effect / visibility must be bind again\n   * @param material defines the current material\n   * @param effect defines the current effect\n   * @param visibility defines the current visibility state\n   * @returns true if one parameter is not cached\n   */\n  isCachedMaterialInvalid(material, effect, visibility = 1) {\n    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n  }\n  /**\n   * Gets the engine associated with the scene\n   * @returns an Engine\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * Gets the total number of vertices rendered per frame\n   * @returns the total number of vertices rendered per frame\n   */\n  getTotalVertices() {\n    return this._totalVertices.current;\n  }\n  /**\n   * Gets the performance counter for total vertices\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get totalVerticesPerfCounter() {\n    return this._totalVertices;\n  }\n  /**\n   * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n   * @returns the total number of active indices rendered per frame\n   */\n  getActiveIndices() {\n    return this._activeIndices.current;\n  }\n  /**\n   * Gets the performance counter for active indices\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get totalActiveIndicesPerfCounter() {\n    return this._activeIndices;\n  }\n  /**\n   * Gets the total number of active particles rendered per frame\n   * @returns the total number of active particles rendered per frame\n   */\n  getActiveParticles() {\n    return this._activeParticles.current;\n  }\n  /**\n   * Gets the performance counter for active particles\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get activeParticlesPerfCounter() {\n    return this._activeParticles;\n  }\n  /**\n   * Gets the total number of active bones rendered per frame\n   * @returns the total number of active bones rendered per frame\n   */\n  getActiveBones() {\n    return this._activeBones.current;\n  }\n  /**\n   * Gets the performance counter for active bones\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get activeBonesPerfCounter() {\n    return this._activeBones;\n  }\n  /**\n   * Gets the array of active meshes\n   * @returns an array of AbstractMesh\n   */\n  getActiveMeshes() {\n    return this._activeMeshes;\n  }\n  /**\n   * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n   * @returns a number\n   */\n  getAnimationRatio() {\n    return this._animationRatio !== undefined ? this._animationRatio : 1;\n  }\n  /**\n   * Gets an unique Id for the current render phase\n   * @returns a number\n   */\n  getRenderId() {\n    return this._renderId;\n  }\n  /**\n   * Gets an unique Id for the current frame\n   * @returns a number\n   */\n  getFrameId() {\n    return this._frameId;\n  }\n  /** Call this function if you want to manually increment the render Id*/\n  incrementRenderId() {\n    this._renderId++;\n  }\n  _createUbo() {\n    this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n  }\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @returns the current scene\n   */\n  simulatePointerMove(pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n    return this;\n  }\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @returns the current scene\n   */\n  simulatePointerDown(pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n    return this;\n  }\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n   * @returns the current scene\n   */\n  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n    return this;\n  }\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n  isPointerCaptured(pointerId = 0) {\n    return this._inputManager.isPointerCaptured(pointerId);\n  }\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp defines if you want to attach events to pointerup\n   * @param attachDown defines if you want to attach events to pointerdown\n   * @param attachMove defines if you want to attach events to pointermove\n   */\n  attachControl(attachUp = true, attachDown = true, attachMove = true) {\n    this._inputManager.attachControl(attachUp, attachDown, attachMove);\n  }\n  /** Detaches all event handlers*/\n  detachControl() {\n    this._inputManager.detachControl();\n  }\n  /**\n   * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n   * Delay loaded resources are not taking in account\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n   * @returns true if all required resources are ready\n   */\n  isReady(checkRenderTargets = true) {\n    var _a, _b, _c;\n    if (this._isDisposed) {\n      return false;\n    }\n    let index;\n    const engine = this.getEngine();\n    const currentRenderPassId = engine.currentRenderPassId;\n    engine.currentRenderPassId = (_b = (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : currentRenderPassId;\n    let isReady = true;\n    // Pending data\n    if (this._pendingData.length > 0) {\n      isReady = false;\n    }\n    // Ensures that the pre-pass renderer is enabled if it is to be enabled.\n    (_c = this.prePassRenderer) === null || _c === void 0 ? void 0 : _c.update();\n    // Meshes\n    if (checkRenderTargets) {\n      this._processedMaterials.reset();\n      this._materialsRenderTargets.reset();\n    }\n    for (index = 0; index < this.meshes.length; index++) {\n      const mesh = this.meshes[index];\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n        continue;\n      }\n      // Do not stop at the first encountered \"unready\" object as we want to ensure\n      // all materials are starting off their compilation in parallel.\n      if (!mesh.isReady(true)) {\n        isReady = false;\n        continue;\n      }\n      const hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && mesh.instances.length > 0;\n      // Is Ready For Mesh\n      for (const step of this._isReadyForMeshStage) {\n        if (!step.action(mesh, hardwareInstancedRendering)) {\n          isReady = false;\n        }\n      }\n      if (!checkRenderTargets) {\n        continue;\n      }\n      const mat = mesh.material || this.defaultMaterial;\n      if (mat) {\n        if (mat._storeEffectOnSubMeshes) {\n          for (const subMesh of mesh.subMeshes) {\n            const material = subMesh.getMaterial();\n            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n              if (this._processedMaterials.indexOf(material) === -1) {\n                this._processedMaterials.push(material);\n                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n              }\n            }\n          }\n        } else {\n          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n            if (this._processedMaterials.indexOf(mat) === -1) {\n              this._processedMaterials.push(mat);\n              this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());\n            }\n          }\n        }\n      }\n    }\n    // Render targets\n    if (checkRenderTargets) {\n      for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n        const rtt = this._materialsRenderTargets.data[index];\n        if (!rtt.isReadyForRendering()) {\n          isReady = false;\n        }\n      }\n    }\n    // Geometries\n    for (index = 0; index < this.geometries.length; index++) {\n      const geometry = this.geometries[index];\n      if (geometry.delayLoadState === 2) {\n        isReady = false;\n      }\n    }\n    // Post-processes\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (const camera of this.activeCameras) {\n        if (!camera.isReady(true)) {\n          isReady = false;\n        }\n      }\n    } else if (this.activeCamera) {\n      if (!this.activeCamera.isReady(true)) {\n        isReady = false;\n      }\n    }\n    // Particles\n    for (const particleSystem of this.particleSystems) {\n      if (!particleSystem.isReady()) {\n        isReady = false;\n      }\n    }\n    // Layers\n    if (this.layers) {\n      for (const layer of this.layers) {\n        if (!layer.isReady()) {\n          isReady = false;\n        }\n      }\n    }\n    // Effects\n    if (!engine.areAllEffectsReady()) {\n      isReady = false;\n    }\n    engine.currentRenderPassId = currentRenderPassId;\n    return isReady;\n  }\n  /** Resets all cached information relative to material (including effect and visibility) */\n  resetCachedMaterial() {\n    this._cachedMaterial = null;\n    this._cachedEffect = null;\n    this._cachedVisibility = null;\n  }\n  /**\n   * Registers a function to be called before every frame render\n   * @param func defines the function to register\n   */\n  registerBeforeRender(func) {\n    this.onBeforeRenderObservable.add(func);\n  }\n  /**\n   * Unregisters a function called before every frame render\n   * @param func defines the function to unregister\n   */\n  unregisterBeforeRender(func) {\n    this.onBeforeRenderObservable.removeCallback(func);\n  }\n  /**\n   * Registers a function to be called after every frame render\n   * @param func defines the function to register\n   */\n  registerAfterRender(func) {\n    this.onAfterRenderObservable.add(func);\n  }\n  /**\n   * Unregisters a function called after every frame render\n   * @param func defines the function to unregister\n   */\n  unregisterAfterRender(func) {\n    this.onAfterRenderObservable.removeCallback(func);\n  }\n  _executeOnceBeforeRender(func) {\n    const execFunc = () => {\n      func();\n      setTimeout(() => {\n        this.unregisterBeforeRender(execFunc);\n      });\n    };\n    this.registerBeforeRender(execFunc);\n  }\n  /**\n   * The provided function will run before render once and will be disposed afterwards.\n   * A timeout delay can be provided so that the function will be executed in N ms.\n   * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n   * @param func The function to be executed.\n   * @param timeout optional delay in ms\n   */\n  executeOnceBeforeRender(func, timeout) {\n    if (timeout !== undefined) {\n      setTimeout(() => {\n        this._executeOnceBeforeRender(func);\n      }, timeout);\n    } else {\n      this._executeOnceBeforeRender(func);\n    }\n  }\n  /**\n   * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.\n   * @param data defines the object to wait for\n   */\n  addPendingData(data) {\n    this._pendingData.push(data);\n  }\n  /**\n   * Remove a pending data from the loading list which has previously been added with addPendingData.\n   * @param data defines the object to remove from the pending list\n   */\n  removePendingData(data) {\n    const wasLoading = this.isLoading;\n    const index = this._pendingData.indexOf(data);\n    if (index !== -1) {\n      this._pendingData.splice(index, 1);\n    }\n    if (wasLoading && !this.isLoading) {\n      this.onDataLoadedObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Returns the number of items waiting to be loaded\n   * @returns the number of items waiting to be loaded\n   */\n  getWaitingItemsCount() {\n    return this._pendingData.length;\n  }\n  /**\n   * Returns a boolean indicating if the scene is still loading data\n   */\n  get isLoading() {\n    return this._pendingData.length > 0;\n  }\n  /**\n   * Registers a function to be executed when the scene is ready\n   * @param func - the function to be executed\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n   */\n  executeWhenReady(func, checkRenderTargets = false) {\n    this.onReadyObservable.addOnce(func);\n    if (this._executeWhenReadyTimeoutId !== null) {\n      return;\n    }\n    this._checkIsReady(checkRenderTargets);\n  }\n  /**\n   * Returns a promise that resolves when the scene is ready\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n   * @returns A promise that resolves when the scene is ready\n   */\n  whenReadyAsync(checkRenderTargets = false) {\n    return new Promise(resolve => {\n      this.executeWhenReady(() => {\n        resolve();\n      }, checkRenderTargets);\n    });\n  }\n  /**\n   * @internal\n   */\n  _checkIsReady(checkRenderTargets = false) {\n    this._registerTransientComponents();\n    if (this.isReady(checkRenderTargets)) {\n      this.onReadyObservable.notifyObservers(this);\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = null;\n      return;\n    }\n    if (this._isDisposed) {\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = null;\n      return;\n    }\n    this._executeWhenReadyTimeoutId = setTimeout(() => {\n      // Ensure materials effects are checked outside render loops\n      this.incrementRenderId();\n      this._checkIsReady(checkRenderTargets);\n    }, 100);\n  }\n  /**\n   * Gets all animatable attached to the scene\n   */\n  get animatables() {\n    return this._activeAnimatables;\n  }\n  /**\n   * Resets the last animation time frame.\n   * Useful to override when animations start running when loading a scene for the first time.\n   */\n  resetLastAnimationTimeFrame() {\n    this._animationTimeLast = PrecisionDate.Now;\n  }\n  // Matrix\n  /**\n   * Gets the current view matrix\n   * @returns a Matrix\n   */\n  getViewMatrix() {\n    return this._viewMatrix;\n  }\n  /**\n   * Gets the current projection matrix\n   * @returns a Matrix\n   */\n  getProjectionMatrix() {\n    return this._projectionMatrix;\n  }\n  /**\n   * Gets the current transform matrix\n   * @returns a Matrix made of View * Projection\n   */\n  getTransformMatrix() {\n    return this._transformMatrix;\n  }\n  /**\n   * Sets the current transform matrix\n   * @param viewL defines the View matrix to use\n   * @param projectionL defines the Projection matrix to use\n   * @param viewR defines the right View matrix to use (if provided)\n   * @param projectionR defines the right Projection matrix to use (if provided)\n   */\n  setTransformMatrix(viewL, projectionL, viewR, projectionR) {\n    // clear the multiviewSceneUbo if no viewR and projectionR are defined\n    if (!viewR && !projectionR && this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n      this._multiviewSceneUbo = null;\n    }\n    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n      return;\n    }\n    this._viewUpdateFlag = viewL.updateFlag;\n    this._projectionUpdateFlag = projectionL.updateFlag;\n    this._viewMatrix = viewL;\n    this._projectionMatrix = projectionL;\n    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n    // Update frustum\n    if (!this._frustumPlanes) {\n      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n    } else {\n      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n    }\n    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n      this._updateMultiviewUbo(viewR, projectionR);\n    } else if (this._sceneUbo.useUbo) {\n      this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n      this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n      this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n    }\n  }\n  /**\n   * Gets the uniform buffer used to store scene data\n   * @returns a UniformBuffer\n   */\n  getSceneUniformBuffer() {\n    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n  }\n  /**\n   * Creates a scene UBO\n   * @param name name of the uniform buffer (optional, for debugging purpose only)\n   * @returns a new ubo\n   */\n  createSceneUniformBuffer(name) {\n    const sceneUbo = new UniformBuffer(this._engine, undefined, false, name !== null && name !== void 0 ? name : \"scene\");\n    sceneUbo.addUniform(\"viewProjection\", 16);\n    sceneUbo.addUniform(\"view\", 16);\n    sceneUbo.addUniform(\"projection\", 16);\n    sceneUbo.addUniform(\"vEyePosition\", 4);\n    return sceneUbo;\n  }\n  /**\n   * Sets the scene ubo\n   * @param ubo the ubo to set for the scene\n   */\n  setSceneUniformBuffer(ubo) {\n    this._sceneUbo = ubo;\n    this._viewUpdateFlag = -1;\n    this._projectionUpdateFlag = -1;\n  }\n  /**\n   * Gets an unique (relatively to the current scene) Id\n   * @returns an unique number for the scene\n   */\n  getUniqueId() {\n    return UniqueIdGenerator.UniqueId;\n  }\n  /**\n   * Add a mesh to the list of scene's meshes\n   * @param newMesh defines the mesh to add\n   * @param recursive if all child meshes should also be added to the scene\n   */\n  addMesh(newMesh, recursive = false) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.meshes.push(newMesh);\n    newMesh._resyncLightSources();\n    if (!newMesh.parent) {\n      newMesh._addToSceneRootNodes();\n    }\n    this.onNewMeshAddedObservable.notifyObservers(newMesh);\n    if (recursive) {\n      newMesh.getChildMeshes().forEach(m => {\n        this.addMesh(m);\n      });\n    }\n  }\n  /**\n   * Remove a mesh for the list of scene's meshes\n   * @param toRemove defines the mesh to remove\n   * @param recursive if all child meshes should also be removed from the scene\n   * @returns the index where the mesh was in the mesh list\n   */\n  removeMesh(toRemove, recursive = false) {\n    const index = this.meshes.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.meshes[index] = this.meshes[this.meshes.length - 1];\n      this.meshes.pop();\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    this._inputManager._invalidateMesh(toRemove);\n    this.onMeshRemovedObservable.notifyObservers(toRemove);\n    if (recursive) {\n      toRemove.getChildMeshes().forEach(m => {\n        this.removeMesh(m);\n      });\n    }\n    return index;\n  }\n  /**\n   * Add a transform node to the list of scene's transform nodes\n   * @param newTransformNode defines the transform node to add\n   */\n  addTransformNode(newTransformNode) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n      // Already there?\n      return;\n    }\n    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n    this.transformNodes.push(newTransformNode);\n    if (!newTransformNode.parent) {\n      newTransformNode._addToSceneRootNodes();\n    }\n    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n  }\n  /**\n   * Remove a transform node for the list of scene's transform nodes\n   * @param toRemove defines the transform node to remove\n   * @returns the index where the transform node was in the transform node list\n   */\n  removeTransformNode(toRemove) {\n    const index = toRemove._indexInSceneTransformNodesArray;\n    if (index !== -1) {\n      if (index !== this.transformNodes.length - 1) {\n        const lastNode = this.transformNodes[this.transformNodes.length - 1];\n        this.transformNodes[index] = lastNode;\n        lastNode._indexInSceneTransformNodesArray = index;\n      }\n      toRemove._indexInSceneTransformNodesArray = -1;\n      this.transformNodes.pop();\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Remove a skeleton for the list of scene's skeletons\n   * @param toRemove defines the skeleton to remove\n   * @returns the index where the skeleton was in the skeleton list\n   */\n  removeSkeleton(toRemove) {\n    const index = this.skeletons.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.skeletons.splice(index, 1);\n      this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n      // Clean active container\n      this._executeActiveContainerCleanup(this._activeSkeletons);\n    }\n    return index;\n  }\n  /**\n   * Remove a morph target for the list of scene's morph targets\n   * @param toRemove defines the morph target to remove\n   * @returns the index where the morph target was in the morph target list\n   */\n  removeMorphTargetManager(toRemove) {\n    const index = this.morphTargetManagers.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.morphTargetManagers.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Remove a light for the list of scene's lights\n   * @param toRemove defines the light to remove\n   * @returns the index where the light was in the light list\n   */\n  removeLight(toRemove) {\n    const index = this.lights.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from meshes\n      for (const mesh of this.meshes) {\n        mesh._removeLightSource(toRemove, false);\n      }\n      // Remove from the scene if mesh found\n      this.lights.splice(index, 1);\n      this.sortLightsByPriority();\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    this.onLightRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Remove a camera for the list of scene's cameras\n   * @param toRemove defines the camera to remove\n   * @returns the index where the camera was in the camera list\n   */\n  removeCamera(toRemove) {\n    const index = this.cameras.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.cameras.splice(index, 1);\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    // Remove from activeCameras\n    if (this.activeCameras) {\n      const index2 = this.activeCameras.indexOf(toRemove);\n      if (index2 !== -1) {\n        // Remove from the scene if mesh found\n        this.activeCameras.splice(index2, 1);\n      }\n    }\n    // Reset the activeCamera\n    if (this.activeCamera === toRemove) {\n      if (this.cameras.length > 0) {\n        this.activeCamera = this.cameras[0];\n      } else {\n        this.activeCamera = null;\n      }\n    }\n    this.onCameraRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Remove a particle system for the list of scene's particle systems\n   * @param toRemove defines the particle system to remove\n   * @returns the index where the particle system was in the particle system list\n   */\n  removeParticleSystem(toRemove) {\n    const index = this.particleSystems.indexOf(toRemove);\n    if (index !== -1) {\n      this.particleSystems.splice(index, 1);\n      // Clean active container\n      this._executeActiveContainerCleanup(this._activeParticleSystems);\n    }\n    return index;\n  }\n  /**\n   * Remove a animation for the list of scene's animations\n   * @param toRemove defines the animation to remove\n   * @returns the index where the animation was in the animation list\n   */\n  removeAnimation(toRemove) {\n    const index = this.animations.indexOf(toRemove);\n    if (index !== -1) {\n      this.animations.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Will stop the animation of the given target\n   * @param target - the target\n   * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n   */\n  stopAnimation(target, animationName, targetMask) {\n    // Do nothing as code will be provided by animation component\n  }\n  /**\n   * Removes the given animation group from this scene.\n   * @param toRemove The animation group to remove\n   * @returns The index of the removed animation group\n   */\n  removeAnimationGroup(toRemove) {\n    const index = this.animationGroups.indexOf(toRemove);\n    if (index !== -1) {\n      this.animationGroups.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Removes the given multi-material from this scene.\n   * @param toRemove The multi-material to remove\n   * @returns The index of the removed multi-material\n   */\n  removeMultiMaterial(toRemove) {\n    const index = this.multiMaterials.indexOf(toRemove);\n    if (index !== -1) {\n      this.multiMaterials.splice(index, 1);\n    }\n    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Removes the given material from this scene.\n   * @param toRemove The material to remove\n   * @returns The index of the removed material\n   */\n  removeMaterial(toRemove) {\n    const index = toRemove._indexInSceneMaterialArray;\n    if (index !== -1 && index < this.materials.length) {\n      if (index !== this.materials.length - 1) {\n        const lastMaterial = this.materials[this.materials.length - 1];\n        this.materials[index] = lastMaterial;\n        lastMaterial._indexInSceneMaterialArray = index;\n      }\n      toRemove._indexInSceneMaterialArray = -1;\n      this.materials.pop();\n    }\n    this.onMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Removes the given action manager from this scene.\n   * @deprecated\n   * @param toRemove The action manager to remove\n   * @returns The index of the removed action manager\n   */\n  removeActionManager(toRemove) {\n    const index = this.actionManagers.indexOf(toRemove);\n    if (index !== -1) {\n      this.actionManagers.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Removes the given texture from this scene.\n   * @param toRemove The texture to remove\n   * @returns The index of the removed texture\n   */\n  removeTexture(toRemove) {\n    const index = this.textures.indexOf(toRemove);\n    if (index !== -1) {\n      this.textures.splice(index, 1);\n    }\n    this.onTextureRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Adds the given light to this scene\n   * @param newLight The light to add\n   */\n  addLight(newLight) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.lights.push(newLight);\n    this.sortLightsByPriority();\n    if (!newLight.parent) {\n      newLight._addToSceneRootNodes();\n    }\n    // Add light to all meshes (To support if the light is removed and then re-added)\n    for (const mesh of this.meshes) {\n      if (mesh.lightSources.indexOf(newLight) === -1) {\n        mesh.lightSources.push(newLight);\n        mesh._resyncLightSources();\n      }\n    }\n    this.onNewLightAddedObservable.notifyObservers(newLight);\n  }\n  /**\n   * Sorts the list list based on light priorities\n   */\n  sortLightsByPriority() {\n    if (this.requireLightSorting) {\n      this.lights.sort(LightConstants.CompareLightsPriority);\n    }\n  }\n  /**\n   * Adds the given camera to this scene\n   * @param newCamera The camera to add\n   */\n  addCamera(newCamera) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.cameras.push(newCamera);\n    this.onNewCameraAddedObservable.notifyObservers(newCamera);\n    if (!newCamera.parent) {\n      newCamera._addToSceneRootNodes();\n    }\n  }\n  /**\n   * Adds the given skeleton to this scene\n   * @param newSkeleton The skeleton to add\n   */\n  addSkeleton(newSkeleton) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.skeletons.push(newSkeleton);\n    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n  }\n  /**\n   * Adds the given particle system to this scene\n   * @param newParticleSystem The particle system to add\n   */\n  addParticleSystem(newParticleSystem) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.particleSystems.push(newParticleSystem);\n  }\n  /**\n   * Adds the given animation to this scene\n   * @param newAnimation The animation to add\n   */\n  addAnimation(newAnimation) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.animations.push(newAnimation);\n  }\n  /**\n   * Adds the given animation group to this scene.\n   * @param newAnimationGroup The animation group to add\n   */\n  addAnimationGroup(newAnimationGroup) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.animationGroups.push(newAnimationGroup);\n  }\n  /**\n   * Adds the given multi-material to this scene\n   * @param newMultiMaterial The multi-material to add\n   */\n  addMultiMaterial(newMultiMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.multiMaterials.push(newMultiMaterial);\n    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n  }\n  /**\n   * Adds the given material to this scene\n   * @param newMaterial The material to add\n   */\n  addMaterial(newMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n      // Already there??\n      return;\n    }\n    newMaterial._indexInSceneMaterialArray = this.materials.length;\n    this.materials.push(newMaterial);\n    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n  }\n  /**\n   * Adds the given morph target to this scene\n   * @param newMorphTargetManager The morph target to add\n   */\n  addMorphTargetManager(newMorphTargetManager) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.morphTargetManagers.push(newMorphTargetManager);\n  }\n  /**\n   * Adds the given geometry to this scene\n   * @param newGeometry The geometry to add\n   */\n  addGeometry(newGeometry) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    if (this._geometriesByUniqueId) {\n      this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n    }\n    this.geometries.push(newGeometry);\n  }\n  /**\n   * Adds the given action manager to this scene\n   * @deprecated\n   * @param newActionManager The action manager to add\n   */\n  addActionManager(newActionManager) {\n    this.actionManagers.push(newActionManager);\n  }\n  /**\n   * Adds the given texture to this scene.\n   * @param newTexture The texture to add\n   */\n  addTexture(newTexture) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.textures.push(newTexture);\n    this.onNewTextureAddedObservable.notifyObservers(newTexture);\n  }\n  /**\n   * Switch active camera\n   * @param newCamera defines the new active camera\n   * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n   */\n  switchActiveCamera(newCamera, attachControl = true) {\n    const canvas = this._engine.getInputElement();\n    if (!canvas) {\n      return;\n    }\n    if (this.activeCamera) {\n      this.activeCamera.detachControl();\n    }\n    this.activeCamera = newCamera;\n    if (attachControl) {\n      newCamera.attachControl();\n    }\n  }\n  /**\n   * sets the active camera of the scene using its Id\n   * @param id defines the camera's Id\n   * @returns the new active camera or null if none found.\n   */\n  setActiveCameraById(id) {\n    const camera = this.getCameraById(id);\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n    return null;\n  }\n  /**\n   * sets the active camera of the scene using its name\n   * @param name defines the camera's name\n   * @returns the new active camera or null if none found.\n   */\n  setActiveCameraByName(name) {\n    const camera = this.getCameraByName(name);\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n    return null;\n  }\n  /**\n   * get an animation group using its name\n   * @param name defines the material's name\n   * @returns the animation group or null if none found.\n   */\n  getAnimationGroupByName(name) {\n    for (let index = 0; index < this.animationGroups.length; index++) {\n      if (this.animationGroups[index].name === name) {\n        return this.animationGroups[index];\n      }\n    }\n    return null;\n  }\n  _getMaterial(allowMultiMaterials, predicate) {\n    for (let index = 0; index < this.materials.length; index++) {\n      const material = this.materials[index];\n      if (predicate(material)) {\n        return material;\n      }\n    }\n    if (allowMultiMaterials) {\n      for (let index = 0; index < this.multiMaterials.length; index++) {\n        const material = this.multiMaterials[index];\n        if (predicate(material)) {\n          return material;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Get a material using its unique id\n   * @param uniqueId defines the material's unique id\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the material or null if none found.\n   */\n  getMaterialByUniqueID(uniqueId, allowMultiMaterials = false) {\n    return this._getMaterial(allowMultiMaterials, m => m.uniqueId === uniqueId);\n  }\n  /**\n   * get a material using its id\n   * @param id defines the material's Id\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the material or null if none found.\n   */\n  getMaterialById(id, allowMultiMaterials = false) {\n    return this._getMaterial(allowMultiMaterials, m => m.id === id);\n  }\n  /**\n   * Gets a material using its name\n   * @param name defines the material's name\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the material or null if none found.\n   */\n  getMaterialByName(name, allowMultiMaterials = false) {\n    return this._getMaterial(allowMultiMaterials, m => m.name === name);\n  }\n  /**\n   * Gets a last added material using a given id\n   * @param id defines the material's id\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the last material with the given id or null if none found.\n   */\n  getLastMaterialById(id, allowMultiMaterials = false) {\n    for (let index = this.materials.length - 1; index >= 0; index--) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n    if (allowMultiMaterials) {\n      for (let index = this.multiMaterials.length - 1; index >= 0; index--) {\n        if (this.multiMaterials[index].id === id) {\n          return this.multiMaterials[index];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Get a texture using its unique id\n   * @param uniqueId defines the texture's unique id\n   * @returns the texture or null if none found.\n   */\n  getTextureByUniqueId(uniqueId) {\n    for (let index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].uniqueId === uniqueId) {\n        return this.textures[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a texture using its name\n   * @param name defines the texture's name\n   * @returns the texture or null if none found.\n   */\n  getTextureByName(name) {\n    for (let index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].name === name) {\n        return this.textures[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a camera using its Id\n   * @param id defines the Id to look for\n   * @returns the camera or null if not found\n   */\n  getCameraById(id) {\n    for (let index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a camera using its unique Id\n   * @param uniqueId defines the unique Id to look for\n   * @returns the camera or null if not found\n   */\n  getCameraByUniqueId(uniqueId) {\n    for (let index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].uniqueId === uniqueId) {\n        return this.cameras[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a camera using its name\n   * @param name defines the camera's name\n   * @returns the camera or null if none found.\n   */\n  getCameraByName(name) {\n    for (let index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].name === name) {\n        return this.cameras[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a bone using its Id\n   * @param id defines the bone's Id\n   * @returns the bone or null if not found\n   */\n  getBoneById(id) {\n    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      const skeleton = this.skeletons[skeletonIndex];\n      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].id === id) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a bone using its id\n   * @param name defines the bone's name\n   * @returns the bone or null if not found\n   */\n  getBoneByName(name) {\n    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      const skeleton = this.skeletons[skeletonIndex];\n      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].name === name) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a light node using its name\n   * @param name defines the the light's name\n   * @returns the light or null if none found.\n   */\n  getLightByName(name) {\n    for (let index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].name === name) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a light node using its Id\n   * @param id defines the light's Id\n   * @returns the light or null if none found.\n   */\n  getLightById(id) {\n    for (let index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a light node using its scene-generated unique Id\n   * @param uniqueId defines the light's unique Id\n   * @returns the light or null if none found.\n   */\n  getLightByUniqueId(uniqueId) {\n    for (let index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].uniqueId === uniqueId) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a particle system by Id\n   * @param id defines the particle system Id\n   * @returns the corresponding system or null if none found\n   */\n  getParticleSystemById(id) {\n    for (let index = 0; index < this.particleSystems.length; index++) {\n      if (this.particleSystems[index].id === id) {\n        return this.particleSystems[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a geometry using its Id\n   * @param id defines the geometry's Id\n   * @returns the geometry or null if none found.\n   */\n  getGeometryById(id) {\n    for (let index = 0; index < this.geometries.length; index++) {\n      if (this.geometries[index].id === id) {\n        return this.geometries[index];\n      }\n    }\n    return null;\n  }\n  _getGeometryByUniqueId(uniqueId) {\n    if (this._geometriesByUniqueId) {\n      const index = this._geometriesByUniqueId[uniqueId];\n      if (index !== undefined) {\n        return this.geometries[index];\n      }\n    } else {\n      for (let index = 0; index < this.geometries.length; index++) {\n        if (this.geometries[index].uniqueId === uniqueId) {\n          return this.geometries[index];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Add a new geometry to this scene\n   * @param geometry defines the geometry to be added to the scene.\n   * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n   * @returns a boolean defining if the geometry was added or not\n   */\n  pushGeometry(geometry, force) {\n    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n      return false;\n    }\n    this.addGeometry(geometry);\n    this.onNewGeometryAddedObservable.notifyObservers(geometry);\n    return true;\n  }\n  /**\n   * Removes an existing geometry\n   * @param geometry defines the geometry to be removed from the scene\n   * @returns a boolean defining if the geometry was removed or not\n   */\n  removeGeometry(geometry) {\n    let index;\n    if (this._geometriesByUniqueId) {\n      index = this._geometriesByUniqueId[geometry.uniqueId];\n      if (index === undefined) {\n        return false;\n      }\n    } else {\n      index = this.geometries.indexOf(geometry);\n      if (index < 0) {\n        return false;\n      }\n    }\n    if (index !== this.geometries.length - 1) {\n      const lastGeometry = this.geometries[this.geometries.length - 1];\n      if (lastGeometry) {\n        this.geometries[index] = lastGeometry;\n        if (this._geometriesByUniqueId) {\n          this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n        }\n      }\n    }\n    if (this._geometriesByUniqueId) {\n      this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n    }\n    this.geometries.pop();\n    this.onGeometryRemovedObservable.notifyObservers(geometry);\n    return true;\n  }\n  /**\n   * Gets the list of geometries attached to the scene\n   * @returns an array of Geometry\n   */\n  getGeometries() {\n    return this.geometries;\n  }\n  /**\n   * Gets the first added mesh found of a given Id\n   * @param id defines the Id to search for\n   * @returns the mesh found or null if not found at all\n   */\n  getMeshById(id) {\n    for (let index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a list of meshes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of meshes\n   */\n  getMeshesById(id) {\n    return this.meshes.filter(function (m) {\n      return m.id === id;\n    });\n  }\n  /**\n   * Gets the first added transform node found of a given Id\n   * @param id defines the Id to search for\n   * @returns the found transform node or null if not found at all.\n   */\n  getTransformNodeById(id) {\n    for (let index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a transform node with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found transform node or null if not found at all.\n   */\n  getTransformNodeByUniqueId(uniqueId) {\n    for (let index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].uniqueId === uniqueId) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a list of transform nodes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of transform nodes\n   */\n  getTransformNodesById(id) {\n    return this.transformNodes.filter(function (m) {\n      return m.id === id;\n    });\n  }\n  /**\n   * Gets a mesh with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getMeshByUniqueId(uniqueId) {\n    for (let index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].uniqueId === uniqueId) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a the last added mesh using a given Id\n   * @param id defines the Id to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getLastMeshById(id) {\n    for (let index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a the last transform node using a given Id\n   * @param id defines the Id to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getLastTransformNodeById(id) {\n    for (let index = this.transformNodes.length - 1; index >= 0; index--) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a the last added node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   */\n  getLastEntryById(id) {\n    let index;\n    for (index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n    for (index = this.transformNodes.length - 1; index >= 0; index--) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n    for (index = this.cameras.length - 1; index >= 0; index--) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n    for (index = this.lights.length - 1; index >= 0; index--) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   */\n  getNodeById(id) {\n    const mesh = this.getMeshById(id);\n    if (mesh) {\n      return mesh;\n    }\n    const transformNode = this.getTransformNodeById(id);\n    if (transformNode) {\n      return transformNode;\n    }\n    const light = this.getLightById(id);\n    if (light) {\n      return light;\n    }\n    const camera = this.getCameraById(id);\n    if (camera) {\n      return camera;\n    }\n    const bone = this.getBoneById(id);\n    if (bone) {\n      return bone;\n    }\n    return null;\n  }\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given name\n   * @param name defines the name to search for\n   * @returns the found node or null if not found at all.\n   */\n  getNodeByName(name) {\n    const mesh = this.getMeshByName(name);\n    if (mesh) {\n      return mesh;\n    }\n    const transformNode = this.getTransformNodeByName(name);\n    if (transformNode) {\n      return transformNode;\n    }\n    const light = this.getLightByName(name);\n    if (light) {\n      return light;\n    }\n    const camera = this.getCameraByName(name);\n    if (camera) {\n      return camera;\n    }\n    const bone = this.getBoneByName(name);\n    if (bone) {\n      return bone;\n    }\n    return null;\n  }\n  /**\n   * Gets a mesh using a given name\n   * @param name defines the name to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getMeshByName(name) {\n    for (let index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].name === name) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a transform node using a given name\n   * @param name defines the name to search for\n   * @returns the found transform node or null if not found at all.\n   */\n  getTransformNodeByName(name) {\n    for (let index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].name === name) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n   * @param id defines the Id to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getLastSkeletonById(id) {\n    for (let index = this.skeletons.length - 1; index >= 0; index--) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given auto generated unique id\n   * @param  uniqueId defines the unique id to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getSkeletonByUniqueId(uniqueId) {\n    for (let index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].uniqueId === uniqueId) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n   * @param id defines the id to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getSkeletonById(id) {\n    for (let index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given name\n   * @param name defines the name to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getSkeletonByName(name) {\n    for (let index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].name === name) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n   * @param id defines the id to search for\n   * @returns the found morph target manager or null if not found at all.\n   */\n  getMorphTargetManagerById(id) {\n    for (let index = 0; index < this.morphTargetManagers.length; index++) {\n      if (this.morphTargetManagers[index].uniqueId === id) {\n        return this.morphTargetManagers[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a morph target using a given id (if many are found, this function will pick the first one)\n   * @param id defines the id to search for\n   * @returns the found morph target or null if not found at all.\n   */\n  getMorphTargetById(id) {\n    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      const morphTargetManager = this.morphTargetManagers[managerIndex];\n      for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n        const target = morphTargetManager.getTarget(index);\n        if (target.id === id) {\n          return target;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a morph target using a given name (if many are found, this function will pick the first one)\n   * @param name defines the name to search for\n   * @returns the found morph target or null if not found at all.\n   */\n  getMorphTargetByName(name) {\n    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      const morphTargetManager = this.morphTargetManagers[managerIndex];\n      for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n        const target = morphTargetManager.getTarget(index);\n        if (target.name === name) {\n          return target;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a post process using a given name (if many are found, this function will pick the first one)\n   * @param name defines the name to search for\n   * @returns the found post process or null if not found at all.\n   */\n  getPostProcessByName(name) {\n    for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n      const postProcess = this.postProcesses[postProcessIndex];\n      if (postProcess.name === name) {\n        return postProcess;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a boolean indicating if the given mesh is active\n   * @param mesh defines the mesh to look for\n   * @returns true if the mesh is in the active list\n   */\n  isActiveMesh(mesh) {\n    return this._activeMeshes.indexOf(mesh) !== -1;\n  }\n  /**\n   * Return a unique id as a string which can serve as an identifier for the scene\n   */\n  get uid() {\n    if (!this._uid) {\n      this._uid = Tools.RandomId();\n    }\n    return this._uid;\n  }\n  /**\n   * Add an externally attached data from its key.\n   * This method call will fail and return false, if such key already exists.\n   * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n   * @param key the unique key that identifies the data\n   * @param data the data object to associate to the key for this Engine instance\n   * @returns true if no such key were already present and the data was added successfully, false otherwise\n   */\n  addExternalData(key, data) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n    return this._externalData.add(key, data);\n  }\n  /**\n   * Get an externally attached data from its key\n   * @param key the unique key that identifies the data\n   * @returns the associated data, if present (can be null), or undefined if not present\n   */\n  getExternalData(key) {\n    if (!this._externalData) {\n      return null;\n    }\n    return this._externalData.get(key);\n  }\n  /**\n   * Get an externally attached data from its key, create it using a factory if it's not already present\n   * @param key the unique key that identifies the data\n   * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n   * @returns the associated data, can be null if the factory returned null.\n   */\n  getOrAddExternalDataWithFactory(key, factory) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n    return this._externalData.getOrAddWithFactory(key, factory);\n  }\n  /**\n   * Remove an externally attached data from the Engine instance\n   * @param key the unique key that identifies the data\n   * @returns true if the data was successfully removed, false if it doesn't exist\n   */\n  removeExternalData(key) {\n    return this._externalData.remove(key);\n  }\n  _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {\n    if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {\n      for (const step of this._evaluateSubMeshStage) {\n        step.action(mesh, subMesh);\n      }\n      const material = subMesh.getMaterial();\n      if (material !== null && material !== undefined) {\n        // Render targets\n        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n          if (this._processedMaterials.indexOf(material) === -1) {\n            this._processedMaterials.push(material);\n            this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n          }\n        }\n        // Dispatch\n        this._renderingManager.dispatch(subMesh, mesh, material);\n      }\n    }\n  }\n  /**\n   * Clear the processed materials smart array preventing retention point in material dispose.\n   */\n  freeProcessedMaterials() {\n    this._processedMaterials.dispose();\n  }\n  /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n   * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n   * when disposing several meshes in a row or a hierarchy of meshes.\n   * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n   */\n  get blockfreeActiveMeshesAndRenderingGroups() {\n    return this._preventFreeActiveMeshesAndRenderingGroups;\n  }\n  set blockfreeActiveMeshesAndRenderingGroups(value) {\n    if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n      return;\n    }\n    if (value) {\n      this.freeActiveMeshes();\n      this.freeRenderingGroups();\n    }\n    this._preventFreeActiveMeshesAndRenderingGroups = value;\n  }\n  /**\n   * Clear the active meshes smart array preventing retention point in mesh dispose.\n   */\n  freeActiveMeshes() {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n    this._activeMeshes.dispose();\n    if (this.activeCamera && this.activeCamera._activeMeshes) {\n      this.activeCamera._activeMeshes.dispose();\n    }\n    if (this.activeCameras) {\n      for (let i = 0; i < this.activeCameras.length; i++) {\n        const activeCamera = this.activeCameras[i];\n        if (activeCamera && activeCamera._activeMeshes) {\n          activeCamera._activeMeshes.dispose();\n        }\n      }\n    }\n  }\n  /**\n   * Clear the info related to rendering groups preventing retention points during dispose.\n   */\n  freeRenderingGroups() {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n    if (this._renderingManager) {\n      this._renderingManager.freeRenderingGroups();\n    }\n    if (this.textures) {\n      for (let i = 0; i < this.textures.length; i++) {\n        const texture = this.textures[i];\n        if (texture && texture.renderList) {\n          texture.freeRenderingGroups();\n        }\n      }\n    }\n  }\n  /** @internal */\n  _isInIntermediateRendering() {\n    return this._intermediateRendering;\n  }\n  /**\n   * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n   * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n   * @param onSuccess optional success callback\n   * @param onError optional error callback\n   * @param freezeMeshes defines if meshes should be frozen (true by default)\n   * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)\n   * @returns the current scene\n   */\n  freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess, onError, freezeMeshes = true, keepFrustumCulling = false) {\n    this.executeWhenReady(() => {\n      if (!this.activeCamera) {\n        onError && onError(\"No active camera found\");\n        return;\n      }\n      if (!this._frustumPlanes) {\n        this.updateTransformMatrix();\n      }\n      this._evaluateActiveMeshes();\n      this._activeMeshesFrozen = true;\n      this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;\n      this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n      if (freezeMeshes) {\n        for (let index = 0; index < this._activeMeshes.length; index++) {\n          this._activeMeshes.data[index]._freeze();\n        }\n      }\n      onSuccess && onSuccess();\n    });\n    return this;\n  }\n  /**\n   * Use this function to restart evaluating active meshes on every frame\n   * @returns the current scene\n   */\n  unfreezeActiveMeshes() {\n    for (let index = 0; index < this.meshes.length; index++) {\n      const mesh = this.meshes[index];\n      if (mesh._internalAbstractMeshDataInfo) {\n        mesh._internalAbstractMeshDataInfo._isActive = false;\n      }\n    }\n    for (let index = 0; index < this._activeMeshes.length; index++) {\n      this._activeMeshes.data[index]._unFreeze();\n    }\n    this._activeMeshesFrozen = false;\n    return this;\n  }\n  _executeActiveContainerCleanup(container) {\n    const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n      return; // Do not execute in frozen mode\n    }\n    // We need to ensure we are not in the rendering loop\n    this.onBeforeRenderObservable.addOnce(() => container.dispose());\n  }\n  _evaluateActiveMeshes() {\n    var _a;\n    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {\n      if (this._activeMeshes.length > 0) {\n        (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();\n        this._activeMeshes.reset();\n        this._renderingManager.reset();\n        this._processedMaterials.reset();\n        this._activeParticleSystems.reset();\n        this._activeSkeletons.reset();\n        this._softwareSkinnedMeshes.reset();\n      }\n      return;\n    }\n    if (this._activeMeshesFrozen && this._activeMeshes.length) {\n      if (!this._skipEvaluateActiveMeshesCompletely) {\n        const len = this._activeMeshes.length;\n        for (let i = 0; i < len; i++) {\n          const mesh = this._activeMeshes.data[i];\n          mesh.computeWorldMatrix();\n        }\n      }\n      if (this._activeParticleSystems) {\n        const psLength = this._activeParticleSystems.length;\n        for (let i = 0; i < psLength; i++) {\n          this._activeParticleSystems.data[i].animate();\n        }\n      }\n      this._renderingManager.resetSprites();\n      return;\n    }\n    if (!this.activeCamera) {\n      return;\n    }\n    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n    this.activeCamera._activeMeshes.reset();\n    this._activeMeshes.reset();\n    this._renderingManager.reset();\n    this._processedMaterials.reset();\n    this._activeParticleSystems.reset();\n    this._activeSkeletons.reset();\n    this._softwareSkinnedMeshes.reset();\n    this._materialsRenderTargets.reset();\n    for (const step of this._beforeEvaluateActiveMeshStage) {\n      step.action();\n    }\n    // Determine mesh candidates\n    const meshes = this.getActiveMeshCandidates();\n    // Check each mesh\n    const len = meshes.length;\n    for (let i = 0; i < len; i++) {\n      const mesh = meshes.data[i];\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n      if (mesh.isBlocked) {\n        continue;\n      }\n      this._totalVertices.addCount(mesh.getTotalVertices(), false);\n      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {\n        continue;\n      }\n      mesh.computeWorldMatrix();\n      // Intersections\n      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n        this._meshesForIntersections.pushNoDuplicate(mesh);\n      }\n      // Switch to current LOD\n      let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n      if (meshToRender === undefined || meshToRender === null) {\n        continue;\n      }\n      // Compute world matrix if LOD is billboard\n      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\n        meshToRender.computeWorldMatrix();\n      }\n      mesh._preActivate();\n      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n        this._activeMeshes.push(mesh);\n        this.activeCamera._activeMeshes.push(mesh);\n        if (meshToRender !== mesh) {\n          meshToRender._activate(this._renderId, false);\n        }\n        for (const step of this._preActiveMeshStage) {\n          step.action(mesh);\n        }\n        if (mesh._activate(this._renderId, false)) {\n          if (!mesh.isAnInstance) {\n            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n          } else {\n            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n              meshToRender = mesh;\n            }\n          }\n          meshToRender._internalAbstractMeshDataInfo._isActive = true;\n          this._activeMesh(mesh, meshToRender);\n        }\n        mesh._postActivate();\n      }\n    }\n    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\n    // Particle systems\n    if (this.particlesEnabled) {\n      this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n      for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n        const particleSystem = this.particleSystems[particleIndex];\n        if (!particleSystem.isStarted() || !particleSystem.emitter) {\n          continue;\n        }\n        const emitter = particleSystem.emitter;\n        if (!emitter.position || emitter.isEnabled()) {\n          this._activeParticleSystems.push(particleSystem);\n          particleSystem.animate();\n          this._renderingManager.dispatchParticles(particleSystem);\n        }\n      }\n      this.onAfterParticlesRenderingObservable.notifyObservers(this);\n    }\n  }\n  _activeMesh(sourceMesh, mesh) {\n    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n        mesh.skeleton.prepare();\n        this._activeBones.addCount(mesh.skeleton.bones.length, false);\n      }\n      if (!mesh.computeBonesUsingShaders) {\n        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n      }\n    }\n    let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;\n    if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {\n      const subMeshes = this.getActiveSubMeshCandidates(mesh);\n      const len = subMeshes.length;\n      forcePush = forcePush || len === 1;\n      for (let i = 0; i < len; i++) {\n        const subMesh = subMeshes.data[i];\n        this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);\n      }\n    }\n  }\n  /**\n   * Update the transform matrix to update from the current active camera\n   * @param force defines a boolean used to force the update even if cache is up to date\n   */\n  updateTransformMatrix(force) {\n    if (!this.activeCamera) {\n      return;\n    }\n    if (this.activeCamera._renderingMultiview) {\n      const leftCamera = this.activeCamera._rigCameras[0];\n      const rightCamera = this.activeCamera._rigCameras[1];\n      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n    } else {\n      this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n    }\n  }\n  _bindFrameBuffer(camera, clear = true) {\n    if (camera && camera._multiviewTexture) {\n      camera._multiviewTexture._bindFrameBuffer();\n    } else if (camera && camera.outputRenderTarget) {\n      camera.outputRenderTarget._bindFrameBuffer();\n    } else {\n      if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n        this._engine.restoreDefaultFramebuffer();\n      }\n    }\n    if (clear) {\n      this._clearFrameBuffer(camera);\n    }\n  }\n  _clearFrameBuffer(camera) {\n    // we assume the framebuffer currently bound is the right one\n    if (camera && camera._multiviewTexture) {\n      // no clearing?\n    } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {\n      const rtt = camera.outputRenderTarget;\n      if (rtt.onClearObservable.hasObservers()) {\n        rtt.onClearObservable.notifyObservers(this._engine);\n      } else if (!rtt.skipInitialClear) {\n        if (this.autoClear) {\n          this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\n        }\n        rtt._cleared = true;\n      }\n    } else {\n      if (!this._defaultFrameBufferCleared) {\n        this._defaultFrameBufferCleared = true;\n        this._clear();\n      } else {\n        this._engine.clear(null, false, true, true);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _renderForCamera(camera, rigParent, bindFrameBuffer = true) {\n    var _a, _b, _c;\n    if (camera && camera._skipRendering) {\n      return;\n    }\n    const engine = this._engine;\n    // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n    this._activeCamera = camera;\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    }\n    // Viewport\n    engine.setViewport(this.activeCamera.viewport);\n    // Camera\n    this.resetCachedMaterial();\n    this._renderId++;\n    if (!this.prePass && bindFrameBuffer) {\n      let skipInitialClear = true;\n      if (camera._renderingMultiview && camera.outputRenderTarget) {\n        skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n        if (this.autoClear) {\n          this._defaultFrameBufferCleared = false;\n          camera.outputRenderTarget.skipInitialClear = false;\n        }\n      }\n      this._bindFrameBuffer(this._activeCamera);\n      if (camera._renderingMultiview && camera.outputRenderTarget) {\n        camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n      }\n    }\n    this.updateTransformMatrix();\n    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\n    // Meshes\n    this._evaluateActiveMeshes();\n    // Software skinning\n    for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n      const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n      mesh.applySkeleton(mesh.skeleton);\n    }\n    // Render targets\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n    this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n    }\n    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n    }\n    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n      this._renderTargets.pushNoDuplicate(this.environmentTexture);\n    }\n    // Collects render targets from external components.\n    for (const step of this._gatherActiveCameraRenderTargetsStage) {\n      step.action(this._renderTargets);\n    }\n    let needRebind = false;\n    if (this.renderTargetsEnabled) {\n      this._intermediateRendering = true;\n      if (this._renderTargets.length > 0) {\n        Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n        for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n          const renderTarget = this._renderTargets.data[renderIndex];\n          if (renderTarget._shouldRender()) {\n            this._renderId++;\n            const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n            needRebind = true;\n          }\n        }\n        Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n        this._renderId++;\n      }\n      for (const step of this._cameraDrawRenderTargetStage) {\n        needRebind = step.action(this.activeCamera) || needRebind;\n      }\n      this._intermediateRendering = false;\n    }\n    this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n    // Restore framebuffer after rendering to targets\n    if (needRebind && !this.prePass) {\n      this._bindFrameBuffer(this._activeCamera, false);\n    }\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n    // Prepare Frame\n    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n      this.postProcessManager._prepareFrame();\n    }\n    // Before Camera Draw\n    for (const step of this._beforeCameraDrawStage) {\n      step.action(this.activeCamera);\n    }\n    // Render\n    this.onBeforeDrawPhaseObservable.notifyObservers(this);\n    if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {\n      this.finalizeSceneUbo();\n    }\n    this._renderingManager.render(null, null, true, true);\n    this.onAfterDrawPhaseObservable.notifyObservers(this);\n    // After Camera Draw\n    for (const step of this._afterCameraDrawStage) {\n      step.action(this.activeCamera);\n    }\n    // Finalize frame\n    if (this.postProcessManager && !camera._multiviewTexture) {\n      // if the camera has an output render target, render the post process to the render target\n      const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : undefined;\n      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n    }\n    // After post process\n    for (const step of this._afterCameraPostProcessStage) {\n      step.action(this.activeCamera);\n    }\n    // Reset some special arrays\n    this._renderTargets.reset();\n    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n  }\n  _processSubCameras(camera, bindFrameBuffer = true) {\n    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {\n      if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n        this._createMultiviewUbo();\n      }\n      this._renderForCamera(camera, undefined, bindFrameBuffer);\n      this.onAfterRenderCameraObservable.notifyObservers(camera);\n      return;\n    }\n    if (camera._useMultiviewToSingleView) {\n      this._renderMultiviewToSingleView(camera);\n    } else {\n      // rig cameras\n      this.onBeforeCameraRenderObservable.notifyObservers(camera);\n      for (let index = 0; index < camera._rigCameras.length; index++) {\n        this._renderForCamera(camera._rigCameras[index], camera);\n      }\n    }\n    // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n    this._activeCamera = camera;\n    this.updateTransformMatrix();\n    this.onAfterRenderCameraObservable.notifyObservers(camera);\n  }\n  _checkIntersections() {\n    for (let index = 0; index < this._meshesForIntersections.length; index++) {\n      const sourceMesh = this._meshesForIntersections.data[index];\n      if (!sourceMesh.actionManager) {\n        continue;\n      }\n      for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n        const action = sourceMesh.actionManager.actions[actionIndex];\n        if (action.trigger === 12 || action.trigger === 13) {\n          const parameters = action.getTriggerParameter();\n          const otherMesh = parameters.mesh ? parameters.mesh : parameters;\n          const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n          const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n          if (areIntersecting && currentIntersectionInProgress === -1) {\n            if (action.trigger === 12) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            } else if (action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            }\n          } else if (!areIntersecting && currentIntersectionInProgress > -1) {\n            //They intersected, and now they don't.\n            //is this trigger an exit trigger? execute an event.\n            if (action.trigger === 13) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n            }\n            //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n            if (!sourceMesh.actionManager.hasSpecificTrigger(13, parameter => {\n              const parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n              return otherMesh === parameterMesh;\n            }) || action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _advancePhysicsEngineStep(step) {\n    // Do nothing. Code will be replaced if physics engine component is referenced\n  }\n  /** @internal */\n  _animate() {\n    // Nothing to do as long as Animatable have not been imported.\n  }\n  /** Execute all animations (for a frame) */\n  animate() {\n    if (this._engine.isDeterministicLockStep()) {\n      let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n      const defaultFrameTime = this._engine.getTimeStep();\n      const defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n      let stepsTaken = 0;\n      const maxSubSteps = this._engine.getLockstepMaxSteps();\n      let internalSteps = Math.floor(deltaTime / defaultFrameTime);\n      internalSteps = Math.min(internalSteps, maxSubSteps);\n      while (deltaTime > 0 && stepsTaken < internalSteps) {\n        this.onBeforeStepObservable.notifyObservers(this);\n        // Animations\n        this._animationRatio = defaultFrameTime * defaultFPS;\n        this._animate();\n        this.onAfterAnimationsObservable.notifyObservers(this);\n        // Physics\n        if (this.physicsEnabled) {\n          this._advancePhysicsEngineStep(defaultFrameTime);\n        }\n        this.onAfterStepObservable.notifyObservers(this);\n        this._currentStepId++;\n        stepsTaken++;\n        deltaTime -= defaultFrameTime;\n      }\n      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n    } else {\n      // Animations\n      const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n      this._animationRatio = deltaTime * (60.0 / 1000.0);\n      this._animate();\n      this.onAfterAnimationsObservable.notifyObservers(this);\n      // Physics\n      if (this.physicsEnabled) {\n        this._advancePhysicsEngineStep(deltaTime);\n      }\n    }\n  }\n  _clear() {\n    if (this.autoClearDepthAndStencil || this.autoClear) {\n      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n    }\n  }\n  _checkCameraRenderTarget(camera) {\n    var _a;\n    if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {\n      camera.outputRenderTarget._cleared = false;\n    }\n    if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {\n      for (let i = 0; i < camera.rigCameras.length; ++i) {\n        const rtt = camera.rigCameras[i].outputRenderTarget;\n        if (rtt) {\n          rtt._cleared = false;\n        }\n      }\n    }\n  }\n  /**\n   * Resets the draw wrappers cache of all meshes\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n  resetDrawCache(passId) {\n    if (!this.meshes) {\n      return;\n    }\n    for (const mesh of this.meshes) {\n      mesh.resetDrawCache(passId);\n    }\n  }\n  /**\n   * Render the scene\n   * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n   * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n   */\n  render(updateCameras = true, ignoreAnimations = false) {\n    var _a, _b, _c;\n    if (this.isDisposed) {\n      return;\n    }\n    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n      this._checkIsReady();\n    }\n    this._frameId++;\n    this._defaultFrameBufferCleared = false;\n    this._checkCameraRenderTarget(this.activeCamera);\n    if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {\n      this.activeCameras.forEach(this._checkCameraRenderTarget);\n    }\n    // Register components that have been associated lately to the scene.\n    this._registerTransientComponents();\n    this._activeParticles.fetchNewFrame();\n    this._totalVertices.fetchNewFrame();\n    this._activeIndices.fetchNewFrame();\n    this._activeBones.fetchNewFrame();\n    this._meshesForIntersections.reset();\n    this.resetCachedMaterial();\n    this.onBeforeAnimationsObservable.notifyObservers(this);\n    // Actions\n    if (this.actionManager) {\n      this.actionManager.processTrigger(11);\n    }\n    // Animations\n    if (!ignoreAnimations) {\n      this.animate();\n    }\n    // Before camera update steps\n    for (const step of this._beforeCameraUpdateStage) {\n      step.action();\n    }\n    // Update Cameras\n    if (updateCameras) {\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n          const camera = this.activeCameras[cameraIndex];\n          camera.update();\n          if (camera.cameraRigMode !== 0) {\n            // rig cameras\n            for (let index = 0; index < camera._rigCameras.length; index++) {\n              camera._rigCameras[index].update();\n            }\n          }\n        }\n      } else if (this.activeCamera) {\n        this.activeCamera.update();\n        if (this.activeCamera.cameraRigMode !== 0) {\n          // rig cameras\n          for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {\n            this.activeCamera._rigCameras[index].update();\n          }\n        }\n      }\n    }\n    // Before render\n    this.onBeforeRenderObservable.notifyObservers(this);\n    const engine = this.getEngine();\n    // Customs render targets\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n    const currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;\n    if (this.renderTargetsEnabled) {\n      Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = true;\n      for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n        const renderTarget = this.customRenderTargets[customIndex];\n        if (renderTarget._shouldRender()) {\n          this._renderId++;\n          this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n          if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n          }\n          // Viewport\n          engine.setViewport(this.activeCamera.viewport);\n          // Camera\n          this.updateTransformMatrix();\n          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n        }\n      }\n      Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = false;\n      this._renderId++;\n    }\n    this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n    // Restore back buffer\n    this.activeCamera = currentActiveCamera;\n    if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {\n      this._bindFrameBuffer(this._activeCamera, false);\n    }\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n    for (const step of this._beforeClearStage) {\n      step.action();\n    }\n    // Clear\n    this._clearFrameBuffer(this.activeCamera);\n    // Collects render targets from external components.\n    for (const step of this._gatherRenderTargetsStage) {\n      step.action(this._renderTargets);\n    }\n    // Multi-cameras?\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n        this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);\n      }\n    } else {\n      if (!this.activeCamera) {\n        throw new Error(\"No camera defined\");\n      }\n      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n    }\n    // Intersection checks\n    this._checkIntersections();\n    // Executes the after render stage actions.\n    for (const step of this._afterRenderStage) {\n      step.action();\n    }\n    // After render\n    if (this.afterRender) {\n      this.afterRender();\n    }\n    this.onAfterRenderObservable.notifyObservers(this);\n    // Cleaning\n    if (this._toBeDisposed.length) {\n      for (let index = 0; index < this._toBeDisposed.length; index++) {\n        const data = this._toBeDisposed[index];\n        if (data) {\n          data.dispose();\n        }\n      }\n      this._toBeDisposed.length = 0;\n    }\n    if (this.dumpNextRenderTargets) {\n      this.dumpNextRenderTargets = false;\n    }\n    this._activeBones.addCount(0, true);\n    this._activeIndices.addCount(0, true);\n    this._activeParticles.addCount(0, true);\n    this._engine.restoreDefaultFramebuffer();\n  }\n  /**\n   * Freeze all materials\n   * A frozen material will not be updatable but should be faster to render\n   * Note: multimaterials will not be frozen, but their submaterials will\n   */\n  freezeMaterials() {\n    for (let i = 0; i < this.materials.length; i++) {\n      this.materials[i].freeze();\n    }\n  }\n  /**\n   * Unfreeze all materials\n   * A frozen material will not be updatable but should be faster to render\n   */\n  unfreezeMaterials() {\n    for (let i = 0; i < this.materials.length; i++) {\n      this.materials[i].unfreeze();\n    }\n  }\n  /**\n   * Releases all held resources\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n    this.beforeRender = null;\n    this.afterRender = null;\n    this.metadata = null;\n    this.skeletons.length = 0;\n    this.morphTargetManagers.length = 0;\n    this._transientComponents.length = 0;\n    this._isReadyForMeshStage.clear();\n    this._beforeEvaluateActiveMeshStage.clear();\n    this._evaluateSubMeshStage.clear();\n    this._preActiveMeshStage.clear();\n    this._cameraDrawRenderTargetStage.clear();\n    this._beforeCameraDrawStage.clear();\n    this._beforeRenderTargetDrawStage.clear();\n    this._beforeRenderingGroupDrawStage.clear();\n    this._beforeRenderingMeshStage.clear();\n    this._afterRenderingMeshStage.clear();\n    this._afterRenderingGroupDrawStage.clear();\n    this._afterCameraDrawStage.clear();\n    this._afterRenderTargetDrawStage.clear();\n    this._afterRenderStage.clear();\n    this._beforeCameraUpdateStage.clear();\n    this._beforeClearStage.clear();\n    this._gatherRenderTargetsStage.clear();\n    this._gatherActiveCameraRenderTargetsStage.clear();\n    this._pointerMoveStage.clear();\n    this._pointerDownStage.clear();\n    this._pointerUpStage.clear();\n    this.importedMeshesFiles = new Array();\n    if (this.stopAllAnimations) {\n      // Ensures that no animatable notifies a callback that could start a new animation group, constantly adding new animatables to the active list...\n      this._activeAnimatables.forEach(animatable => {\n        animatable.onAnimationEndObservable.clear();\n        animatable.onAnimationEnd = null;\n      });\n      this.stopAllAnimations();\n    }\n    this.resetCachedMaterial();\n    // Smart arrays\n    if (this.activeCamera) {\n      this.activeCamera._activeMeshes.dispose();\n      this.activeCamera = null;\n    }\n    this.activeCameras = null;\n    this._activeMeshes.dispose();\n    this._renderingManager.dispose();\n    this._processedMaterials.dispose();\n    this._activeParticleSystems.dispose();\n    this._activeSkeletons.dispose();\n    this._softwareSkinnedMeshes.dispose();\n    this._renderTargets.dispose();\n    this._materialsRenderTargets.dispose();\n    this._registeredForLateAnimationBindings.dispose();\n    this._meshesForIntersections.dispose();\n    this._toBeDisposed.length = 0;\n    // Abort active requests\n    const activeRequests = this._activeRequests.slice();\n    for (const request of activeRequests) {\n      request.abort();\n    }\n    this._activeRequests.length = 0;\n    // Events\n    try {\n      this.onDisposeObservable.notifyObservers(this);\n    } catch (e) {\n      console.error(\"An error occurred while calling onDisposeObservable!\", e);\n    }\n    this.detachControl();\n    // Detach cameras\n    const canvas = this._engine.getInputElement();\n    if (canvas) {\n      for (let index = 0; index < this.cameras.length; index++) {\n        this.cameras[index].detachControl();\n      }\n    }\n    // Release animation groups\n    this._disposeList(this.animationGroups);\n    // Release lights\n    this._disposeList(this.lights);\n    // Release meshes\n    this._disposeList(this.meshes, item => item.dispose(true));\n    this._disposeList(this.transformNodes, item => item.dispose(true));\n    // Release cameras\n    const cameras = this.cameras;\n    this._disposeList(cameras);\n    // Release materials\n    if (this._defaultMaterial) {\n      this._defaultMaterial.dispose();\n    }\n    this._disposeList(this.multiMaterials);\n    this._disposeList(this.materials);\n    // Release particles\n    this._disposeList(this.particleSystems);\n    // Release postProcesses\n    this._disposeList(this.postProcesses);\n    // Release textures\n    this._disposeList(this.textures);\n    // Release morph targets\n    this._disposeList(this.morphTargetManagers);\n    // Release UBO\n    this._sceneUbo.dispose();\n    if (this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n    }\n    // Post-processes\n    this.postProcessManager.dispose();\n    // Components\n    this._disposeList(this._components);\n    // Remove from engine\n    let index = this._engine.scenes.indexOf(this);\n    if (index > -1) {\n      this._engine.scenes.splice(index, 1);\n    }\n    if (EngineStore._LastCreatedScene === this) {\n      if (this._engine.scenes.length > 0) {\n        EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n      } else {\n        EngineStore._LastCreatedScene = null;\n      }\n    }\n    index = this._engine._virtualScenes.indexOf(this);\n    if (index > -1) {\n      this._engine._virtualScenes.splice(index, 1);\n    }\n    this._engine.wipeCaches(true);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderTargetsRenderObservable.clear();\n    this.onAfterRenderTargetsRenderObservable.clear();\n    this.onAfterStepObservable.clear();\n    this.onBeforeStepObservable.clear();\n    this.onBeforeActiveMeshesEvaluationObservable.clear();\n    this.onAfterActiveMeshesEvaluationObservable.clear();\n    this.onBeforeParticlesRenderingObservable.clear();\n    this.onAfterParticlesRenderingObservable.clear();\n    this.onBeforeDrawPhaseObservable.clear();\n    this.onAfterDrawPhaseObservable.clear();\n    this.onBeforeAnimationsObservable.clear();\n    this.onAfterAnimationsObservable.clear();\n    this.onDataLoadedObservable.clear();\n    this.onBeforeRenderingGroupObservable.clear();\n    this.onAfterRenderingGroupObservable.clear();\n    this.onMeshImportedObservable.clear();\n    this.onBeforeCameraRenderObservable.clear();\n    this.onAfterCameraRenderObservable.clear();\n    this.onAfterRenderCameraObservable.clear();\n    this.onReadyObservable.clear();\n    this.onNewCameraAddedObservable.clear();\n    this.onCameraRemovedObservable.clear();\n    this.onNewLightAddedObservable.clear();\n    this.onLightRemovedObservable.clear();\n    this.onNewGeometryAddedObservable.clear();\n    this.onGeometryRemovedObservable.clear();\n    this.onNewTransformNodeAddedObservable.clear();\n    this.onTransformNodeRemovedObservable.clear();\n    this.onNewMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onNewSkeletonAddedObservable.clear();\n    this.onSkeletonRemovedObservable.clear();\n    this.onNewMaterialAddedObservable.clear();\n    this.onNewMultiMaterialAddedObservable.clear();\n    this.onMaterialRemovedObservable.clear();\n    this.onMultiMaterialRemovedObservable.clear();\n    this.onNewTextureAddedObservable.clear();\n    this.onTextureRemovedObservable.clear();\n    this.onPrePointerObservable.clear();\n    this.onPointerObservable.clear();\n    this.onPreKeyboardObservable.clear();\n    this.onKeyboardObservable.clear();\n    this.onActiveCameraChanged.clear();\n    this.onScenePerformancePriorityChangedObservable.clear();\n    this._isDisposed = true;\n  }\n  _disposeList(items, callback) {\n    const itemsCopy = items.slice(0);\n    callback = callback !== null && callback !== void 0 ? callback : item => item.dispose();\n    for (const item of itemsCopy) {\n      callback(item);\n    }\n    items.length = 0;\n  }\n  /**\n   * Gets if the scene is already disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Call this function to reduce memory footprint of the scene.\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n   */\n  clearCachedVertexData() {\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n      const mesh = this.meshes[meshIndex];\n      const geometry = mesh.geometry;\n      if (geometry) {\n        geometry.clearCachedData();\n      }\n    }\n  }\n  /**\n   * This function will remove the local cached buffer data from texture.\n   * It will save memory but will prevent the texture from being rebuilt\n   */\n  cleanCachedTextureBuffer() {\n    for (const baseTexture of this.textures) {\n      const buffer = baseTexture._buffer;\n      if (buffer) {\n        baseTexture._buffer = null;\n      }\n    }\n  }\n  /**\n   * Get the world extend vectors with an optional filter\n   *\n   * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n   * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n   */\n  getWorldExtends(filterPredicate) {\n    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    filterPredicate = filterPredicate || (() => true);\n    this.meshes.filter(filterPredicate).forEach(mesh => {\n      mesh.computeWorldMatrix(true);\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n        return;\n      }\n      const boundingInfo = mesh.getBoundingInfo();\n      const minBox = boundingInfo.boundingBox.minimumWorld;\n      const maxBox = boundingInfo.boundingBox.maximumWorld;\n      Vector3.CheckExtends(minBox, min, max);\n      Vector3.CheckExtends(maxBox, min, max);\n    });\n    return {\n      min: min,\n      max: max\n    };\n  }\n  // Picking\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n   * @param camera defines the camera to use for the picking\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\n   * @returns a Ray\n   */\n  createPickingRay(x, y, world, camera, cameraViewSpace = false) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n   * @param result defines the ray where to store the picking ray\n   * @param camera defines the camera to use for the picking\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\n   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n   * @returns the current scene\n   */\n  createPickingRayToRef(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param camera defines the camera to use for the picking\n   * @returns a Ray\n   */\n  createPickingRayInCameraSpace(x, y, camera) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param result defines the ray where to store the picking ray\n   * @param camera defines the camera to use for the picking\n   * @returns the current scene\n   */\n  createPickingRayInCameraSpaceToRef(x, y, result, camera) {\n    throw _WarnImport(\"Ray\");\n  }\n  /** @internal */\n  get _pickingAvailable() {\n    return false;\n  }\n  /** Launch a ray to try to pick a mesh in the scene\n   * @param x position on screen\n   * @param y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns a PickingInfo\n   */\n  pick(x, y, predicate, fastCheck, camera, trianglePredicate) {\n    // Dummy info if picking as not been imported\n    return new PickingInfo();\n  }\n  /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n   * @param x position on screen\n   * @param y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n   */\n  pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {\n    // Dummy info if picking as not been imported\n    return new PickingInfo();\n  }\n  /**\n   * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n   * irrespective of orientation.\n   * @param ray The ray to use to pick meshes\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns a PickingInfo\n   */\n  pickWithRay(ray, predicate, fastCheck, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n   * irrespective of orientation.\n   * @param x X position on screen\n   * @param y Y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns an array of PickingInfo\n   */\n  multiPick(x, y, predicate, camera, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Launch a ray to try to pick a mesh in the scene\n   * @param ray Ray to use\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns an array of PickingInfo\n   */\n  multiPickWithRay(ray, predicate, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh defines the mesh to use\n   * @param pointerId optional pointer id when using more than one pointer\n   * @param pickResult optional pickingInfo data used to find mesh\n   */\n  setPointerOverMesh(mesh, pointerId, pickResult) {\n    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n  }\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n  getPointerOverMesh() {\n    return this._inputManager.getPointerOverMesh();\n  }\n  // Misc.\n  /** @internal */\n  _rebuildGeometries() {\n    for (const geometry of this.geometries) {\n      geometry._rebuild();\n    }\n    for (const mesh of this.meshes) {\n      mesh._rebuild();\n    }\n    if (this.postProcessManager) {\n      this.postProcessManager._rebuild();\n    }\n    for (const component of this._components) {\n      component.rebuild();\n    }\n    for (const system of this.particleSystems) {\n      system.rebuild();\n    }\n    if (this.spriteManagers) {\n      for (const spriteMgr of this.spriteManagers) {\n        spriteMgr.rebuild();\n      }\n    }\n  }\n  /** @internal */\n  _rebuildTextures() {\n    for (const texture of this.textures) {\n      texture._rebuild();\n    }\n    this.markAllMaterialsAsDirty(1);\n  }\n  /**\n   * Get from a list of objects by tags\n   * @param list the list of objects to use\n   * @param tagsQuery the query to use\n   * @param filter a predicate to filter for tags\n   * @returns\n   */\n  _getByTags(list, tagsQuery, filter) {\n    if (tagsQuery === undefined) {\n      // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n      return list;\n    }\n    const listByTags = [];\n    for (const i in list) {\n      const item = list[i];\n      if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {\n        listByTags.push(item);\n      }\n    }\n    return listByTags;\n  }\n  /**\n   * Get a list of meshes by tags\n   * @param tagsQuery defines the tags query to use\n   * @param filter defines a predicate used to filter results\n   * @returns an array of Mesh\n   */\n  getMeshesByTags(tagsQuery, filter) {\n    return this._getByTags(this.meshes, tagsQuery, filter);\n  }\n  /**\n   * Get a list of cameras by tags\n   * @param tagsQuery defines the tags query to use\n   * @param filter defines a predicate used to filter results\n   * @returns an array of Camera\n   */\n  getCamerasByTags(tagsQuery, filter) {\n    return this._getByTags(this.cameras, tagsQuery, filter);\n  }\n  /**\n   * Get a list of lights by tags\n   * @param tagsQuery defines the tags query to use\n   * @param filter defines a predicate used to filter results\n   * @returns an array of Light\n   */\n  getLightsByTags(tagsQuery, filter) {\n    return this._getByTags(this.lights, tagsQuery, filter);\n  }\n  /**\n   * Get a list of materials by tags\n   * @param tagsQuery defines the tags query to use\n   * @param filter defines a predicate used to filter results\n   * @returns an array of Material\n   */\n  getMaterialByTags(tagsQuery, filter) {\n    return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));\n  }\n  /**\n   * Get a list of transform nodes by tags\n   * @param tagsQuery defines the tags query to use\n   * @param filter defines a predicate used to filter results\n   * @returns an array of TransformNode\n   */\n  getTransformNodesByTags(tagsQuery, filter) {\n    return this._getByTags(this.transformNodes, tagsQuery, filter);\n  }\n  /**\n   * Overrides the default sort function applied in the rendering group to prepare the meshes.\n   * This allowed control for front to back rendering or reversly depending of the special needs.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n   */\n  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n  }\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n   */\n  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {\n    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n  }\n  /**\n   * Gets the current auto clear configuration for one rendering group of the rendering\n   * manager.\n   * @param index the rendering group index to get the information for\n   * @returns The auto clear setup for the requested rendering group\n   */\n  getAutoClearDepthStencilSetup(index) {\n    return this._renderingManager.getAutoClearDepthStencilSetup(index);\n  }\n  /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n  get blockMaterialDirtyMechanism() {\n    return this._blockMaterialDirtyMechanism;\n  }\n  set blockMaterialDirtyMechanism(value) {\n    if (this._blockMaterialDirtyMechanism === value) {\n      return;\n    }\n    this._blockMaterialDirtyMechanism = value;\n    if (!value) {\n      // Do a complete update\n      this.markAllMaterialsAsDirty(63);\n    }\n  }\n  /**\n   * Will flag all materials as dirty to trigger new shader compilation\n   * @param flag defines the flag used to specify which material part must be marked as dirty\n   * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n   */\n  markAllMaterialsAsDirty(flag, predicate) {\n    if (this._blockMaterialDirtyMechanism) {\n      return;\n    }\n    for (const material of this.materials) {\n      if (predicate && !predicate(material)) {\n        continue;\n      }\n      material.markAsDirty(flag);\n    }\n  }\n  /**\n   * @internal\n   */\n  _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n    this._activeRequests.push(request);\n    request.onCompleteObservable.add(request => {\n      this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  }\n  /**\n   * @internal\n   */\n  _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    return new Promise((resolve, reject) => {\n      this._loadFile(fileOrUrl, data => {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {\n        reject(exception);\n      }, onOpened);\n    });\n  }\n  /**\n   * @internal\n   */\n  _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n    this._activeRequests.push(request);\n    request.onCompleteObservable.add(request => {\n      this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  }\n  /**\n   * @internal\n   */\n  _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    return new Promise((resolve, reject) => {\n      this._requestFile(url, data => {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, error => {\n        reject(error);\n      }, onOpened);\n    });\n  }\n  /**\n   * @internal\n   */\n  _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n    const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n    this._activeRequests.push(request);\n    request.onCompleteObservable.add(request => {\n      this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  }\n  /**\n   * @internal\n   */\n  _readFileAsync(file, onProgress, useArrayBuffer) {\n    return new Promise((resolve, reject) => {\n      this._readFile(file, data => {\n        resolve(data);\n      }, onProgress, useArrayBuffer, error => {\n        reject(error);\n      });\n    });\n  }\n  /**\n   * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n   * @returns the perf collector belonging to the scene.\n   */\n  getPerfCollector() {\n    throw _WarnImport(\"performanceViewerSceneExtension\");\n  }\n  // deprecated\n  /**\n   * Sets the active camera of the scene using its Id\n   * @param id defines the camera's Id\n   * @returns the new active camera or null if none found.\n   * @deprecated Please use setActiveCameraById instead\n   */\n  setActiveCameraByID(id) {\n    return this.setActiveCameraById(id);\n  }\n  /**\n   * Get a material using its id\n   * @param id defines the material's Id\n   * @returns the material or null if none found.\n   * @deprecated Please use getMaterialById instead\n   */\n  getMaterialByID(id) {\n    return this.getMaterialById(id);\n  }\n  /**\n   * Gets a the last added material using a given id\n   * @param id defines the material's Id\n   * @returns the last material with the given id or null if none found.\n   * @deprecated Please use getLastMaterialById instead\n   */\n  getLastMaterialByID(id) {\n    return this.getLastMaterialById(id);\n  }\n  /**\n   * Get a texture using its unique id\n   * @param uniqueId defines the texture's unique id\n   * @returns the texture or null if none found.\n   * @deprecated Please use getTextureByUniqueId instead\n   */\n  getTextureByUniqueID(uniqueId) {\n    return this.getTextureByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a camera using its Id\n   * @param id defines the Id to look for\n   * @returns the camera or null if not found\n   * @deprecated Please use getCameraById instead\n   */\n  getCameraByID(id) {\n    return this.getCameraById(id);\n  }\n  /**\n   * Gets a camera using its unique Id\n   * @param uniqueId defines the unique Id to look for\n   * @returns the camera or null if not found\n   * @deprecated Please use getCameraByUniqueId instead\n   */\n  getCameraByUniqueID(uniqueId) {\n    return this.getCameraByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a bone using its Id\n   * @param id defines the bone's Id\n   * @returns the bone or null if not found\n   * @deprecated Please use getBoneById instead\n   */\n  getBoneByID(id) {\n    return this.getBoneById(id);\n  }\n  /**\n   * Gets a light node using its Id\n   * @param id defines the light's Id\n   * @returns the light or null if none found.\n   * @deprecated Please use getLightById instead\n   */\n  getLightByID(id) {\n    return this.getLightById(id);\n  }\n  /**\n   * Gets a light node using its scene-generated unique Id\n   * @param uniqueId defines the light's unique Id\n   * @returns the light or null if none found.\n   * @deprecated Please use getLightByUniqueId instead\n   */\n  getLightByUniqueID(uniqueId) {\n    return this.getLightByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a particle system by Id\n   * @param id defines the particle system Id\n   * @returns the corresponding system or null if none found\n   * @deprecated Please use getParticleSystemById instead\n   */\n  getParticleSystemByID(id) {\n    return this.getParticleSystemById(id);\n  }\n  /**\n   * Gets a geometry using its Id\n   * @param id defines the geometry's Id\n   * @returns the geometry or null if none found.\n   * @deprecated Please use getGeometryById instead\n   */\n  getGeometryByID(id) {\n    return this.getGeometryById(id);\n  }\n  /**\n   * Gets the first added mesh found of a given Id\n   * @param id defines the Id to search for\n   * @returns the mesh found or null if not found at all\n   * @deprecated Please use getMeshById instead\n   */\n  getMeshByID(id) {\n    return this.getMeshById(id);\n  }\n  /**\n   * Gets a mesh with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found mesh or null if not found at all.\n   * @deprecated Please use getMeshByUniqueId instead\n   */\n  getMeshByUniqueID(uniqueId) {\n    return this.getMeshByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a the last added mesh using a given Id\n   * @param id defines the Id to search for\n   * @returns the found mesh or null if not found at all.\n   * @deprecated Please use getLastMeshById instead\n   */\n  getLastMeshByID(id) {\n    return this.getLastMeshById(id);\n  }\n  /**\n   * Gets a list of meshes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of meshes\n   * @deprecated Please use getMeshesById instead\n   */\n  getMeshesByID(id) {\n    return this.getMeshesById(id);\n  }\n  /**\n   * Gets the first added transform node found of a given Id\n   * @param id defines the Id to search for\n   * @returns the found transform node or null if not found at all.\n   * @deprecated Please use getTransformNodeById instead\n   */\n  getTransformNodeByID(id) {\n    return this.getTransformNodeById(id);\n  }\n  /**\n   * Gets a transform node with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found transform node or null if not found at all.\n   * @deprecated Please use getTransformNodeByUniqueId instead\n   */\n  getTransformNodeByUniqueID(uniqueId) {\n    return this.getTransformNodeByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a list of transform nodes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of transform nodes\n   * @deprecated Please use getTransformNodesById instead\n   */\n  getTransformNodesByID(id) {\n    return this.getTransformNodesById(id);\n  }\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   * @deprecated Please use getNodeById instead\n   */\n  getNodeByID(id) {\n    return this.getNodeById(id);\n  }\n  /**\n   * Gets a the last added node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   * @deprecated Please use getLastEntryById instead\n   */\n  getLastEntryByID(id) {\n    return this.getLastEntryById(id);\n  }\n  /**\n   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n   * @param id defines the Id to search for\n   * @returns the found skeleton or null if not found at all.\n   * @deprecated Please use getLastSkeletonById instead\n   */\n  getLastSkeletonByID(id) {\n    return this.getLastSkeletonById(id);\n  }\n}\n/** The fog is deactivated */\nScene.FOGMODE_NONE = 0;\n/** The fog density is following an exponential function */\nScene.FOGMODE_EXP = 1;\n/** The fog density is following an exponential function faster than FOGMODE_EXP */\nScene.FOGMODE_EXP2 = 2;\n/** The fog density is following a linear function. */\nScene.FOGMODE_LINEAR = 3;\n/**\n * Gets or sets the minimum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MinDeltaTime = 1.0;\n/**\n * Gets or sets the maximum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MaxDeltaTime = 1000.0;","map":{"version":3,"names":["Tools","PrecisionDate","Observable","SmartArrayNoDuplicate","SmartArray","StringDictionary","Tags","Vector3","Matrix","TmpVectors","AbstractScene","ImageProcessingConfiguration","UniformBuffer","PickingInfo","ActionEvent","PostProcessManager","RenderingManager","Stage","IsWindowObjectExist","EngineStore","_WarnImport","InputManager","PerfCounter","Color4","Color3","Frustum","UniqueIdGenerator","ReadFile","RequestFile","LoadFile","LightConstants","_ObserveArray","PointerPickingConfiguration","ScenePerformancePriority","Scene","DefaultMaterialFactory","scene","CollisionCoordinatorFactory","environmentTexture","_environmentTexture","value","markAllMaterialsAsDirty","imageProcessingConfiguration","_imageProcessingConfiguration","performancePriority","_performancePriority","BackwardCompatible","skipFrustumClipping","_renderingManager","maintainStateBetweenFrames","skipPointerMovePicking","autoClear","Intermediate","Aggressive","onScenePerformancePriorityChangedObservable","notifyObservers","forceWireframe","_forceWireframe","_skipFrustumClipping","forcePointsCloud","_forcePointsCloud","animationPropertiesOverride","_animationPropertiesOverride","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","beforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","afterRender","_onAfterRenderObserver","onAfterRenderObservable","beforeCameraRender","_onBeforeCameraRenderObserver","onBeforeCameraRenderObservable","afterCameraRender","_onAfterCameraRenderObserver","onAfterCameraRenderObservable","pointerDownPredicate","_pointerPickingConfiguration","pointerUpPredicate","pointerMovePredicate","pointerDownFastCheck","pointerUpFastCheck","pointerMoveFastCheck","skipPointerDownPicking","skipPointerUpPicking","unTranslatedPointer","_inputManager","DragMovementThreshold","LongPressDelay","DoubleClickDelay","ExclusiveDoubleClickMode","bindEyePosition","effect","variableName","isVector3","eyePosition","_forcedViewPosition","_mirroredCameraPosition","activeCamera","globalPosition","invertNormal","useRightHandedSystem","Vector4","set","x","y","z","setFloat3","setVector4","finalizeSceneUbo","ubo","getSceneUniformBuffer","updateFloat4","w","update","_useRightHandedSystem","setStepId","newStepId","_currentStepId","getStepId","getInternalStep","_currentInternalStep","fogEnabled","_fogEnabled","fogMode","_fogMode","prePass","prePassRenderer","defaultRT","enabled","shadowsEnabled","_shadowsEnabled","lightsEnabled","_lightsEnabled","activeCameras","_activeCameras","cameras","_unObserveActiveCameras","onActiveCamerasChanged","_activeCamera","onActiveCameraChanged","defaultMaterial","_defaultMaterial","texturesEnabled","_texturesEnabled","skeletonsEnabled","_skeletonsEnabled","collisionCoordinator","_collisionCoordinator","init","renderingManager","frustumPlanes","_frustumPlanes","_registerTransientComponents","_transientComponents","length","component","register","_addComponent","_components","push","serializableComponent","addFromContainer","serialize","_serializableComponents","_getComponent","name","constructor","engine","options","cameraToUseForPointers","_isScene","_blockEntityCollection","autoClearDepthAndStencil","clearColor","ambientColor","environmentIntensity","animationsEnabled","useConstantAnimationDeltaTime","constantlyUpdateMeshUnderPointer","hoverCursor","defaultCursor","doNotHandleCursors","preventDefaultOnPointerDown","preventDefaultOnPointerUp","metadata","reservedDataStore","disableOfflineSupportExceptionRules","Array","onAfterRenderCameraObservable","onBeforeAnimationsObservable","onAfterAnimationsObservable","onBeforeDrawPhaseObservable","onAfterDrawPhaseObservable","onReadyObservable","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesEvaluationObservable","onBeforeParticlesRenderingObservable","onAfterParticlesRenderingObservable","onDataLoadedObservable","onNewCameraAddedObservable","onCameraRemovedObservable","onNewLightAddedObservable","onLightRemovedObservable","onNewGeometryAddedObservable","onGeometryRemovedObservable","onNewTransformNodeAddedObservable","onTransformNodeRemovedObservable","onNewMeshAddedObservable","onMeshRemovedObservable","onNewSkeletonAddedObservable","onSkeletonRemovedObservable","onNewMaterialAddedObservable","onNewMultiMaterialAddedObservable","onMaterialRemovedObservable","onMultiMaterialRemovedObservable","onNewTextureAddedObservable","onTextureRemovedObservable","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsRenderObservable","onBeforeStepObservable","onAfterStepObservable","onBeforeRenderingGroupObservable","onAfterRenderingGroupObservable","onMeshImportedObservable","onAnimationFileImportedObservable","_registeredForLateAnimationBindings","onPrePointerObservable","onPointerObservable","onPreKeyboardObservable","onKeyboardObservable","_timeAccumulator","FOGMODE_NONE","fogColor","fogDensity","fogStart","fogEnd","needsPreviousWorldMatrices","physicsEnabled","particlesEnabled","spritesEnabled","lensFlaresEnabled","collisionsEnabled","gravity","postProcessesEnabled","renderTargetsEnabled","dumpNextRenderTargets","customRenderTargets","importedMeshesFiles","probesEnabled","_meshesForIntersections","proceduralTexturesEnabled","_totalVertices","_activeIndices","_activeParticles","_activeBones","_animationTime","animationTimeScale","_renderId","_frameId","_executeWhenReadyTimeoutId","_intermediateRendering","_defaultFrameBufferCleared","_viewUpdateFlag","_projectionUpdateFlag","_toBeDisposed","_activeRequests","_pendingData","_isDisposed","dispatchAllSubMeshesOfActiveMeshes","_activeMeshes","_processedMaterials","_renderTargets","_materialsRenderTargets","_activeParticleSystems","_activeSkeletons","_softwareSkinnedMeshes","_activeAnimatables","_transformMatrix","Zero","requireLightSorting","_beforeCameraUpdateStage","Create","_beforeClearStage","_beforeRenderTargetClearStage","_gatherRenderTargetsStage","_gatherActiveCameraRenderTargetsStage","_isReadyForMeshStage","_beforeEvaluateActiveMeshStage","_evaluateSubMeshStage","_preActiveMeshStage","_cameraDrawRenderTargetStage","_beforeCameraDrawStage","_beforeRenderTargetDrawStage","_beforeRenderingGroupDrawStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_afterRenderingGroupDrawStage","_afterCameraDrawStage","_afterCameraPostProcessStage","_afterRenderTargetDrawStage","_afterRenderTargetPostProcessStage","_afterRenderStage","_pointerMoveStage","_pointerDownStage","_pointerUpStage","_geometriesByUniqueId","_defaultMeshCandidates","data","_defaultSubMeshCandidates","_preventFreeActiveMeshesAndRenderingGroups","_activeMeshesFrozen","_activeMeshesFrozenButKeepClipping","_skipEvaluateActiveMeshesCompletely","_allowPostProcessClearColor","getDeterministicFrameTime","_engine","getTimeStep","_registeredActions","_blockMaterialDirtyMechanism","_perfCollector","fullOptions","Object","assign","useGeometryUniqueIdsMap","useMaterialMeshMap","useClonedMeshMap","virtual","LastCreatedEngine","_LastCreatedScene","scenes","_virtualScenes","_uid","postProcessManager","attachControl","_createUbo","setDefaultCandidateProviders","onNewSceneAddedObservable","getClassName","_getDefaultMeshCandidates","meshes","_getDefaultSubMeshCandidates","mesh","subMeshes","getActiveMeshCandidates","getActiveSubMeshCandidates","getIntersectingSubMeshCandidates","localRay","getCollidingSubMeshCandidates","collider","meshUnderPointer","pointerX","pointerY","getCachedMaterial","_cachedMaterial","getCachedEffect","_cachedEffect","getCachedVisibility","_cachedVisibility","isCachedMaterialInvalid","material","visibility","getEngine","getTotalVertices","current","totalVerticesPerfCounter","getActiveIndices","totalActiveIndicesPerfCounter","getActiveParticles","activeParticlesPerfCounter","getActiveBones","activeBonesPerfCounter","getActiveMeshes","getAnimationRatio","_animationRatio","undefined","getRenderId","getFrameId","incrementRenderId","setSceneUniformBuffer","createSceneUniformBuffer","simulatePointerMove","pickResult","pointerEventInit","simulatePointerDown","simulatePointerUp","doubleTap","isPointerCaptured","pointerId","attachUp","attachDown","attachMove","detachControl","isReady","checkRenderTargets","index","currentRenderPassId","_b","_a","renderPassId","_c","reset","hardwareInstancedRendering","hasThinInstances","getCaps","instancedArrays","instances","step","action","mat","_storeEffectOnSubMeshes","subMesh","getMaterial","hasRenderTargetTextures","getRenderTargetTextures","indexOf","concatWithNoDuplicate","rtt","isReadyForRendering","geometries","geometry","delayLoadState","camera","particleSystem","particleSystems","layers","layer","areAllEffectsReady","resetCachedMaterial","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","unregisterAfterRender","_executeOnceBeforeRender","execFunc","setTimeout","executeOnceBeforeRender","timeout","addPendingData","removePendingData","wasLoading","isLoading","splice","getWaitingItemsCount","executeWhenReady","addOnce","_checkIsReady","whenReadyAsync","Promise","resolve","clear","animatables","resetLastAnimationTimeFrame","_animationTimeLast","Now","getViewMatrix","_viewMatrix","getProjectionMatrix","_projectionMatrix","getTransformMatrix","setTransformMatrix","viewL","projectionL","viewR","projectionR","_multiviewSceneUbo","dispose","updateFlag","multiplyToRef","GetPlanes","GetPlanesToRef","useUbo","_updateMultiviewUbo","_sceneUbo","updateMatrix","sceneUbo","addUniform","getUniqueId","UniqueId","addMesh","newMesh","recursive","_resyncLightSources","parent","_addToSceneRootNodes","getChildMeshes","forEach","m","removeMesh","toRemove","pop","_removeFromSceneRootNodes","_invalidateMesh","addTransformNode","newTransformNode","getScene","_indexInSceneTransformNodesArray","transformNodes","removeTransformNode","lastNode","removeSkeleton","skeletons","_executeActiveContainerCleanup","removeMorphTargetManager","morphTargetManagers","removeLight","lights","_removeLightSource","sortLightsByPriority","removeCamera","index2","removeParticleSystem","removeAnimation","animations","stopAnimation","target","animationName","targetMask","removeAnimationGroup","animationGroups","removeMultiMaterial","multiMaterials","removeMaterial","_indexInSceneMaterialArray","materials","lastMaterial","removeActionManager","actionManagers","removeTexture","textures","addLight","newLight","lightSources","sort","CompareLightsPriority","addCamera","newCamera","addSkeleton","newSkeleton","addParticleSystem","newParticleSystem","addAnimation","newAnimation","addAnimationGroup","newAnimationGroup","addMultiMaterial","newMultiMaterial","addMaterial","newMaterial","addMorphTargetManager","newMorphTargetManager","addGeometry","newGeometry","uniqueId","addActionManager","newActionManager","addTexture","newTexture","switchActiveCamera","canvas","getInputElement","setActiveCameraById","id","getCameraById","setActiveCameraByName","getCameraByName","getAnimationGroupByName","_getMaterial","allowMultiMaterials","predicate","getMaterialByUniqueID","getMaterialById","getMaterialByName","getLastMaterialById","getTextureByUniqueId","getTextureByName","getCameraByUniqueId","getBoneById","skeletonIndex","skeleton","boneIndex","bones","getBoneByName","getLightByName","getLightById","getLightByUniqueId","getParticleSystemById","getGeometryById","_getGeometryByUniqueId","pushGeometry","force","removeGeometry","lastGeometry","getGeometries","getMeshById","getMeshesById","filter","getTransformNodeById","getTransformNodeByUniqueId","getTransformNodesById","getMeshByUniqueId","getLastMeshById","getLastTransformNodeById","getLastEntryById","getNodeById","transformNode","light","bone","getNodeByName","getMeshByName","getTransformNodeByName","getLastSkeletonById","getSkeletonByUniqueId","getSkeletonById","getSkeletonByName","getMorphTargetManagerById","getMorphTargetById","managerIndex","morphTargetManager","numTargets","getTarget","getMorphTargetByName","getPostProcessByName","postProcessIndex","postProcesses","postProcess","isActiveMesh","uid","RandomId","addExternalData","key","_externalData","getExternalData","get","getOrAddExternalDataWithFactory","factory","getOrAddWithFactory","removeExternalData","_evaluateSubMesh","initialMesh","forcePush","isInFrustum","dispatch","freeProcessedMaterials","blockfreeActiveMeshesAndRenderingGroups","freeActiveMeshes","freeRenderingGroups","i","texture","renderList","_isInIntermediateRendering","freezeActiveMeshes","skipEvaluateActiveMeshes","onSuccess","onError","freezeMeshes","keepFrustumCulling","updateTransformMatrix","_evaluateActiveMeshes","_freeze","unfreezeActiveMeshes","_internalAbstractMeshDataInfo","_isActive","_unFreeze","container","isInFastMode","snapshotRendering","snapshotRenderingMode","len","computeWorldMatrix","psLength","animate","resetSprites","_currentLODIsUpToDate","isBlocked","addCount","isEnabled","scaling","hasAZeroComponent","actionManager","hasSpecificTriggers2","pushNoDuplicate","meshToRender","customLODSelector","getLOD","_currentLOD","billboardMode","_preActivate","isVisible","layerMask","alwaysSelectAsActiveMesh","_activate","isAnInstance","_onlyForInstances","_actAsRegularMesh","_activeMesh","_postActivate","particleIndex","isStarted","emitter","position","dispatchParticles","sourceMesh","prepare","computeBonesUsingShaders","hasInstances","_renderingMultiview","leftCamera","_rigCameras","rightCamera","_bindFrameBuffer","_multiviewTexture","outputRenderTarget","_currentFrameBufferIsDefaultFrameBuffer","restoreDefaultFramebuffer","_clearFrameBuffer","onClearObservable","hasObservers","skipInitialClear","_cleared","_clear","_renderForCamera","rigParent","bindFrameBuffer","_skipRendering","Error","setViewport","viewport","softwareSkinnedMeshIndex","applySkeleton","isRenderTarget","needRebind","StartPerformanceCounter","renderIndex","renderTarget","_shouldRender","hasSpecialRenderTargetCamera","render","EndPerformanceCounter","_prepareFrame","_finalizeFrame","isIntermediate","_processSubCameras","cameraRigMode","_createMultiviewUbo","_useMultiviewToSingleView","_renderMultiviewToSingleView","_checkIntersections","actionIndex","actions","trigger","parameters","getTriggerParameter","otherMesh","areIntersecting","intersectsMesh","usePreciseIntersection","currentIntersectionInProgress","_intersectionsInProgress","_executeCurrent","CreateNew","hasSpecificTrigger","parameter","parameterMesh","_advancePhysicsEngineStep","_animate","isDeterministicLockStep","deltaTime","Math","max","MinDeltaTime","min","getDeltaTime","MaxDeltaTime","defaultFrameTime","defaultFPS","stepsTaken","maxSubSteps","getLockstepMaxSteps","internalSteps","floor","_checkCameraRenderTarget","isRigCamera","rigCameras","resetDrawCache","passId","updateCameras","ignoreAnimations","isDisposed","fetchNewFrame","processTrigger","cameraIndex","currentActiveCamera","customIndex","freezeMaterials","freeze","unfreezeMaterials","unfreeze","stopAllAnimations","animatable","onAnimationEndObservable","onAnimationEnd","activeRequests","slice","request","abort","e","console","error","_disposeList","item","wipeCaches","items","itemsCopy","clearCachedVertexData","meshIndex","clearCachedData","cleanCachedTextureBuffer","baseTexture","buffer","_buffer","getWorldExtends","filterPredicate","Number","MAX_VALUE","infiniteDistance","boundingInfo","getBoundingInfo","minBox","boundingBox","minimumWorld","maxBox","maximumWorld","CheckExtends","createPickingRay","world","cameraViewSpace","createPickingRayToRef","result","enableDistantPicking","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","_pickingAvailable","pick","fastCheck","trianglePredicate","pickWithBoundingInfo","pickWithRay","ray","multiPick","multiPickWithRay","setPointerOverMesh","getPointerOverMesh","_rebuildGeometries","_rebuild","rebuild","system","spriteManagers","spriteMgr","_rebuildTextures","_getByTags","list","tagsQuery","listByTags","MatchesQuery","getMeshesByTags","getCamerasByTags","getLightsByTags","getMaterialByTags","concat","getTransformNodesByTags","setRenderingOrder","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingAutoClearDepthStencil","autoClearDepthStencil","depth","stencil","getAutoClearDepthStencilSetup","blockMaterialDirtyMechanism","flag","markAsDirty","_loadFile","fileOrUrl","onProgress","useOfflineSupport","useArrayBuffer","onOpened","offlineProvider","onCompleteObservable","_loadFileAsync","reject","exception","_requestFile","url","_requestFileAsync","_readFile","file","_readFileAsync","getPerfCollector","setActiveCameraByID","getMaterialByID","getLastMaterialByID","getTextureByUniqueID","getCameraByID","getCameraByUniqueID","getBoneByID","getLightByID","getLightByUniqueID","getParticleSystemByID","getGeometryByID","getMeshByID","getMeshByUniqueID","getLastMeshByID","getMeshesByID","getTransformNodeByID","getTransformNodeByUniqueID","getTransformNodesByID","getNodeByID","getLastEntryByID","getLastSkeletonByID","FOGMODE_EXP","FOGMODE_EXP2","FOGMODE_LINEAR"],"sources":["../../../dev/core/src/scene.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"./types\";\r\nimport { Tools } from \"./Misc/tools\";\r\nimport type { IAnimatable } from \"./Animations/animatable.interface\";\r\nimport { PrecisionDate } from \"./Misc/precisionDate\";\r\nimport type { Observer } from \"./Misc/observable\";\r\nimport { Observable } from \"./Misc/observable\";\r\nimport type { ISmartArrayLike } from \"./Misc/smartArray\";\r\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray\";\r\nimport { StringDictionary } from \"./Misc/stringDictionary\";\r\nimport { Tags } from \"./Misc/tags\";\r\nimport type { Vector2, Vector4 } from \"./Maths/math.vector\";\r\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector\";\r\nimport type { IParticleSystem } from \"./Particles/IParticleSystem\";\r\nimport { AbstractScene } from \"./abstractScene\";\r\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration\";\r\nimport { UniformBuffer } from \"./Materials/uniformBuffer\";\r\nimport { PickingInfo } from \"./Collisions/pickingInfo\";\r\nimport type { ICollisionCoordinator } from \"./Collisions/collisionCoordinator\";\r\nimport type { PointerEventTypes, PointerInfoPre, PointerInfo } from \"./Events/pointerEvents\";\r\nimport type { KeyboardInfoPre, KeyboardInfo } from \"./Events/keyboardEvents\";\r\nimport { ActionEvent } from \"./Actions/actionEvent\";\r\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager\";\r\nimport type { IOfflineProvider } from \"./Offline/IOfflineProvider\";\r\nimport type { RenderingGroupInfo, IRenderingManagerAutoClearSetup } from \"./Rendering/renderingManager\";\r\nimport { RenderingManager } from \"./Rendering/renderingManager\";\r\nimport type {\r\n    ISceneComponent,\r\n    ISceneSerializableComponent,\r\n    SimpleStageAction,\r\n    RenderTargetsStageAction,\r\n    RenderTargetStageAction,\r\n    MeshStageAction,\r\n    EvaluateSubMeshStageAction,\r\n    PreActiveMeshStageAction,\r\n    CameraStageAction,\r\n    RenderingGroupStageAction,\r\n    RenderingMeshStageAction,\r\n    PointerMoveStageAction,\r\n    PointerUpDownStageAction,\r\n    CameraStageFrameBufferAction,\r\n} from \"./sceneComponent\";\r\nimport { Stage } from \"./sceneComponent\";\r\nimport type { Engine } from \"./Engines/engine\";\r\nimport { Constants } from \"./Engines/constants\";\r\nimport { IsWindowObjectExist } from \"./Misc/domManagement\";\r\nimport { EngineStore } from \"./Engines/engineStore\";\r\nimport type { AbstractActionManager } from \"./Actions/abstractActionManager\";\r\nimport { _WarnImport } from \"./Misc/devTools\";\r\nimport type { WebRequest } from \"./Misc/webRequest\";\r\nimport { InputManager } from \"./Inputs/scene.inputManager\";\r\nimport { PerfCounter } from \"./Misc/perfCounter\";\r\nimport type { IFileRequest } from \"./Misc/fileRequest\";\r\nimport { Color4, Color3 } from \"./Maths/math.color\";\r\nimport type { Plane } from \"./Maths/math.plane\";\r\nimport { Frustum } from \"./Maths/math.frustum\";\r\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator\";\r\nimport type { LoadFileError, RequestFileError, ReadFileError } from \"./Misc/fileTools\";\r\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools\";\r\nimport type { IClipPlanesHolder } from \"./Misc/interfaces/iClipPlanesHolder\";\r\nimport type { IPointerEvent } from \"./Events/deviceInputEvents\";\r\nimport { LightConstants } from \"./Lights/lightConstants\";\r\nimport { _ObserveArray } from \"./Misc/arrayTools\";\r\nimport type { IAction } from \"./Actions/action\";\r\nimport type { AnimationPropertiesOverride } from \"./Animations/animationPropertiesOverride\";\r\nimport type { AnimationGroup } from \"./Animations/animationGroup\";\r\nimport type { Skeleton } from \"./Bones/skeleton\";\r\nimport type { Bone } from \"./Bones/bone\";\r\nimport type { Camera } from \"./Cameras/camera\";\r\nimport type { Collider } from \"./Collisions/collider\";\r\nimport type { Ray, TrianglePickingPredicate } from \"./Culling/ray\";\r\nimport type { Light } from \"./Lights/light\";\r\nimport type { PerformanceViewerCollector } from \"./Misc/PerformanceViewer/performanceViewerCollector\";\r\nimport type { MorphTarget } from \"./Morph/morphTarget\";\r\nimport type { MorphTargetManager } from \"./Morph/morphTargetManager\";\r\nimport type { PostProcess } from \"./PostProcesses/postProcess\";\r\nimport type { Material } from \"./Materials/material\";\r\nimport type { BaseTexture } from \"./Materials/Textures/baseTexture\";\r\nimport type { Geometry } from \"./Meshes/geometry\";\r\nimport type { TransformNode } from \"./Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport type { MultiMaterial } from \"./Materials/multiMaterial\";\r\nimport type { Effect } from \"./Materials/effect\";\r\nimport type { RenderTargetTexture } from \"./Materials/Textures/renderTargetTexture\";\r\nimport type { Mesh } from \"./Meshes/mesh\";\r\nimport type { SubMesh } from \"./Meshes/subMesh\";\r\nimport type { Node } from \"./node\";\r\nimport type { Animation } from \"./Animations/animation\";\r\nimport type { Animatable } from \"./Animations/animatable\";\r\nimport type { Texture } from \"./Materials/Textures/texture\";\r\nimport { PointerPickingConfiguration } from \"./Inputs/pointerPickingConfiguration\";\r\n\r\n/**\r\n * Define an interface for all classes that will hold resources\r\n */\r\nexport interface IDisposable {\r\n    /**\r\n     * Releases all held resources\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/** Interface defining initialization parameters for Scene class */\r\nexport interface SceneOptions {\r\n    /**\r\n     * Defines that scene should keep up-to-date a map of geometry to enable fast look-up by uniqueId\r\n     * It will improve performance when the number of geometries becomes important.\r\n     */\r\n    useGeometryUniqueIdsMap?: boolean;\r\n\r\n    /**\r\n     * Defines that each material of the scene should keep up-to-date a map of referencing meshes for fast disposing\r\n     * It will improve performance when the number of mesh becomes important, but might consume a bit more memory\r\n     */\r\n    useMaterialMeshMap?: boolean;\r\n\r\n    /**\r\n     * Defines that each mesh of the scene should keep up-to-date a map of referencing cloned meshes for fast disposing\r\n     * It will improve performance when the number of mesh becomes important, but might consume a bit more memory\r\n     */\r\n    useClonedMeshMap?: boolean;\r\n\r\n    /** Defines if the creation of the scene should impact the engine (Eg. UtilityLayer's scene) */\r\n    virtual?: boolean;\r\n}\r\n\r\n/**\r\n * Define how the scene should favor performance over ease of use\r\n */\r\nexport enum ScenePerformancePriority {\r\n    /** Default mode. No change. Performance will be treated as less important than backward compatibility */\r\n    BackwardCompatible,\r\n    /** Some performance options will be turned on trying to strike a balance between perf and ease of use */\r\n    Intermediate,\r\n    /** Performance will be top priority */\r\n    Aggressive,\r\n}\r\n\r\n/**\r\n * Represents a scene to be rendered by the engine.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene\r\n */\r\nexport class Scene extends AbstractScene implements IAnimatable, IClipPlanesHolder {\r\n    /** The fog is deactivated */\r\n    public static readonly FOGMODE_NONE = 0;\r\n    /** The fog density is following an exponential function */\r\n    public static readonly FOGMODE_EXP = 1;\r\n    /** The fog density is following an exponential function faster than FOGMODE_EXP */\r\n    public static readonly FOGMODE_EXP2 = 2;\r\n    /** The fog density is following a linear function. */\r\n    public static readonly FOGMODE_LINEAR = 3;\r\n\r\n    /**\r\n     * Gets or sets the minimum deltatime when deterministic lock step is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    public static MinDeltaTime = 1.0;\r\n    /**\r\n     * Gets or sets the maximum deltatime when deterministic lock step is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    public static MaxDeltaTime = 1000.0;\r\n\r\n    /**\r\n     * Factory used to create the default material.\r\n     * @param scene The scene to create the material for\r\n     * @returns The default material\r\n     */\r\n    public static DefaultMaterialFactory(scene: Scene): Material {\r\n        throw _WarnImport(\"StandardMaterial\");\r\n    }\r\n\r\n    /**\r\n     * Factory used to create the a collision coordinator.\r\n     * @returns The collision coordinator\r\n     */\r\n    public static CollisionCoordinatorFactory(): ICollisionCoordinator {\r\n        throw _WarnImport(\"DefaultCollisionCoordinator\");\r\n    }\r\n\r\n    // Members\r\n\r\n    /** @internal */\r\n    public _inputManager = new InputManager(this);\r\n\r\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\r\n    public cameraToUseForPointers: Nullable<Camera> = null;\r\n\r\n    /** @internal */\r\n    public readonly _isScene = true;\r\n\r\n    /** @internal */\r\n    public _blockEntityCollection = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\r\n     */\r\n    public autoClear = true;\r\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\r\n     */\r\n    public autoClearDepthAndStencil = true;\r\n    /**\r\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\r\n     */\r\n    public clearColor: Color4 = new Color4(0.2, 0.2, 0.3, 1.0);\r\n    /**\r\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\r\n     */\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * This is use to store the default BRDF lookup for PBR materials in your scene.\r\n     * It should only be one of the following (if not the default embedded one):\r\n     * * For uncorrelated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = false) : https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\r\n     * * For correlated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedBRDF.dds\r\n     * * For correlated multi scattering BRDF (pbr.brdf.useEnergyConservation = true and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\r\n     * The material properties need to be setup according to the type of texture in use.\r\n     */\r\n    public environmentBRDFTexture: BaseTexture;\r\n\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public get environmentTexture(): Nullable<BaseTexture> {\r\n        return this._environmentTexture;\r\n    }\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to set here than in all the materials.\r\n     */\r\n    public set environmentTexture(value: Nullable<BaseTexture>) {\r\n        if (this._environmentTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._environmentTexture = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Intensity of the environment in all pbr material.\r\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public environmentIntensity: number = 1;\r\n\r\n    /** @internal */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n    /**\r\n     * Default image processing configuration used either in the rendering\r\n     * Forward main pass or through the imageProcessingPostProcess if present.\r\n     * As in the majority of the scene they are the same (exception for multi camera),\r\n     * this is easier to reference from here than from all the materials and post process.\r\n     *\r\n     * No setter as we it is a shared configuration, you can set the values instead.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    private _performancePriority = ScenePerformancePriority.BackwardCompatible;\r\n\r\n    /**\r\n     * Observable triggered when the performance priority is changed\r\n     */\r\n    public onScenePerformancePriorityChangedObservable = new Observable<ScenePerformancePriority>();\r\n    /**\r\n     * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility\r\n     */\r\n    public get performancePriority() {\r\n        return this._performancePriority;\r\n    }\r\n\r\n    public set performancePriority(value) {\r\n        if (value === this._performancePriority) {\r\n            return;\r\n        }\r\n\r\n        this._performancePriority = value;\r\n\r\n        switch (value) {\r\n            case ScenePerformancePriority.BackwardCompatible:\r\n                this.skipFrustumClipping = false;\r\n                this._renderingManager.maintainStateBetweenFrames = false;\r\n                this.skipPointerMovePicking = false;\r\n                this.autoClear = true;\r\n                break;\r\n            case ScenePerformancePriority.Intermediate:\r\n                this.skipFrustumClipping = false;\r\n                this._renderingManager.maintainStateBetweenFrames = false;\r\n                this.skipPointerMovePicking = true;\r\n                this.autoClear = false;\r\n                break;\r\n            case ScenePerformancePriority.Aggressive:\r\n                this.skipFrustumClipping = true;\r\n                this._renderingManager.maintainStateBetweenFrames = true;\r\n                this.skipPointerMovePicking = true;\r\n                this.autoClear = false;\r\n                break;\r\n        }\r\n\r\n        this.onScenePerformancePriorityChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    private _forceWireframe = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\r\n     */\r\n    public set forceWireframe(value: boolean) {\r\n        if (this._forceWireframe === value) {\r\n            return;\r\n        }\r\n        this._forceWireframe = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\r\n    }\r\n    public get forceWireframe(): boolean {\r\n        return this._forceWireframe;\r\n    }\r\n\r\n    private _skipFrustumClipping = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\r\n     */\r\n    public set skipFrustumClipping(value: boolean) {\r\n        if (this._skipFrustumClipping === value) {\r\n            return;\r\n        }\r\n        this._skipFrustumClipping = value;\r\n    }\r\n    public get skipFrustumClipping(): boolean {\r\n        return this._skipFrustumClipping;\r\n    }\r\n\r\n    private _forcePointsCloud = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\r\n     */\r\n    public set forcePointsCloud(value: boolean) {\r\n        if (this._forcePointsCloud === value) {\r\n            return;\r\n        }\r\n        this._forcePointsCloud = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\r\n    }\r\n    public get forcePointsCloud(): boolean {\r\n        return this._forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations are enabled\r\n     */\r\n    public animationsEnabled = true;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\r\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\r\n     */\r\n    public useConstantAnimationDeltaTime = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\r\n     * Please note that it requires to run a ray cast through the scene on every frame\r\n     */\r\n    public constantlyUpdateMeshUnderPointer = false;\r\n\r\n    /**\r\n     * Defines the HTML cursor to use when hovering over interactive elements\r\n     */\r\n    public hoverCursor = \"pointer\";\r\n    /**\r\n     * Defines the HTML default cursor to use (empty by default)\r\n     */\r\n    public defaultCursor: string = \"\";\r\n    /**\r\n     * Defines whether cursors are handled by the scene.\r\n     */\r\n    public doNotHandleCursors = false;\r\n    /**\r\n     * This is used to call preventDefault() on pointer down\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\r\n    public preventDefaultOnPointerDown = true;\r\n\r\n    /**\r\n     * This is used to call preventDefault() on pointer up\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\r\n    public preventDefaultOnPointerUp = true;\r\n\r\n    // Metadata\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Gets the name of the plugin used to load this scene (null by default)\r\n     */\r\n    public loadingPluginName: string;\r\n\r\n    /**\r\n     * Use this array to add regular expressions used to disable offline support for specific urls\r\n     */\r\n    public disableOfflineSupportExceptionRules = new Array<RegExp>();\r\n\r\n    /**\r\n     * An event triggered when the scene is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<Scene>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Scene>> = null;\r\n    /** Sets a function to be executed when this scene is disposed. */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the scene (right after animations and physics)\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Scene>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Scene>> = null;\r\n    /** Sets a function to be executed before rendering this scene */\r\n    public set beforeRender(callback: Nullable<() => void>) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        if (callback) {\r\n            this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the scene\r\n     */\r\n    public onAfterRenderObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\r\n     * This is triggered for each \"sub\" camera in a Camera Rig unlike onAfterCameraRenderObservable\r\n     */\r\n    public onAfterRenderCameraObservable = new Observable<Camera>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Scene>> = null;\r\n    /** Sets a function to be executed after rendering this scene */\r\n    public set afterRender(callback: Nullable<() => void>) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n\r\n        if (callback) {\r\n            this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An event triggered before animating the scene\r\n     */\r\n    public onBeforeAnimationsObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered after animations processing\r\n     */\r\n    public onAfterAnimationsObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered before draw calls are ready to be sent\r\n     */\r\n    public onBeforeDrawPhaseObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered after draw calls have been sent\r\n     */\r\n    public onAfterDrawPhaseObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when the scene is ready\r\n     */\r\n    public onReadyObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered before rendering a camera\r\n     */\r\n    public onBeforeCameraRenderObservable = new Observable<Camera>();\r\n\r\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /** Sets a function to be executed before rendering a camera*/\r\n    public set beforeCameraRender(callback: () => void) {\r\n        if (this._onBeforeCameraRenderObserver) {\r\n            this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        }\r\n\r\n        this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering a camera\r\n     * This is triggered for the full rig Camera only unlike onAfterRenderCameraObservable\r\n     */\r\n    public onAfterCameraRenderObservable = new Observable<Camera>();\r\n\r\n    private _onAfterCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /** Sets a function to be executed after rendering a camera*/\r\n    public set afterCameraRender(callback: () => void) {\r\n        if (this._onAfterCameraRenderObserver) {\r\n            this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\r\n        }\r\n        this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when active meshes evaluation is about to start\r\n     */\r\n    public onBeforeActiveMeshesEvaluationObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when active meshes evaluation is done\r\n     */\r\n    public onAfterActiveMeshesEvaluationObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when particles rendering is about to start\r\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n     */\r\n    public onBeforeParticlesRenderingObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when particles rendering is done\r\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n     */\r\n    public onAfterParticlesRenderingObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\r\n     */\r\n    public onDataLoadedObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when a camera is created\r\n     */\r\n    public onNewCameraAddedObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * An event triggered when a camera is removed\r\n     */\r\n    public onCameraRemovedObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * An event triggered when a light is created\r\n     */\r\n    public onNewLightAddedObservable = new Observable<Light>();\r\n\r\n    /**\r\n     * An event triggered when a light is removed\r\n     */\r\n    public onLightRemovedObservable = new Observable<Light>();\r\n\r\n    /**\r\n     * An event triggered when a geometry is created\r\n     */\r\n    public onNewGeometryAddedObservable = new Observable<Geometry>();\r\n\r\n    /**\r\n     * An event triggered when a geometry is removed\r\n     */\r\n    public onGeometryRemovedObservable = new Observable<Geometry>();\r\n\r\n    /**\r\n     * An event triggered when a transform node is created\r\n     */\r\n    public onNewTransformNodeAddedObservable = new Observable<TransformNode>();\r\n\r\n    /**\r\n     * An event triggered when a transform node is removed\r\n     */\r\n    public onTransformNodeRemovedObservable = new Observable<TransformNode>();\r\n\r\n    /**\r\n     * An event triggered when a mesh is created\r\n     */\r\n    public onNewMeshAddedObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when a mesh is removed\r\n     */\r\n    public onMeshRemovedObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when a skeleton is created\r\n     */\r\n    public onNewSkeletonAddedObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * An event triggered when a skeleton is removed\r\n     */\r\n    public onSkeletonRemovedObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * An event triggered when a material is created\r\n     */\r\n    public onNewMaterialAddedObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An event triggered when a multi material is created\r\n     */\r\n    public onNewMultiMaterialAddedObservable = new Observable<MultiMaterial>();\r\n\r\n    /**\r\n     * An event triggered when a material is removed\r\n     */\r\n    public onMaterialRemovedObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An event triggered when a multi material is removed\r\n     */\r\n    public onMultiMaterialRemovedObservable = new Observable<MultiMaterial>();\r\n\r\n    /**\r\n     * An event triggered when a texture is created\r\n     */\r\n    public onNewTextureAddedObservable = new Observable<BaseTexture>();\r\n\r\n    /**\r\n     * An event triggered when a texture is removed\r\n     */\r\n    public onTextureRemovedObservable = new Observable<BaseTexture>();\r\n\r\n    /**\r\n     * An event triggered when render targets are about to be rendered\r\n     * Can happen multiple times per frame.\r\n     */\r\n    public onBeforeRenderTargetsRenderObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when render targets were rendered.\r\n     * Can happen multiple times per frame.\r\n     */\r\n    public onAfterRenderTargetsRenderObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered before calculating deterministic simulation step\r\n     */\r\n    public onBeforeStepObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered after calculating deterministic simulation step\r\n     */\r\n    public onAfterStepObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when the activeCamera property is updated\r\n     */\r\n    public onActiveCameraChanged = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when the activeCameras property is updated\r\n     */\r\n    public onActiveCamerasChanged = new Observable<Scene>();\r\n\r\n    /**\r\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\r\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\r\n    public onBeforeRenderingGroupObservable = new Observable<RenderingGroupInfo>();\r\n\r\n    /**\r\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\r\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\r\n    public onAfterRenderingGroupObservable = new Observable<RenderingGroupInfo>();\r\n\r\n    /**\r\n     * This Observable will when a mesh has been imported into the scene.\r\n     */\r\n    public onMeshImportedObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * This Observable will when an animation file has been imported into the scene.\r\n     */\r\n    public onAnimationFileImportedObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * Gets or sets a user defined funtion to select LOD from a mesh and a camera.\r\n     * By default this function is undefined and Babylon.js will select LOD based on distance to camera\r\n     */\r\n    public customLODSelector: (mesh: AbstractMesh, camera: Camera) => Nullable<AbstractMesh>;\r\n\r\n    // Animations\r\n\r\n    /** @internal */\r\n    public _registeredForLateAnimationBindings = new SmartArrayNoDuplicate<any>(256);\r\n\r\n    // Pointers\r\n    private _pointerPickingConfiguration = new PointerPickingConfiguration();\r\n\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer down event\r\n     */\r\n    public get pointerDownPredicate() {\r\n        return this._pointerPickingConfiguration.pointerDownPredicate;\r\n    }\r\n\r\n    public set pointerDownPredicate(value) {\r\n        this._pointerPickingConfiguration.pointerDownPredicate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer up event\r\n     */\r\n    public get pointerUpPredicate() {\r\n        return this._pointerPickingConfiguration.pointerUpPredicate;\r\n    }\r\n\r\n    public set pointerUpPredicate(value) {\r\n        this._pointerPickingConfiguration.pointerUpPredicate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer move event\r\n     */\r\n    public get pointerMovePredicate() {\r\n        return this._pointerPickingConfiguration.pointerMovePredicate;\r\n    }\r\n\r\n    public set pointerMovePredicate(value) {\r\n        this._pointerPickingConfiguration.pointerMovePredicate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer down event\r\n     */\r\n    public get pointerDownFastCheck() {\r\n        return this._pointerPickingConfiguration.pointerDownFastCheck;\r\n    }\r\n\r\n    public set pointerDownFastCheck(value) {\r\n        this._pointerPickingConfiguration.pointerDownFastCheck = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer up event\r\n     */\r\n    public get pointerUpFastCheck() {\r\n        return this._pointerPickingConfiguration.pointerUpFastCheck;\r\n    }\r\n\r\n    public set pointerUpFastCheck(value) {\r\n        this._pointerPickingConfiguration.pointerUpFastCheck = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer move event\r\n     */\r\n    public get pointerMoveFastCheck() {\r\n        return this._pointerPickingConfiguration.pointerMoveFastCheck;\r\n    }\r\n\r\n    public set pointerMoveFastCheck(value) {\r\n        this._pointerPickingConfiguration.pointerMoveFastCheck = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\r\n     */\r\n    public get skipPointerMovePicking() {\r\n        return this._pointerPickingConfiguration.skipPointerMovePicking;\r\n    }\r\n\r\n    public set skipPointerMovePicking(value) {\r\n        this._pointerPickingConfiguration.skipPointerMovePicking = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\r\n     */\r\n    public get skipPointerDownPicking() {\r\n        return this._pointerPickingConfiguration.skipPointerDownPicking;\r\n    }\r\n\r\n    public set skipPointerDownPicking(value) {\r\n        this._pointerPickingConfiguration.skipPointerDownPicking = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.\r\n     */\r\n    public get skipPointerUpPicking() {\r\n        return this._pointerPickingConfiguration.skipPointerUpPicking;\r\n    }\r\n\r\n    public set skipPointerUpPicking(value) {\r\n        this._pointerPickingConfiguration.skipPointerUpPicking = value;\r\n    }\r\n\r\n    /** Callback called when a pointer move is detected */\r\n    public onPointerMove?: (evt: IPointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;\r\n    /** Callback called when a pointer down is detected  */\r\n    public onPointerDown?: (evt: IPointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;\r\n    /** Callback called when a pointer up is detected  */\r\n    public onPointerUp?: (evt: IPointerEvent, pickInfo: Nullable<PickingInfo>, type: PointerEventTypes) => void;\r\n    /** Callback called when a pointer pick is detected */\r\n    public onPointerPick?: (evt: IPointerEvent, pickInfo: PickingInfo) => void;\r\n\r\n    /**\r\n     * Gets or sets a predicate used to select candidate faces for a pointer move event\r\n     */\r\n    public pointerMoveTrianglePredicate: ((p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray) => boolean) | undefined;\r\n\r\n    /**\r\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\r\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\r\n     */\r\n    public onPrePointerObservable = new Observable<PointerInfoPre>();\r\n\r\n    /**\r\n     * Observable event triggered each time an input event is received from the rendering canvas\r\n     */\r\n    public onPointerObservable = new Observable<PointerInfo>();\r\n\r\n    /**\r\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\r\n     */\r\n    public get unTranslatedPointer(): Vector2 {\r\n        return this._inputManager.unTranslatedPointer;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\r\n     */\r\n    public static get DragMovementThreshold() {\r\n        return InputManager.DragMovementThreshold;\r\n    }\r\n\r\n    public static set DragMovementThreshold(value: number) {\r\n        InputManager.DragMovementThreshold = value;\r\n    }\r\n\r\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\r\n     */\r\n    public static get LongPressDelay() {\r\n        return InputManager.LongPressDelay;\r\n    }\r\n\r\n    public static set LongPressDelay(value: number) {\r\n        InputManager.LongPressDelay = value;\r\n    }\r\n\r\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\r\n     */\r\n    public static get DoubleClickDelay() {\r\n        return InputManager.DoubleClickDelay;\r\n    }\r\n\r\n    public static set DoubleClickDelay(value: number) {\r\n        InputManager.DoubleClickDelay = value;\r\n    }\r\n\r\n    /** If you need to check double click without raising a single click at first click, enable this flag */\r\n    public static get ExclusiveDoubleClickMode() {\r\n        return InputManager.ExclusiveDoubleClickMode;\r\n    }\r\n\r\n    public static set ExclusiveDoubleClickMode(value: boolean) {\r\n        InputManager.ExclusiveDoubleClickMode = value;\r\n    }\r\n\r\n    /**\r\n     * Bind the current view position to an effect.\r\n     * @param effect The effect to be bound\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\r\n     * @returns the computed eye position\r\n     */\r\n    public bindEyePosition(effect: Nullable<Effect>, variableName = \"vEyePosition\", isVector3 = false): Vector4 {\r\n        const eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : this.activeCamera!.globalPosition;\r\n\r\n        const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\r\n\r\n        TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\r\n\r\n        if (effect) {\r\n            if (isVector3) {\r\n                effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\r\n            } else {\r\n                effect.setVector4(variableName, TmpVectors.Vector4[0]);\r\n            }\r\n        }\r\n\r\n        return TmpVectors.Vector4[0];\r\n    }\r\n\r\n    /**\r\n     * Update the scene ubo before it can be used in rendering processing\r\n     * @returns the scene UniformBuffer\r\n     */\r\n    public finalizeSceneUbo(): UniformBuffer {\r\n        const ubo = this.getSceneUniformBuffer();\r\n        const eyePosition = this.bindEyePosition(null);\r\n        ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\r\n\r\n        ubo.update();\r\n\r\n        return ubo;\r\n    }\r\n\r\n    // Mirror\r\n    /** @internal */\r\n    public _mirroredCameraPosition: Nullable<Vector3>;\r\n\r\n    // Keyboard\r\n\r\n    /**\r\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\r\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\r\n     */\r\n    public onPreKeyboardObservable = new Observable<KeyboardInfoPre>();\r\n\r\n    /**\r\n     * Observable event triggered each time an keyboard event is received from the hosting window\r\n     */\r\n    public onKeyboardObservable = new Observable<KeyboardInfo>();\r\n\r\n    // Coordinates system\r\n\r\n    private _useRightHandedSystem = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\r\n     */\r\n    public set useRightHandedSystem(value: boolean) {\r\n        if (this._useRightHandedSystem === value) {\r\n            return;\r\n        }\r\n        this._useRightHandedSystem = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\r\n    }\r\n    public get useRightHandedSystem(): boolean {\r\n        return this._useRightHandedSystem;\r\n    }\r\n\r\n    // Deterministic lockstep\r\n    private _timeAccumulator: number = 0;\r\n    private _currentStepId: number = 0;\r\n    private _currentInternalStep: number = 0;\r\n\r\n    /**\r\n     * Sets the step Id used by deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @param newStepId defines the step Id\r\n     */\r\n    public setStepId(newStepId: number): void {\r\n        this._currentStepId = newStepId;\r\n    }\r\n\r\n    /**\r\n     * Gets the step Id used by deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns the step Id\r\n     */\r\n    public getStepId(): number {\r\n        return this._currentStepId;\r\n    }\r\n\r\n    /**\r\n     * Gets the internal step used by deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns the internal step\r\n     */\r\n    public getInternalStep(): number {\r\n        return this._currentInternalStep;\r\n    }\r\n\r\n    // Fog\r\n\r\n    private _fogEnabled = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if fog is enabled on this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\r\n     * (Default is true)\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\r\n    }\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    private _fogMode = Scene.FOGMODE_NONE;\r\n    /**\r\n     * Gets or sets the fog mode to use\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\r\n     * | mode | value |\r\n     * | --- | --- |\r\n     * | FOGMODE_NONE | 0 |\r\n     * | FOGMODE_EXP | 1 |\r\n     * | FOGMODE_EXP2 | 2 |\r\n     * | FOGMODE_LINEAR | 3 |\r\n     */\r\n    public set fogMode(value: number) {\r\n        if (this._fogMode === value) {\r\n            return;\r\n        }\r\n        this._fogMode = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\r\n    }\r\n    public get fogMode(): number {\r\n        return this._fogMode;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the fog color to use\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\r\n     * (Default is Color3(0.2, 0.2, 0.3))\r\n     */\r\n    public fogColor = new Color3(0.2, 0.2, 0.3);\r\n    /**\r\n     * Gets or sets the fog density to use\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\r\n     * (Default is 0.1)\r\n     */\r\n    public fogDensity = 0.1;\r\n    /**\r\n     * Gets or sets the fog start distance to use\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\r\n     * (Default is 0)\r\n     */\r\n    public fogStart = 0;\r\n    /**\r\n     * Gets or sets the fog end distance to use\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\r\n     * (Default is 1000)\r\n     */\r\n    public fogEnd = 1000.0;\r\n\r\n    /**\r\n     * Flag indicating that the frame buffer binding is handled by another component\r\n     */\r\n    public get prePass(): boolean {\r\n        return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\r\n    }\r\n\r\n    /**\r\n     * Flag indicating if we need to store previous matrices when rendering\r\n     */\r\n    public needsPreviousWorldMatrices = false;\r\n\r\n    // Lights\r\n    private _shadowsEnabled = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if shadows are enabled on this scene\r\n     */\r\n    public set shadowsEnabled(value: boolean) {\r\n        if (this._shadowsEnabled === value) {\r\n            return;\r\n        }\r\n        this._shadowsEnabled = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_LightDirtyFlag);\r\n    }\r\n    public get shadowsEnabled(): boolean {\r\n        return this._shadowsEnabled;\r\n    }\r\n\r\n    private _lightsEnabled = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if lights are enabled on this scene\r\n     */\r\n    public set lightsEnabled(value: boolean) {\r\n        if (this._lightsEnabled === value) {\r\n            return;\r\n        }\r\n        this._lightsEnabled = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_LightDirtyFlag);\r\n    }\r\n\r\n    public get lightsEnabled(): boolean {\r\n        return this._lightsEnabled;\r\n    }\r\n\r\n    private _activeCameras: Nullable<Camera[]>;\r\n    private _unObserveActiveCameras: Nullable<() => void> = null;\r\n\r\n    /** All of the active cameras added to this scene. */\r\n    public get activeCameras(): Nullable<Camera[]> {\r\n        return this._activeCameras;\r\n    }\r\n\r\n    public set activeCameras(cameras: Nullable<Camera[]>) {\r\n        if (this._unObserveActiveCameras) {\r\n            this._unObserveActiveCameras();\r\n            this._unObserveActiveCameras = null;\r\n        }\r\n\r\n        if (cameras) {\r\n            this._unObserveActiveCameras = _ObserveArray(cameras, () => {\r\n                this.onActiveCamerasChanged.notifyObservers(this);\r\n            });\r\n        }\r\n\r\n        this._activeCameras = cameras;\r\n    }\r\n\r\n    /** @internal */\r\n    public _activeCamera: Nullable<Camera>;\r\n    /** Gets or sets the current active camera */\r\n    public get activeCamera(): Nullable<Camera> {\r\n        return this._activeCamera;\r\n    }\r\n\r\n    public set activeCamera(value: Nullable<Camera>) {\r\n        if (value === this._activeCamera) {\r\n            return;\r\n        }\r\n\r\n        this._activeCamera = value;\r\n        this.onActiveCameraChanged.notifyObservers(this);\r\n    }\r\n\r\n    private _defaultMaterial: Material;\r\n\r\n    /** The default material used on meshes when no material is affected */\r\n    public get defaultMaterial(): Material {\r\n        if (!this._defaultMaterial) {\r\n            this._defaultMaterial = Scene.DefaultMaterialFactory(this);\r\n        }\r\n\r\n        return this._defaultMaterial;\r\n    }\r\n\r\n    /** The default material used on meshes when no material is affected */\r\n    public set defaultMaterial(value: Material) {\r\n        this._defaultMaterial = value;\r\n    }\r\n\r\n    // Textures\r\n    private _texturesEnabled = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if textures are enabled on this scene\r\n     */\r\n    public set texturesEnabled(value: boolean) {\r\n        if (this._texturesEnabled === value) {\r\n            return;\r\n        }\r\n        this._texturesEnabled = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    public get texturesEnabled(): boolean {\r\n        return this._texturesEnabled;\r\n    }\r\n\r\n    // Physics\r\n    /**\r\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\r\n     */\r\n    public physicsEnabled = true;\r\n\r\n    // Particles\r\n    /**\r\n     * Gets or sets a boolean indicating if particles are enabled on this scene\r\n     */\r\n    public particlesEnabled = true;\r\n\r\n    // Sprites\r\n    /**\r\n     * Gets or sets a boolean indicating if sprites are enabled on this scene\r\n     */\r\n    public spritesEnabled = true;\r\n\r\n    // Skeletons\r\n    private _skeletonsEnabled = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if skeletons are enabled on this scene\r\n     */\r\n    public set skeletonsEnabled(value: boolean) {\r\n        if (this._skeletonsEnabled === value) {\r\n            return;\r\n        }\r\n        this._skeletonsEnabled = value;\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_AttributesDirtyFlag);\r\n    }\r\n\r\n    public get skeletonsEnabled(): boolean {\r\n        return this._skeletonsEnabled;\r\n    }\r\n\r\n    // Lens flares\r\n    /**\r\n     * Gets or sets a boolean indicating if lens flares are enabled on this scene\r\n     */\r\n    public lensFlaresEnabled = true;\r\n\r\n    // Collisions\r\n    /**\r\n     * Gets or sets a boolean indicating if collisions are enabled on this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public collisionsEnabled = true;\r\n\r\n    private _collisionCoordinator: ICollisionCoordinator;\r\n\r\n    /** @internal */\r\n    public get collisionCoordinator(): ICollisionCoordinator {\r\n        if (!this._collisionCoordinator) {\r\n            this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\r\n            this._collisionCoordinator.init(this);\r\n        }\r\n\r\n        return this._collisionCoordinator;\r\n    }\r\n\r\n    /**\r\n     * Defines the gravity applied to this scene (used only for collisions)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public gravity = new Vector3(0, -9.807, 0);\r\n\r\n    // Postprocesses\r\n    /**\r\n     * Gets or sets a boolean indicating if postprocesses are enabled on this scene\r\n     */\r\n    public postProcessesEnabled = true;\r\n    /**\r\n     * Gets the current postprocess manager\r\n     */\r\n    public postProcessManager: PostProcessManager;\r\n\r\n    // Customs render targets\r\n    /**\r\n     * Gets or sets a boolean indicating if render targets are enabled on this scene\r\n     */\r\n    public renderTargetsEnabled = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\r\n     * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\r\n     */\r\n    public dumpNextRenderTargets = false;\r\n    /**\r\n     * The list of user defined render targets added to the scene\r\n     */\r\n    public customRenderTargets = new Array<RenderTargetTexture>();\r\n\r\n    /**\r\n     * Defines if texture loading must be delayed\r\n     * If true, textures will only be loaded when they need to be rendered\r\n     */\r\n    public useDelayedTextureLoading: boolean;\r\n\r\n    /**\r\n     * Gets the list of meshes imported to the scene through SceneLoader\r\n     */\r\n    public importedMeshesFiles = new Array<string>();\r\n\r\n    // Probes\r\n    /**\r\n     * Gets or sets a boolean indicating if probes are enabled on this scene\r\n     */\r\n    public probesEnabled = true;\r\n\r\n    // Offline support\r\n    /**\r\n     * Gets or sets the current offline provider to use to store scene data\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeCached\r\n     */\r\n    public offlineProvider: IOfflineProvider;\r\n\r\n    /**\r\n     * Gets or sets the action manager associated with the scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\r\n     */\r\n    public actionManager: AbstractActionManager;\r\n\r\n    private _meshesForIntersections = new SmartArrayNoDuplicate<AbstractMesh>(256);\r\n\r\n    // Procedural textures\r\n    /**\r\n     * Gets or sets a boolean indicating if procedural textures are enabled on this scene\r\n     */\r\n    public proceduralTexturesEnabled = true;\r\n\r\n    // Private\r\n    private _engine: Engine;\r\n\r\n    // Performance counters\r\n    private _totalVertices = new PerfCounter();\r\n    /** @internal */\r\n    public _activeIndices = new PerfCounter();\r\n    /** @internal */\r\n    public _activeParticles = new PerfCounter();\r\n    /** @internal */\r\n    public _activeBones = new PerfCounter();\r\n\r\n    private _animationRatio: number;\r\n\r\n    /** @internal */\r\n    public _animationTimeLast: number;\r\n\r\n    /** @internal */\r\n    public _animationTime: number = 0;\r\n\r\n    /**\r\n     * Gets or sets a general scale for animation speed\r\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\r\n     */\r\n    public animationTimeScale: number = 1;\r\n\r\n    /** @internal */\r\n    public _cachedMaterial: Nullable<Material>;\r\n    /** @internal */\r\n    public _cachedEffect: Nullable<Effect>;\r\n    /** @internal */\r\n    public _cachedVisibility: Nullable<number>;\r\n\r\n    private _renderId = 0;\r\n    private _frameId = 0;\r\n    private _executeWhenReadyTimeoutId: Nullable<ReturnType<typeof setTimeout>> = null;\r\n    private _intermediateRendering = false;\r\n    private _defaultFrameBufferCleared = false;\r\n\r\n    private _viewUpdateFlag = -1;\r\n    private _projectionUpdateFlag = -1;\r\n\r\n    /** @internal */\r\n    public _toBeDisposed = new Array<Nullable<IDisposable>>(256);\r\n    private _activeRequests = new Array<IFileRequest>();\r\n\r\n    /** @internal */\r\n    public _pendingData = new Array();\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\r\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\r\n     */\r\n    public dispatchAllSubMeshesOfActiveMeshes: boolean = false;\r\n    private _activeMeshes = new SmartArray<AbstractMesh>(256);\r\n    private _processedMaterials = new SmartArray<Material>(256);\r\n    private _renderTargets = new SmartArrayNoDuplicate<RenderTargetTexture>(256);\r\n    private _materialsRenderTargets = new SmartArrayNoDuplicate<RenderTargetTexture>(256);\r\n    /** @internal */\r\n    public _activeParticleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _activeSkeletons = new SmartArrayNoDuplicate<Skeleton>(32);\r\n    private _softwareSkinnedMeshes = new SmartArrayNoDuplicate<Mesh>(32);\r\n\r\n    private _renderingManager: RenderingManager;\r\n\r\n    /**\r\n     * Gets the scene's rendering manager\r\n     */\r\n    public get renderingManager(): RenderingManager {\r\n        return this._renderingManager;\r\n    }\r\n\r\n    /** @internal */\r\n    public _activeAnimatables = new Array<Animatable>();\r\n\r\n    private _transformMatrix = Matrix.Zero();\r\n    private _sceneUbo: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _viewMatrix: Matrix;\r\n    /** @internal */\r\n    public _projectionMatrix: Matrix;\r\n    /** @internal */\r\n    public _forcedViewPosition: Nullable<Vector3>;\r\n\r\n    /** @internal */\r\n    public _frustumPlanes: Plane[];\r\n    /**\r\n     * Gets the list of frustum planes (built from the active camera)\r\n     */\r\n    public get frustumPlanes(): Plane[] {\r\n        return this._frustumPlanes;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\r\n     * This is useful if there are more lights that the maximum simulteanous authorized\r\n     */\r\n    public requireLightSorting = false;\r\n\r\n    /** @internal */\r\n    public readonly useMaterialMeshMap: boolean;\r\n    /** @internal */\r\n    public readonly useClonedMeshMap: boolean;\r\n\r\n    private _externalData: StringDictionary<Object>;\r\n    private _uid: Nullable<string>;\r\n\r\n    /**\r\n     * @internal\r\n     * Backing store of defined scene components.\r\n     */\r\n    public _components: ISceneComponent[] = [];\r\n\r\n    /**\r\n     * @internal\r\n     * Backing store of defined scene components.\r\n     */\r\n    public _serializableComponents: ISceneSerializableComponent[] = [];\r\n\r\n    /**\r\n     * List of components to register on the next registration step.\r\n     */\r\n    private _transientComponents: ISceneComponent[] = [];\r\n\r\n    /**\r\n     * Registers the transient components if needed.\r\n     */\r\n    private _registerTransientComponents(): void {\r\n        // Register components that have been associated lately to the scene.\r\n        if (this._transientComponents.length > 0) {\r\n            for (const component of this._transientComponents) {\r\n                component.register();\r\n            }\r\n            this._transientComponents.length = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Add a component to the scene.\r\n     * Note that the ccomponent could be registered on th next frame if this is called after\r\n     * the register component stage.\r\n     * @param component Defines the component to add to the scene\r\n     */\r\n    public _addComponent(component: ISceneComponent) {\r\n        this._components.push(component);\r\n        this._transientComponents.push(component);\r\n\r\n        const serializableComponent = component as any;\r\n        if (serializableComponent.addFromContainer && serializableComponent.serialize) {\r\n            this._serializableComponents.push(serializableComponent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Gets a component from the scene.\r\n     * @param name defines the name of the component to retrieve\r\n     * @returns the component or null if not present\r\n     */\r\n    public _getComponent(name: string): Nullable<ISceneComponent> {\r\n        for (const component of this._components) {\r\n            if (component.name === name) {\r\n                return component;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening before camera updates.\r\n     */\r\n    public _beforeCameraUpdateStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening before clear the canvas.\r\n     */\r\n    public _beforeClearStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening before clear the canvas.\r\n     */\r\n    public _beforeRenderTargetClearStage = Stage.Create<RenderTargetStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions when collecting render targets for the frame.\r\n     */\r\n    public _gatherRenderTargetsStage = Stage.Create<RenderTargetsStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening for one camera in the frame.\r\n     */\r\n    public _gatherActiveCameraRenderTargetsStage = Stage.Create<RenderTargetsStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening during the per mesh ready checks.\r\n     */\r\n    public _isReadyForMeshStage = Stage.Create<MeshStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening before evaluate active mesh checks.\r\n     */\r\n    public _beforeEvaluateActiveMeshStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening during the evaluate sub mesh checks.\r\n     */\r\n    public _evaluateSubMeshStage = Stage.Create<EvaluateSubMeshStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening during the active mesh stage.\r\n     */\r\n    public _preActiveMeshStage = Stage.Create<PreActiveMeshStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening during the per camera render target step.\r\n     */\r\n    public _cameraDrawRenderTargetStage = Stage.Create<CameraStageFrameBufferAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just before the active camera is drawing.\r\n     */\r\n    public _beforeCameraDrawStage = Stage.Create<CameraStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just before a render target is drawing.\r\n     */\r\n    public _beforeRenderTargetDrawStage = Stage.Create<RenderTargetStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just before a rendering group is drawing.\r\n     */\r\n    public _beforeRenderingGroupDrawStage = Stage.Create<RenderingGroupStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just before a mesh is drawing.\r\n     */\r\n    public _beforeRenderingMeshStage = Stage.Create<RenderingMeshStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just after a mesh has been drawn.\r\n     */\r\n    public _afterRenderingMeshStage = Stage.Create<RenderingMeshStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just after a rendering group has been drawn.\r\n     */\r\n    public _afterRenderingGroupDrawStage = Stage.Create<RenderingGroupStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just after the active camera has been drawn.\r\n     */\r\n    public _afterCameraDrawStage = Stage.Create<CameraStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just after the post processing\r\n     */\r\n    public _afterCameraPostProcessStage = Stage.Create<CameraStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just after a render target has been drawn.\r\n     */\r\n    public _afterRenderTargetDrawStage = Stage.Create<RenderTargetStageAction>();\r\n    /**\r\n     * Defines the actions happening just after the post processing on a render target\r\n     */\r\n    public _afterRenderTargetPostProcessStage = Stage.Create<RenderTargetStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening just after rendering all cameras and computing intersections.\r\n     */\r\n    public _afterRenderStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening when a pointer move event happens.\r\n     */\r\n    public _pointerMoveStage = Stage.Create<PointerMoveStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening when a pointer down event happens.\r\n     */\r\n    public _pointerDownStage = Stage.Create<PointerUpDownStageAction>();\r\n    /**\r\n     * @internal\r\n     * Defines the actions happening when a pointer up event happens.\r\n     */\r\n    public _pointerUpStage = Stage.Create<PointerUpDownStageAction>();\r\n\r\n    /**\r\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\r\n     */\r\n    private _geometriesByUniqueId: Nullable<{ [uniqueId: string]: number | undefined }> = null;\r\n\r\n    /**\r\n     * Creates a new Scene\r\n     * @param engine defines the engine to use to render this scene\r\n     * @param options defines the scene options\r\n     */\r\n    constructor(engine: Engine, options?: SceneOptions) {\r\n        super();\r\n\r\n        this.activeCameras = new Array<Camera>();\r\n\r\n        const fullOptions = {\r\n            useGeometryUniqueIdsMap: true,\r\n            useMaterialMeshMap: true,\r\n            useClonedMeshMap: true,\r\n            virtual: false,\r\n            ...options,\r\n        };\r\n\r\n        this._engine = engine || EngineStore.LastCreatedEngine;\r\n        if (!fullOptions.virtual) {\r\n            EngineStore._LastCreatedScene = this;\r\n            this._engine.scenes.push(this);\r\n        } else {\r\n            this._engine._virtualScenes.push(this);\r\n        }\r\n\r\n        this._uid = null;\r\n\r\n        this._renderingManager = new RenderingManager(this);\r\n\r\n        if (PostProcessManager) {\r\n            this.postProcessManager = new PostProcessManager(this);\r\n        }\r\n\r\n        if (IsWindowObjectExist()) {\r\n            this.attachControl();\r\n        }\r\n\r\n        // Uniform Buffer\r\n        this._createUbo();\r\n\r\n        // Default Image processing definition\r\n        if (ImageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration = new ImageProcessingConfiguration();\r\n        }\r\n\r\n        this.setDefaultCandidateProviders();\r\n\r\n        if (fullOptions.useGeometryUniqueIdsMap) {\r\n            this._geometriesByUniqueId = {};\r\n        }\r\n\r\n        this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\r\n        this.useClonedMeshMap = fullOptions.useClonedMeshMap;\r\n\r\n        if (!options || !options.virtual) {\r\n            this._engine.onNewSceneAddedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"Scene\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"Scene\";\r\n    }\r\n\r\n    private _defaultMeshCandidates: ISmartArrayLike<AbstractMesh> = {\r\n        data: [],\r\n        length: 0,\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDefaultMeshCandidates(): ISmartArrayLike<AbstractMesh> {\r\n        this._defaultMeshCandidates.data = this.meshes;\r\n        this._defaultMeshCandidates.length = this.meshes.length;\r\n        return this._defaultMeshCandidates;\r\n    }\r\n\r\n    private _defaultSubMeshCandidates: ISmartArrayLike<SubMesh> = {\r\n        data: [],\r\n        length: 0,\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDefaultSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh> {\r\n        this._defaultSubMeshCandidates.data = mesh.subMeshes;\r\n        this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\r\n        return this._defaultSubMeshCandidates;\r\n    }\r\n\r\n    /**\r\n     * Sets the default candidate providers for the scene.\r\n     * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\r\n     * and getCollidingSubMeshCandidates to their default function\r\n     */\r\n    public setDefaultCandidateProviders(): void {\r\n        this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates();\r\n        this.getActiveSubMeshCandidates = (mesh: AbstractMesh) => this._getDefaultSubMeshCandidates(mesh);\r\n        this.getIntersectingSubMeshCandidates = (mesh: AbstractMesh, localRay: Ray) => this._getDefaultSubMeshCandidates(mesh);\r\n        this.getCollidingSubMeshCandidates = (mesh: AbstractMesh, collider: Collider) => this._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     */\r\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\r\n        return this._inputManager.meshUnderPointer;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     */\r\n    public get pointerX(): number {\r\n        return this._inputManager.pointerX;\r\n    }\r\n\r\n    public set pointerX(value: number) {\r\n        this._inputManager.pointerX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     */\r\n    public get pointerY(): number {\r\n        return this._inputManager.pointerY;\r\n    }\r\n\r\n    public set pointerY(value: number) {\r\n        this._inputManager.pointerY = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the cached material (ie. the latest rendered one)\r\n     * @returns the cached material\r\n     */\r\n    public getCachedMaterial(): Nullable<Material> {\r\n        return this._cachedMaterial;\r\n    }\r\n\r\n    /**\r\n     * Gets the cached effect (ie. the latest rendered one)\r\n     * @returns the cached effect\r\n     */\r\n    public getCachedEffect(): Nullable<Effect> {\r\n        return this._cachedEffect;\r\n    }\r\n\r\n    /**\r\n     * Gets the cached visibility state (ie. the latest rendered one)\r\n     * @returns the cached visibility state\r\n     */\r\n    public getCachedVisibility(): Nullable<number> {\r\n        return this._cachedVisibility;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current material / effect / visibility must be bind again\r\n     * @param material defines the current material\r\n     * @param effect defines the current effect\r\n     * @param visibility defines the current visibility state\r\n     * @returns true if one parameter is not cached\r\n     */\r\n    public isCachedMaterialInvalid(material: Material, effect: Effect, visibility: number = 1) {\r\n        return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\r\n    }\r\n\r\n    /**\r\n     * Gets the engine associated with the scene\r\n     * @returns an Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of vertices rendered per frame\r\n     * @returns the total number of vertices rendered per frame\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._totalVertices.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for total vertices\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\r\n     */\r\n    public get totalVerticesPerfCounter(): PerfCounter {\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\r\n     * @returns the total number of active indices rendered per frame\r\n     */\r\n    public getActiveIndices(): number {\r\n        return this._activeIndices.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for active indices\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\r\n     */\r\n    public get totalActiveIndicesPerfCounter(): PerfCounter {\r\n        return this._activeIndices;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of active particles rendered per frame\r\n     * @returns the total number of active particles rendered per frame\r\n     */\r\n    public getActiveParticles(): number {\r\n        return this._activeParticles.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for active particles\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\r\n     */\r\n    public get activeParticlesPerfCounter(): PerfCounter {\r\n        return this._activeParticles;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of active bones rendered per frame\r\n     * @returns the total number of active bones rendered per frame\r\n     */\r\n    public getActiveBones(): number {\r\n        return this._activeBones.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for active bones\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\r\n     */\r\n    public get activeBonesPerfCounter(): PerfCounter {\r\n        return this._activeBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the array of active meshes\r\n     * @returns an array of AbstractMesh\r\n     */\r\n    public getActiveMeshes(): SmartArray<AbstractMesh> {\r\n        return this._activeMeshes;\r\n    }\r\n\r\n    /**\r\n     * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\r\n     * @returns a number\r\n     */\r\n    public getAnimationRatio(): number {\r\n        return this._animationRatio !== undefined ? this._animationRatio : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets an unique Id for the current render phase\r\n     * @returns a number\r\n     */\r\n    public getRenderId(): number {\r\n        return this._renderId;\r\n    }\r\n\r\n    /**\r\n     * Gets an unique Id for the current frame\r\n     * @returns a number\r\n     */\r\n    public getFrameId(): number {\r\n        return this._frameId;\r\n    }\r\n\r\n    /** Call this function if you want to manually increment the render Id*/\r\n    public incrementRenderId(): void {\r\n        this._renderId++;\r\n    }\r\n\r\n    private _createUbo(): void {\r\n        this.setSceneUniformBuffer(this.createSceneUniformBuffer());\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer move on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @returns the current scene\r\n     */\r\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene {\r\n        this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer down on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @returns the current scene\r\n     */\r\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene {\r\n        this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer up on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\r\n     * @returns the current scene\r\n     */\r\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): Scene {\r\n        this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\r\n     * @returns true if the pointer was captured\r\n     */\r\n    public isPointerCaptured(pointerId = 0): boolean {\r\n        return this._inputManager.isPointerCaptured(pointerId);\r\n    }\r\n\r\n    /**\r\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n     * @param attachUp defines if you want to attach events to pointerup\r\n     * @param attachDown defines if you want to attach events to pointerdown\r\n     * @param attachMove defines if you want to attach events to pointermove\r\n     */\r\n    public attachControl(attachUp = true, attachDown = true, attachMove = true): void {\r\n        this._inputManager.attachControl(attachUp, attachDown, attachMove);\r\n    }\r\n\r\n    /** Detaches all event handlers*/\r\n    public detachControl() {\r\n        this._inputManager.detachControl();\r\n    }\r\n\r\n    /**\r\n     * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\r\n     * Delay loaded resources are not taking in account\r\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\r\n     * @returns true if all required resources are ready\r\n     */\r\n    public isReady(checkRenderTargets = true): boolean {\r\n        if (this._isDisposed) {\r\n            return false;\r\n        }\r\n\r\n        let index: number;\r\n        const engine = this.getEngine();\r\n\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n\r\n        engine.currentRenderPassId = this.activeCamera?.renderPassId ?? currentRenderPassId;\r\n\r\n        let isReady = true;\r\n\r\n        // Pending data\r\n        if (this._pendingData.length > 0) {\r\n            isReady = false;\r\n        }\r\n\r\n        // Ensures that the pre-pass renderer is enabled if it is to be enabled.\r\n        this.prePassRenderer?.update();\r\n\r\n        // Meshes\r\n        if (checkRenderTargets) {\r\n            this._processedMaterials.reset();\r\n            this._materialsRenderTargets.reset();\r\n        }\r\n\r\n        for (index = 0; index < this.meshes.length; index++) {\r\n            const mesh = this.meshes[index];\r\n\r\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n                continue;\r\n            }\r\n\r\n            // Do not stop at the first encountered \"unready\" object as we want to ensure\r\n            // all materials are starting off their compilation in parallel.\r\n            if (!mesh.isReady(true)) {\r\n                isReady = false;\r\n                continue;\r\n            }\r\n\r\n            const hardwareInstancedRendering =\r\n                mesh.hasThinInstances ||\r\n                mesh.getClassName() === \"InstancedMesh\" ||\r\n                mesh.getClassName() === \"InstancedLinesMesh\" ||\r\n                (engine.getCaps().instancedArrays && (<Mesh>mesh).instances.length > 0);\r\n            // Is Ready For Mesh\r\n            for (const step of this._isReadyForMeshStage) {\r\n                if (!step.action(mesh, hardwareInstancedRendering)) {\r\n                    isReady = false;\r\n                }\r\n            }\r\n\r\n            if (!checkRenderTargets) {\r\n                continue;\r\n            }\r\n\r\n            const mat = mesh.material || this.defaultMaterial;\r\n            if (mat) {\r\n                if (mat._storeEffectOnSubMeshes) {\r\n                    for (const subMesh of mesh.subMeshes) {\r\n                        const material = subMesh.getMaterial();\r\n                        if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\r\n                            if (this._processedMaterials.indexOf(material) === -1) {\r\n                                this._processedMaterials.push(material);\r\n\r\n                                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures!());\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\r\n                        if (this._processedMaterials.indexOf(mat) === -1) {\r\n                            this._processedMaterials.push(mat);\r\n\r\n                            this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures!());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Render targets\r\n        if (checkRenderTargets) {\r\n            for (index = 0; index < this._materialsRenderTargets.length; ++index) {\r\n                const rtt = this._materialsRenderTargets.data[index];\r\n                if (!rtt.isReadyForRendering()) {\r\n                    isReady = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        for (index = 0; index < this.geometries.length; index++) {\r\n            const geometry = this.geometries[index];\r\n\r\n            if (geometry.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n                isReady = false;\r\n            }\r\n        }\r\n\r\n        // Post-processes\r\n        if (this.activeCameras && this.activeCameras.length > 0) {\r\n            for (const camera of this.activeCameras) {\r\n                if (!camera.isReady(true)) {\r\n                    isReady = false;\r\n                }\r\n            }\r\n        } else if (this.activeCamera) {\r\n            if (!this.activeCamera.isReady(true)) {\r\n                isReady = false;\r\n            }\r\n        }\r\n\r\n        // Particles\r\n        for (const particleSystem of this.particleSystems) {\r\n            if (!particleSystem.isReady()) {\r\n                isReady = false;\r\n            }\r\n        }\r\n\r\n        // Layers\r\n        if (this.layers) {\r\n            for (const layer of this.layers) {\r\n                if (!layer.isReady()) {\r\n                    isReady = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Effects\r\n        if (!engine.areAllEffectsReady()) {\r\n            isReady = false;\r\n        }\r\n\r\n        engine.currentRenderPassId = currentRenderPassId;\r\n\r\n        return isReady;\r\n    }\r\n\r\n    /** Resets all cached information relative to material (including effect and visibility) */\r\n    public resetCachedMaterial(): void {\r\n        this._cachedMaterial = null;\r\n        this._cachedEffect = null;\r\n        this._cachedVisibility = null;\r\n    }\r\n\r\n    /**\r\n     * Registers a function to be called before every frame render\r\n     * @param func defines the function to register\r\n     */\r\n    public registerBeforeRender(func: () => void): void {\r\n        this.onBeforeRenderObservable.add(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function called before every frame render\r\n     * @param func defines the function to unregister\r\n     */\r\n    public unregisterBeforeRender(func: () => void): void {\r\n        this.onBeforeRenderObservable.removeCallback(func);\r\n    }\r\n\r\n    /**\r\n     * Registers a function to be called after every frame render\r\n     * @param func defines the function to register\r\n     */\r\n    public registerAfterRender(func: () => void): void {\r\n        this.onAfterRenderObservable.add(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function called after every frame render\r\n     * @param func defines the function to unregister\r\n     */\r\n    public unregisterAfterRender(func: () => void): void {\r\n        this.onAfterRenderObservable.removeCallback(func);\r\n    }\r\n\r\n    private _executeOnceBeforeRender(func: () => void): void {\r\n        const execFunc = () => {\r\n            func();\r\n            setTimeout(() => {\r\n                this.unregisterBeforeRender(execFunc);\r\n            });\r\n        };\r\n        this.registerBeforeRender(execFunc);\r\n    }\r\n\r\n    /**\r\n     * The provided function will run before render once and will be disposed afterwards.\r\n     * A timeout delay can be provided so that the function will be executed in N ms.\r\n     * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\r\n     * @param func The function to be executed.\r\n     * @param timeout optional delay in ms\r\n     */\r\n    public executeOnceBeforeRender(func: () => void, timeout?: number): void {\r\n        if (timeout !== undefined) {\r\n            setTimeout(() => {\r\n                this._executeOnceBeforeRender(func);\r\n            }, timeout);\r\n        } else {\r\n            this._executeOnceBeforeRender(func);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.\r\n     * @param data defines the object to wait for\r\n     */\r\n    public addPendingData(data: any): void {\r\n        this._pendingData.push(data);\r\n    }\r\n\r\n    /**\r\n     * Remove a pending data from the loading list which has previously been added with addPendingData.\r\n     * @param data defines the object to remove from the pending list\r\n     */\r\n    public removePendingData(data: any): void {\r\n        const wasLoading = this.isLoading;\r\n        const index = this._pendingData.indexOf(data);\r\n\r\n        if (index !== -1) {\r\n            this._pendingData.splice(index, 1);\r\n        }\r\n\r\n        if (wasLoading && !this.isLoading) {\r\n            this.onDataLoadedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the number of items waiting to be loaded\r\n     * @returns the number of items waiting to be loaded\r\n     */\r\n    public getWaitingItemsCount(): number {\r\n        return this._pendingData.length;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean indicating if the scene is still loading data\r\n     */\r\n    public get isLoading(): boolean {\r\n        return this._pendingData.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Registers a function to be executed when the scene is ready\r\n     * @param func - the function to be executed\r\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\r\n     */\r\n    public executeWhenReady(func: () => void, checkRenderTargets = false): void {\r\n        this.onReadyObservable.addOnce(func);\r\n\r\n        if (this._executeWhenReadyTimeoutId !== null) {\r\n            return;\r\n        }\r\n\r\n        this._checkIsReady(checkRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the scene is ready\r\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\r\n     * @returns A promise that resolves when the scene is ready\r\n     */\r\n    public whenReadyAsync(checkRenderTargets = false): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.executeWhenReady(() => {\r\n                resolve();\r\n            }, checkRenderTargets);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkIsReady(checkRenderTargets = false) {\r\n        this._registerTransientComponents();\r\n\r\n        if (this.isReady(checkRenderTargets)) {\r\n            this.onReadyObservable.notifyObservers(this);\r\n\r\n            this.onReadyObservable.clear();\r\n            this._executeWhenReadyTimeoutId = null;\r\n            return;\r\n        }\r\n\r\n        if (this._isDisposed) {\r\n            this.onReadyObservable.clear();\r\n            this._executeWhenReadyTimeoutId = null;\r\n            return;\r\n        }\r\n\r\n        this._executeWhenReadyTimeoutId = setTimeout(() => {\r\n            // Ensure materials effects are checked outside render loops\r\n            this.incrementRenderId();\r\n            this._checkIsReady(checkRenderTargets);\r\n        }, 100);\r\n    }\r\n\r\n    /**\r\n     * Gets all animatable attached to the scene\r\n     */\r\n    public get animatables(): Animatable[] {\r\n        return this._activeAnimatables;\r\n    }\r\n\r\n    /**\r\n     * Resets the last animation time frame.\r\n     * Useful to override when animations start running when loading a scene for the first time.\r\n     */\r\n    public resetLastAnimationTimeFrame(): void {\r\n        this._animationTimeLast = PrecisionDate.Now;\r\n    }\r\n\r\n    // Matrix\r\n\r\n    /**\r\n     * Gets the current view matrix\r\n     * @returns a Matrix\r\n     */\r\n    public getViewMatrix(): Matrix {\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the current projection matrix\r\n     * @returns a Matrix\r\n     */\r\n    public getProjectionMatrix(): Matrix {\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the current transform matrix\r\n     * @returns a Matrix made of View * Projection\r\n     */\r\n    public getTransformMatrix(): Matrix {\r\n        return this._transformMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the current transform matrix\r\n     * @param viewL defines the View matrix to use\r\n     * @param projectionL defines the Projection matrix to use\r\n     * @param viewR defines the right View matrix to use (if provided)\r\n     * @param projectionR defines the right Projection matrix to use (if provided)\r\n     */\r\n    public setTransformMatrix(viewL: Matrix, projectionL: Matrix, viewR?: Matrix, projectionR?: Matrix): void {\r\n        // clear the multiviewSceneUbo if no viewR and projectionR are defined\r\n        if (!viewR && !projectionR && this._multiviewSceneUbo) {\r\n            this._multiviewSceneUbo.dispose();\r\n            this._multiviewSceneUbo = null;\r\n        }\r\n        if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        this._viewUpdateFlag = viewL.updateFlag;\r\n        this._projectionUpdateFlag = projectionL.updateFlag;\r\n        this._viewMatrix = viewL;\r\n        this._projectionMatrix = projectionL;\r\n\r\n        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\r\n\r\n        // Update frustum\r\n        if (!this._frustumPlanes) {\r\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\r\n        } else {\r\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\r\n        }\r\n\r\n        if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\r\n            this._updateMultiviewUbo(viewR, projectionR);\r\n        } else if (this._sceneUbo.useUbo) {\r\n            this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\r\n            this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\r\n            this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the uniform buffer used to store scene data\r\n     * @returns a UniformBuffer\r\n     */\r\n    public getSceneUniformBuffer(): UniformBuffer {\r\n        return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\r\n    }\r\n\r\n    /**\r\n     * Creates a scene UBO\r\n     * @param name name of the uniform buffer (optional, for debugging purpose only)\r\n     * @returns a new ubo\r\n     */\r\n    public createSceneUniformBuffer(name?: string): UniformBuffer {\r\n        const sceneUbo = new UniformBuffer(this._engine, undefined, false, name ?? \"scene\");\r\n        sceneUbo.addUniform(\"viewProjection\", 16);\r\n        sceneUbo.addUniform(\"view\", 16);\r\n        sceneUbo.addUniform(\"projection\", 16);\r\n        sceneUbo.addUniform(\"vEyePosition\", 4);\r\n\r\n        return sceneUbo;\r\n    }\r\n\r\n    /**\r\n     * Sets the scene ubo\r\n     * @param ubo the ubo to set for the scene\r\n     */\r\n    public setSceneUniformBuffer(ubo: UniformBuffer): void {\r\n        this._sceneUbo = ubo;\r\n        this._viewUpdateFlag = -1;\r\n        this._projectionUpdateFlag = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets an unique (relatively to the current scene) Id\r\n     * @returns an unique number for the scene\r\n     */\r\n    public getUniqueId() {\r\n        return UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of scene's meshes\r\n     * @param newMesh defines the mesh to add\r\n     * @param recursive if all child meshes should also be added to the scene\r\n     */\r\n    public addMesh(newMesh: AbstractMesh, recursive = false) {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        this.meshes.push(newMesh);\r\n\r\n        newMesh._resyncLightSources();\r\n\r\n        if (!newMesh.parent) {\r\n            newMesh._addToSceneRootNodes();\r\n        }\r\n\r\n        this.onNewMeshAddedObservable.notifyObservers(newMesh);\r\n\r\n        if (recursive) {\r\n            newMesh.getChildMeshes().forEach((m) => {\r\n                this.addMesh(m);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh for the list of scene's meshes\r\n     * @param toRemove defines the mesh to remove\r\n     * @param recursive if all child meshes should also be removed from the scene\r\n     * @returns the index where the mesh was in the mesh list\r\n     */\r\n    public removeMesh(toRemove: AbstractMesh, recursive = false): number {\r\n        const index = this.meshes.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if mesh found\r\n            this.meshes[index] = this.meshes[this.meshes.length - 1];\r\n            this.meshes.pop();\r\n\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n\r\n        this._inputManager._invalidateMesh(toRemove);\r\n\r\n        this.onMeshRemovedObservable.notifyObservers(toRemove);\r\n        if (recursive) {\r\n            toRemove.getChildMeshes().forEach((m) => {\r\n                this.removeMesh(m);\r\n            });\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Add a transform node to the list of scene's transform nodes\r\n     * @param newTransformNode defines the transform node to add\r\n     */\r\n    public addTransformNode(newTransformNode: TransformNode) {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\r\n            // Already there?\r\n            return;\r\n        }\r\n\r\n        newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\r\n        this.transformNodes.push(newTransformNode);\r\n\r\n        if (!newTransformNode.parent) {\r\n            newTransformNode._addToSceneRootNodes();\r\n        }\r\n\r\n        this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\r\n    }\r\n\r\n    /**\r\n     * Remove a transform node for the list of scene's transform nodes\r\n     * @param toRemove defines the transform node to remove\r\n     * @returns the index where the transform node was in the transform node list\r\n     */\r\n    public removeTransformNode(toRemove: TransformNode): number {\r\n        const index = toRemove._indexInSceneTransformNodesArray;\r\n        if (index !== -1) {\r\n            if (index !== this.transformNodes.length - 1) {\r\n                const lastNode = this.transformNodes[this.transformNodes.length - 1];\r\n                this.transformNodes[index] = lastNode;\r\n                lastNode._indexInSceneTransformNodesArray = index;\r\n            }\r\n\r\n            toRemove._indexInSceneTransformNodesArray = -1;\r\n            this.transformNodes.pop();\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n\r\n        this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a skeleton for the list of scene's skeletons\r\n     * @param toRemove defines the skeleton to remove\r\n     * @returns the index where the skeleton was in the skeleton list\r\n     */\r\n    public removeSkeleton(toRemove: Skeleton): number {\r\n        const index = this.skeletons.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this.skeletons.splice(index, 1);\r\n            this.onSkeletonRemovedObservable.notifyObservers(toRemove);\r\n\r\n            // Clean active container\r\n            this._executeActiveContainerCleanup(this._activeSkeletons);\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a morph target for the list of scene's morph targets\r\n     * @param toRemove defines the morph target to remove\r\n     * @returns the index where the morph target was in the morph target list\r\n     */\r\n    public removeMorphTargetManager(toRemove: MorphTargetManager): number {\r\n        const index = this.morphTargetManagers.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this.morphTargetManagers.splice(index, 1);\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a light for the list of scene's lights\r\n     * @param toRemove defines the light to remove\r\n     * @returns the index where the light was in the light list\r\n     */\r\n    public removeLight(toRemove: Light): number {\r\n        const index = this.lights.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from meshes\r\n            for (const mesh of this.meshes) {\r\n                mesh._removeLightSource(toRemove, false);\r\n            }\r\n\r\n            // Remove from the scene if mesh found\r\n            this.lights.splice(index, 1);\r\n            this.sortLightsByPriority();\r\n\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n        this.onLightRemovedObservable.notifyObservers(toRemove);\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a camera for the list of scene's cameras\r\n     * @param toRemove defines the camera to remove\r\n     * @returns the index where the camera was in the camera list\r\n     */\r\n    public removeCamera(toRemove: Camera): number {\r\n        const index = this.cameras.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if mesh found\r\n            this.cameras.splice(index, 1);\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n        // Remove from activeCameras\r\n        if (this.activeCameras) {\r\n            const index2 = this.activeCameras.indexOf(toRemove);\r\n            if (index2 !== -1) {\r\n                // Remove from the scene if mesh found\r\n                this.activeCameras.splice(index2, 1);\r\n            }\r\n        }\r\n        // Reset the activeCamera\r\n        if (this.activeCamera === toRemove) {\r\n            if (this.cameras.length > 0) {\r\n                this.activeCamera = this.cameras[0];\r\n            } else {\r\n                this.activeCamera = null;\r\n            }\r\n        }\r\n        this.onCameraRemovedObservable.notifyObservers(toRemove);\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a particle system for the list of scene's particle systems\r\n     * @param toRemove defines the particle system to remove\r\n     * @returns the index where the particle system was in the particle system list\r\n     */\r\n    public removeParticleSystem(toRemove: IParticleSystem): number {\r\n        const index = this.particleSystems.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.particleSystems.splice(index, 1);\r\n\r\n            // Clean active container\r\n            this._executeActiveContainerCleanup(this._activeParticleSystems);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a animation for the list of scene's animations\r\n     * @param toRemove defines the animation to remove\r\n     * @returns the index where the animation was in the animation list\r\n     */\r\n    public removeAnimation(toRemove: Animation): number {\r\n        const index = this.animations.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.animations.splice(index, 1);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Will stop the animation of the given target\r\n     * @param target - the target\r\n     * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    public stopAnimation(target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        // Do nothing as code will be provided by animation component\r\n    }\r\n\r\n    /**\r\n     * Removes the given animation group from this scene.\r\n     * @param toRemove The animation group to remove\r\n     * @returns The index of the removed animation group\r\n     */\r\n    public removeAnimationGroup(toRemove: AnimationGroup): number {\r\n        const index = this.animationGroups.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.animationGroups.splice(index, 1);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given multi-material from this scene.\r\n     * @param toRemove The multi-material to remove\r\n     * @returns The index of the removed multi-material\r\n     */\r\n    public removeMultiMaterial(toRemove: MultiMaterial): number {\r\n        const index = this.multiMaterials.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.multiMaterials.splice(index, 1);\r\n        }\r\n\r\n        this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given material from this scene.\r\n     * @param toRemove The material to remove\r\n     * @returns The index of the removed material\r\n     */\r\n    public removeMaterial(toRemove: Material): number {\r\n        const index = toRemove._indexInSceneMaterialArray;\r\n        if (index !== -1 && index < this.materials.length) {\r\n            if (index !== this.materials.length - 1) {\r\n                const lastMaterial = this.materials[this.materials.length - 1];\r\n                this.materials[index] = lastMaterial;\r\n                lastMaterial._indexInSceneMaterialArray = index;\r\n            }\r\n\r\n            toRemove._indexInSceneMaterialArray = -1;\r\n            this.materials.pop();\r\n        }\r\n\r\n        this.onMaterialRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given action manager from this scene.\r\n     * @deprecated\r\n     * @param toRemove The action manager to remove\r\n     * @returns The index of the removed action manager\r\n     */\r\n    public removeActionManager(toRemove: AbstractActionManager): number {\r\n        const index = this.actionManagers.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.actionManagers.splice(index, 1);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given texture from this scene.\r\n     * @param toRemove The texture to remove\r\n     * @returns The index of the removed texture\r\n     */\r\n    public removeTexture(toRemove: BaseTexture): number {\r\n        const index = this.textures.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.textures.splice(index, 1);\r\n        }\r\n        this.onTextureRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Adds the given light to this scene\r\n     * @param newLight The light to add\r\n     */\r\n    public addLight(newLight: Light): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.lights.push(newLight);\r\n        this.sortLightsByPriority();\r\n\r\n        if (!newLight.parent) {\r\n            newLight._addToSceneRootNodes();\r\n        }\r\n\r\n        // Add light to all meshes (To support if the light is removed and then re-added)\r\n        for (const mesh of this.meshes) {\r\n            if (mesh.lightSources.indexOf(newLight) === -1) {\r\n                mesh.lightSources.push(newLight);\r\n                mesh._resyncLightSources();\r\n            }\r\n        }\r\n\r\n        this.onNewLightAddedObservable.notifyObservers(newLight);\r\n    }\r\n\r\n    /**\r\n     * Sorts the list list based on light priorities\r\n     */\r\n    public sortLightsByPriority(): void {\r\n        if (this.requireLightSorting) {\r\n            this.lights.sort(LightConstants.CompareLightsPriority);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the given camera to this scene\r\n     * @param newCamera The camera to add\r\n     */\r\n    public addCamera(newCamera: Camera): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        this.cameras.push(newCamera);\r\n        this.onNewCameraAddedObservable.notifyObservers(newCamera);\r\n\r\n        if (!newCamera.parent) {\r\n            newCamera._addToSceneRootNodes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the given skeleton to this scene\r\n     * @param newSkeleton The skeleton to add\r\n     */\r\n    public addSkeleton(newSkeleton: Skeleton): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.skeletons.push(newSkeleton);\r\n        this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\r\n    }\r\n\r\n    /**\r\n     * Adds the given particle system to this scene\r\n     * @param newParticleSystem The particle system to add\r\n     */\r\n    public addParticleSystem(newParticleSystem: IParticleSystem): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.particleSystems.push(newParticleSystem);\r\n    }\r\n\r\n    /**\r\n     * Adds the given animation to this scene\r\n     * @param newAnimation The animation to add\r\n     */\r\n    public addAnimation(newAnimation: Animation): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.animations.push(newAnimation);\r\n    }\r\n\r\n    /**\r\n     * Adds the given animation group to this scene.\r\n     * @param newAnimationGroup The animation group to add\r\n     */\r\n    public addAnimationGroup(newAnimationGroup: AnimationGroup): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.animationGroups.push(newAnimationGroup);\r\n    }\r\n\r\n    /**\r\n     * Adds the given multi-material to this scene\r\n     * @param newMultiMaterial The multi-material to add\r\n     */\r\n    public addMultiMaterial(newMultiMaterial: MultiMaterial): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.multiMaterials.push(newMultiMaterial);\r\n        this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\r\n    }\r\n\r\n    /**\r\n     * Adds the given material to this scene\r\n     * @param newMaterial The material to add\r\n     */\r\n    public addMaterial(newMaterial: Material): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\r\n            // Already there??\r\n            return;\r\n        }\r\n\r\n        newMaterial._indexInSceneMaterialArray = this.materials.length;\r\n        this.materials.push(newMaterial);\r\n        this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\r\n    }\r\n\r\n    /**\r\n     * Adds the given morph target to this scene\r\n     * @param newMorphTargetManager The morph target to add\r\n     */\r\n    public addMorphTargetManager(newMorphTargetManager: MorphTargetManager): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.morphTargetManagers.push(newMorphTargetManager);\r\n    }\r\n\r\n    /**\r\n     * Adds the given geometry to this scene\r\n     * @param newGeometry The geometry to add\r\n     */\r\n    public addGeometry(newGeometry: Geometry): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        if (this._geometriesByUniqueId) {\r\n            this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\r\n        }\r\n\r\n        this.geometries.push(newGeometry);\r\n    }\r\n\r\n    /**\r\n     * Adds the given action manager to this scene\r\n     * @deprecated\r\n     * @param newActionManager The action manager to add\r\n     */\r\n    public addActionManager(newActionManager: AbstractActionManager): void {\r\n        this.actionManagers.push(newActionManager);\r\n    }\r\n\r\n    /**\r\n     * Adds the given texture to this scene.\r\n     * @param newTexture The texture to add\r\n     */\r\n    public addTexture(newTexture: BaseTexture): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.textures.push(newTexture);\r\n        this.onNewTextureAddedObservable.notifyObservers(newTexture);\r\n    }\r\n\r\n    /**\r\n     * Switch active camera\r\n     * @param newCamera defines the new active camera\r\n     * @param attachControl defines if attachControl must be called for the new active camera (default: true)\r\n     */\r\n    public switchActiveCamera(newCamera: Camera, attachControl = true): void {\r\n        const canvas = this._engine.getInputElement();\r\n\r\n        if (!canvas) {\r\n            return;\r\n        }\r\n\r\n        if (this.activeCamera) {\r\n            this.activeCamera.detachControl();\r\n        }\r\n        this.activeCamera = newCamera;\r\n        if (attachControl) {\r\n            newCamera.attachControl();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * sets the active camera of the scene using its Id\r\n     * @param id defines the camera's Id\r\n     * @returns the new active camera or null if none found.\r\n     */\r\n    public setActiveCameraById(id: string): Nullable<Camera> {\r\n        const camera = this.getCameraById(id);\r\n\r\n        if (camera) {\r\n            this.activeCamera = camera;\r\n            return camera;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * sets the active camera of the scene using its name\r\n     * @param name defines the camera's name\r\n     * @returns the new active camera or null if none found.\r\n     */\r\n    public setActiveCameraByName(name: string): Nullable<Camera> {\r\n        const camera = this.getCameraByName(name);\r\n\r\n        if (camera) {\r\n            this.activeCamera = camera;\r\n            return camera;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get an animation group using its name\r\n     * @param name defines the material's name\r\n     * @returns the animation group or null if none found.\r\n     */\r\n    public getAnimationGroupByName(name: string): Nullable<AnimationGroup> {\r\n        for (let index = 0; index < this.animationGroups.length; index++) {\r\n            if (this.animationGroups[index].name === name) {\r\n                return this.animationGroups[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _getMaterial(allowMultiMaterials: boolean, predicate: (m: Material) => boolean): Nullable<Material> {\r\n        for (let index = 0; index < this.materials.length; index++) {\r\n            const material = this.materials[index];\r\n            if (predicate(material)) {\r\n                return material;\r\n            }\r\n        }\r\n        if (allowMultiMaterials) {\r\n            for (let index = 0; index < this.multiMaterials.length; index++) {\r\n                const material = this.multiMaterials[index];\r\n                if (predicate(material)) {\r\n                    return material;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a material using its unique id\r\n     * @param uniqueId defines the material's unique id\r\n     * @param allowMultiMaterials determines whether multimaterials should be considered\r\n     * @returns the material or null if none found.\r\n     */\r\n    public getMaterialByUniqueID(uniqueId: number, allowMultiMaterials: boolean = false): Nullable<Material> {\r\n        return this._getMaterial(allowMultiMaterials, (m) => m.uniqueId === uniqueId);\r\n    }\r\n\r\n    /**\r\n     * get a material using its id\r\n     * @param id defines the material's Id\r\n     * @param allowMultiMaterials determines whether multimaterials should be considered\r\n     * @returns the material or null if none found.\r\n     */\r\n    public getMaterialById(id: string, allowMultiMaterials: boolean = false): Nullable<Material> {\r\n        return this._getMaterial(allowMultiMaterials, (m) => m.id === id);\r\n    }\r\n\r\n    /**\r\n     * Gets a material using its name\r\n     * @param name defines the material's name\r\n     * @param allowMultiMaterials determines whether multimaterials should be considered\r\n     * @returns the material or null if none found.\r\n     */\r\n    public getMaterialByName(name: string, allowMultiMaterials: boolean = false): Nullable<Material> {\r\n        return this._getMaterial(allowMultiMaterials, (m) => m.name === name);\r\n    }\r\n\r\n    /**\r\n     * Gets a last added material using a given id\r\n     * @param id defines the material's id\r\n     * @param allowMultiMaterials determines whether multimaterials should be considered\r\n     * @returns the last material with the given id or null if none found.\r\n     */\r\n    public getLastMaterialById(id: string, allowMultiMaterials: boolean = false): Nullable<Material> {\r\n        for (let index = this.materials.length - 1; index >= 0; index--) {\r\n            if (this.materials[index].id === id) {\r\n                return this.materials[index];\r\n            }\r\n        }\r\n        if (allowMultiMaterials) {\r\n            for (let index = this.multiMaterials.length - 1; index >= 0; index--) {\r\n                if (this.multiMaterials[index].id === id) {\r\n                    return this.multiMaterials[index];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a texture using its unique id\r\n     * @param uniqueId defines the texture's unique id\r\n     * @returns the texture or null if none found.\r\n     */\r\n    public getTextureByUniqueId(uniqueId: number): Nullable<BaseTexture> {\r\n        for (let index = 0; index < this.textures.length; index++) {\r\n            if (this.textures[index].uniqueId === uniqueId) {\r\n                return this.textures[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a texture using its name\r\n     * @param name defines the texture's name\r\n     * @returns the texture or null if none found.\r\n     */\r\n    public getTextureByName(name: string): Nullable<BaseTexture> {\r\n        for (let index = 0; index < this.textures.length; index++) {\r\n            if (this.textures[index].name === name) {\r\n                return this.textures[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a camera using its Id\r\n     * @param id defines the Id to look for\r\n     * @returns the camera or null if not found\r\n     */\r\n    public getCameraById(id: string): Nullable<Camera> {\r\n        for (let index = 0; index < this.cameras.length; index++) {\r\n            if (this.cameras[index].id === id) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a camera using its unique Id\r\n     * @param uniqueId defines the unique Id to look for\r\n     * @returns the camera or null if not found\r\n     */\r\n    public getCameraByUniqueId(uniqueId: number): Nullable<Camera> {\r\n        for (let index = 0; index < this.cameras.length; index++) {\r\n            if (this.cameras[index].uniqueId === uniqueId) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a camera using its name\r\n     * @param name defines the camera's name\r\n     * @returns the camera or null if none found.\r\n     */\r\n    public getCameraByName(name: string): Nullable<Camera> {\r\n        for (let index = 0; index < this.cameras.length; index++) {\r\n            if (this.cameras[index].name === name) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a bone using its Id\r\n     * @param id defines the bone's Id\r\n     * @returns the bone or null if not found\r\n     */\r\n    public getBoneById(id: string): Nullable<Bone> {\r\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\r\n            const skeleton = this.skeletons[skeletonIndex];\r\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\r\n                if (skeleton.bones[boneIndex].id === id) {\r\n                    return skeleton.bones[boneIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a bone using its id\r\n     * @param name defines the bone's name\r\n     * @returns the bone or null if not found\r\n     */\r\n    public getBoneByName(name: string): Nullable<Bone> {\r\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\r\n            const skeleton = this.skeletons[skeletonIndex];\r\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\r\n                if (skeleton.bones[boneIndex].name === name) {\r\n                    return skeleton.bones[boneIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a light node using its name\r\n     * @param name defines the the light's name\r\n     * @returns the light or null if none found.\r\n     */\r\n    public getLightByName(name: string): Nullable<Light> {\r\n        for (let index = 0; index < this.lights.length; index++) {\r\n            if (this.lights[index].name === name) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a light node using its Id\r\n     * @param id defines the light's Id\r\n     * @returns the light or null if none found.\r\n     */\r\n    public getLightById(id: string): Nullable<Light> {\r\n        for (let index = 0; index < this.lights.length; index++) {\r\n            if (this.lights[index].id === id) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a light node using its scene-generated unique Id\r\n     * @param uniqueId defines the light's unique Id\r\n     * @returns the light or null if none found.\r\n     */\r\n    public getLightByUniqueId(uniqueId: number): Nullable<Light> {\r\n        for (let index = 0; index < this.lights.length; index++) {\r\n            if (this.lights[index].uniqueId === uniqueId) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a particle system by Id\r\n     * @param id defines the particle system Id\r\n     * @returns the corresponding system or null if none found\r\n     */\r\n    public getParticleSystemById(id: string): Nullable<IParticleSystem> {\r\n        for (let index = 0; index < this.particleSystems.length; index++) {\r\n            if (this.particleSystems[index].id === id) {\r\n                return this.particleSystems[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a geometry using its Id\r\n     * @param id defines the geometry's Id\r\n     * @returns the geometry or null if none found.\r\n     */\r\n    public getGeometryById(id: string): Nullable<Geometry> {\r\n        for (let index = 0; index < this.geometries.length; index++) {\r\n            if (this.geometries[index].id === id) {\r\n                return this.geometries[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _getGeometryByUniqueId(uniqueId: number): Nullable<Geometry> {\r\n        if (this._geometriesByUniqueId) {\r\n            const index = this._geometriesByUniqueId[uniqueId];\r\n            if (index !== undefined) {\r\n                return this.geometries[index];\r\n            }\r\n        } else {\r\n            for (let index = 0; index < this.geometries.length; index++) {\r\n                if (this.geometries[index].uniqueId === uniqueId) {\r\n                    return this.geometries[index];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Add a new geometry to this scene\r\n     * @param geometry defines the geometry to be added to the scene.\r\n     * @param force defines if the geometry must be pushed even if a geometry with this id already exists\r\n     * @returns a boolean defining if the geometry was added or not\r\n     */\r\n    public pushGeometry(geometry: Geometry, force?: boolean): boolean {\r\n        if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\r\n            return false;\r\n        }\r\n\r\n        this.addGeometry(geometry);\r\n\r\n        this.onNewGeometryAddedObservable.notifyObservers(geometry);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes an existing geometry\r\n     * @param geometry defines the geometry to be removed from the scene\r\n     * @returns a boolean defining if the geometry was removed or not\r\n     */\r\n    public removeGeometry(geometry: Geometry): boolean {\r\n        let index;\r\n        if (this._geometriesByUniqueId) {\r\n            index = this._geometriesByUniqueId[geometry.uniqueId];\r\n            if (index === undefined) {\r\n                return false;\r\n            }\r\n        } else {\r\n            index = this.geometries.indexOf(geometry);\r\n            if (index < 0) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (index !== this.geometries.length - 1) {\r\n            const lastGeometry = this.geometries[this.geometries.length - 1];\r\n            if (lastGeometry) {\r\n                this.geometries[index] = lastGeometry;\r\n                if (this._geometriesByUniqueId) {\r\n                    this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._geometriesByUniqueId) {\r\n            this._geometriesByUniqueId[geometry.uniqueId] = undefined;\r\n        }\r\n\r\n        this.geometries.pop();\r\n\r\n        this.onGeometryRemovedObservable.notifyObservers(geometry);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of geometries attached to the scene\r\n     * @returns an array of Geometry\r\n     */\r\n    public getGeometries(): Geometry[] {\r\n        return this.geometries;\r\n    }\r\n\r\n    /**\r\n     * Gets the first added mesh found of a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the mesh found or null if not found at all\r\n     */\r\n    public getMeshById(id: string): Nullable<AbstractMesh> {\r\n        for (let index = 0; index < this.meshes.length; index++) {\r\n            if (this.meshes[index].id === id) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of meshes using their Id\r\n     * @param id defines the Id to search for\r\n     * @returns a list of meshes\r\n     */\r\n    public getMeshesById(id: string): Array<AbstractMesh> {\r\n        return this.meshes.filter(function (m) {\r\n            return m.id === id;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the first added transform node found of a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found transform node or null if not found at all.\r\n     */\r\n    public getTransformNodeById(id: string): Nullable<TransformNode> {\r\n        for (let index = 0; index < this.transformNodes.length; index++) {\r\n            if (this.transformNodes[index].id === id) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a transform node with its auto-generated unique Id\r\n     * @param uniqueId defines the unique Id to search for\r\n     * @returns the found transform node or null if not found at all.\r\n     */\r\n    public getTransformNodeByUniqueId(uniqueId: number): Nullable<TransformNode> {\r\n        for (let index = 0; index < this.transformNodes.length; index++) {\r\n            if (this.transformNodes[index].uniqueId === uniqueId) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of transform nodes using their Id\r\n     * @param id defines the Id to search for\r\n     * @returns a list of transform nodes\r\n     */\r\n    public getTransformNodesById(id: string): Array<TransformNode> {\r\n        return this.transformNodes.filter(function (m) {\r\n            return m.id === id;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a mesh with its auto-generated unique Id\r\n     * @param uniqueId defines the unique Id to search for\r\n     * @returns the found mesh or null if not found at all.\r\n     */\r\n    public getMeshByUniqueId(uniqueId: number): Nullable<AbstractMesh> {\r\n        for (let index = 0; index < this.meshes.length; index++) {\r\n            if (this.meshes[index].uniqueId === uniqueId) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a the last added mesh using a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found mesh or null if not found at all.\r\n     */\r\n    public getLastMeshById(id: string): Nullable<AbstractMesh> {\r\n        for (let index = this.meshes.length - 1; index >= 0; index--) {\r\n            if (this.meshes[index].id === id) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a the last transform node using a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found mesh or null if not found at all.\r\n     */\r\n    public getLastTransformNodeById(id: string): Nullable<TransformNode> {\r\n        for (let index = this.transformNodes.length - 1; index >= 0; index--) {\r\n            if (this.transformNodes[index].id === id) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found node or null if not found at all\r\n     */\r\n    public getLastEntryById(id: string): Nullable<Node> {\r\n        let index: number;\r\n        for (index = this.meshes.length - 1; index >= 0; index--) {\r\n            if (this.meshes[index].id === id) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        for (index = this.transformNodes.length - 1; index >= 0; index--) {\r\n            if (this.transformNodes[index].id === id) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        for (index = this.cameras.length - 1; index >= 0; index--) {\r\n            if (this.cameras[index].id === id) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        for (index = this.lights.length - 1; index >= 0; index--) {\r\n            if (this.lights[index].id === id) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a node (Mesh, Camera, Light) using a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found node or null if not found at all\r\n     */\r\n    public getNodeById(id: string): Nullable<Node> {\r\n        const mesh = this.getMeshById(id);\r\n        if (mesh) {\r\n            return mesh;\r\n        }\r\n\r\n        const transformNode = this.getTransformNodeById(id);\r\n        if (transformNode) {\r\n            return transformNode;\r\n        }\r\n\r\n        const light = this.getLightById(id);\r\n        if (light) {\r\n            return light;\r\n        }\r\n\r\n        const camera = this.getCameraById(id);\r\n        if (camera) {\r\n            return camera;\r\n        }\r\n\r\n        const bone = this.getBoneById(id);\r\n        if (bone) {\r\n            return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a node (Mesh, Camera, Light) using a given name\r\n     * @param name defines the name to search for\r\n     * @returns the found node or null if not found at all.\r\n     */\r\n    public getNodeByName(name: string): Nullable<Node> {\r\n        const mesh = this.getMeshByName(name);\r\n        if (mesh) {\r\n            return mesh;\r\n        }\r\n\r\n        const transformNode = this.getTransformNodeByName(name);\r\n        if (transformNode) {\r\n            return transformNode;\r\n        }\r\n\r\n        const light = this.getLightByName(name);\r\n        if (light) {\r\n            return light;\r\n        }\r\n\r\n        const camera = this.getCameraByName(name);\r\n        if (camera) {\r\n            return camera;\r\n        }\r\n\r\n        const bone = this.getBoneByName(name);\r\n        if (bone) {\r\n            return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a mesh using a given name\r\n     * @param name defines the name to search for\r\n     * @returns the found mesh or null if not found at all.\r\n     */\r\n    public getMeshByName(name: string): Nullable<AbstractMesh> {\r\n        for (let index = 0; index < this.meshes.length; index++) {\r\n            if (this.meshes[index].name === name) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a transform node using a given name\r\n     * @param name defines the name to search for\r\n     * @returns the found transform node or null if not found at all.\r\n     */\r\n    public getTransformNodeByName(name: string): Nullable<TransformNode> {\r\n        for (let index = 0; index < this.transformNodes.length; index++) {\r\n            if (this.transformNodes[index].name === name) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\r\n     * @param id defines the Id to search for\r\n     * @returns the found skeleton or null if not found at all.\r\n     */\r\n    public getLastSkeletonById(id: string): Nullable<Skeleton> {\r\n        for (let index = this.skeletons.length - 1; index >= 0; index--) {\r\n            if (this.skeletons[index].id === id) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given auto generated unique id\r\n     * @param  uniqueId defines the unique id to search for\r\n     * @returns the found skeleton or null if not found at all.\r\n     */\r\n    public getSkeletonByUniqueId(uniqueId: number): Nullable<Skeleton> {\r\n        for (let index = 0; index < this.skeletons.length; index++) {\r\n            if (this.skeletons[index].uniqueId === uniqueId) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given id (if many are found, this function will pick the first one)\r\n     * @param id defines the id to search for\r\n     * @returns the found skeleton or null if not found at all.\r\n     */\r\n    public getSkeletonById(id: string): Nullable<Skeleton> {\r\n        for (let index = 0; index < this.skeletons.length; index++) {\r\n            if (this.skeletons[index].id === id) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given name\r\n     * @param name defines the name to search for\r\n     * @returns the found skeleton or null if not found at all.\r\n     */\r\n    public getSkeletonByName(name: string): Nullable<Skeleton> {\r\n        for (let index = 0; index < this.skeletons.length; index++) {\r\n            if (this.skeletons[index].name === name) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\r\n     * @param id defines the id to search for\r\n     * @returns the found morph target manager or null if not found at all.\r\n     */\r\n    public getMorphTargetManagerById(id: number): Nullable<MorphTargetManager> {\r\n        for (let index = 0; index < this.morphTargetManagers.length; index++) {\r\n            if (this.morphTargetManagers[index].uniqueId === id) {\r\n                return this.morphTargetManagers[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a morph target using a given id (if many are found, this function will pick the first one)\r\n     * @param id defines the id to search for\r\n     * @returns the found morph target or null if not found at all.\r\n     */\r\n    public getMorphTargetById(id: string): Nullable<MorphTarget> {\r\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\r\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\r\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\r\n                const target = morphTargetManager.getTarget(index);\r\n                if (target.id === id) {\r\n                    return target;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a morph target using a given name (if many are found, this function will pick the first one)\r\n     * @param name defines the name to search for\r\n     * @returns the found morph target or null if not found at all.\r\n     */\r\n    public getMorphTargetByName(name: string): Nullable<MorphTarget> {\r\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\r\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\r\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\r\n                const target = morphTargetManager.getTarget(index);\r\n                if (target.name === name) {\r\n                    return target;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a post process using a given name (if many are found, this function will pick the first one)\r\n     * @param name defines the name to search for\r\n     * @returns the found post process or null if not found at all.\r\n     */\r\n    public getPostProcessByName(name: string): Nullable<PostProcess> {\r\n        for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\r\n            const postProcess = this.postProcesses[postProcessIndex];\r\n            if (postProcess.name === name) {\r\n                return postProcess;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given mesh is active\r\n     * @param mesh defines the mesh to look for\r\n     * @returns true if the mesh is in the active list\r\n     */\r\n    public isActiveMesh(mesh: AbstractMesh): boolean {\r\n        return this._activeMeshes.indexOf(mesh) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Return a unique id as a string which can serve as an identifier for the scene\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = Tools.RandomId();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /**\r\n     * Add an externally attached data from its key.\r\n     * This method call will fail and return false, if such key already exists.\r\n     * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\r\n     * @param key the unique key that identifies the data\r\n     * @param data the data object to associate to the key for this Engine instance\r\n     * @returns true if no such key were already present and the data was added successfully, false otherwise\r\n     */\r\n    public addExternalData<T extends Object>(key: string, data: T): boolean {\r\n        if (!this._externalData) {\r\n            this._externalData = new StringDictionary<Object>();\r\n        }\r\n        return this._externalData.add(key, data);\r\n    }\r\n\r\n    /**\r\n     * Get an externally attached data from its key\r\n     * @param key the unique key that identifies the data\r\n     * @returns the associated data, if present (can be null), or undefined if not present\r\n     */\r\n    public getExternalData<T>(key: string): Nullable<T> {\r\n        if (!this._externalData) {\r\n            return null;\r\n        }\r\n        return <T>this._externalData.get(key);\r\n    }\r\n\r\n    /**\r\n     * Get an externally attached data from its key, create it using a factory if it's not already present\r\n     * @param key the unique key that identifies the data\r\n     * @param factory the factory that will be called to create the instance if and only if it doesn't exists\r\n     * @returns the associated data, can be null if the factory returned null.\r\n     */\r\n    public getOrAddExternalDataWithFactory<T extends Object>(key: string, factory: (k: string) => T): T {\r\n        if (!this._externalData) {\r\n            this._externalData = new StringDictionary<Object>();\r\n        }\r\n        return <T>this._externalData.getOrAddWithFactory(key, factory);\r\n    }\r\n\r\n    /**\r\n     * Remove an externally attached data from the Engine instance\r\n     * @param key the unique key that identifies the data\r\n     * @returns true if the data was successfully removed, false if it doesn't exist\r\n     */\r\n    public removeExternalData(key: string): boolean {\r\n        return this._externalData.remove(key);\r\n    }\r\n\r\n    private _evaluateSubMesh(subMesh: SubMesh, mesh: AbstractMesh, initialMesh: AbstractMesh, forcePush: boolean): void {\r\n        if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {\r\n            for (const step of this._evaluateSubMeshStage) {\r\n                step.action(mesh, subMesh);\r\n            }\r\n\r\n            const material = subMesh.getMaterial();\r\n            if (material !== null && material !== undefined) {\r\n                // Render targets\r\n                if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\r\n                    if (this._processedMaterials.indexOf(material) === -1) {\r\n                        this._processedMaterials.push(material);\r\n\r\n                        this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures!());\r\n                    }\r\n                }\r\n\r\n                // Dispatch\r\n                this._renderingManager.dispatch(subMesh, mesh, material);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the processed materials smart array preventing retention point in material dispose.\r\n     */\r\n    public freeProcessedMaterials(): void {\r\n        this._processedMaterials.dispose();\r\n    }\r\n\r\n    private _preventFreeActiveMeshesAndRenderingGroups = false;\r\n\r\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\r\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\r\n     * when disposing several meshes in a row or a hierarchy of meshes.\r\n     * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\r\n     */\r\n    public get blockfreeActiveMeshesAndRenderingGroups(): boolean {\r\n        return this._preventFreeActiveMeshesAndRenderingGroups;\r\n    }\r\n\r\n    public set blockfreeActiveMeshesAndRenderingGroups(value: boolean) {\r\n        if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this.freeActiveMeshes();\r\n            this.freeRenderingGroups();\r\n        }\r\n\r\n        this._preventFreeActiveMeshesAndRenderingGroups = value;\r\n    }\r\n\r\n    /**\r\n     * Clear the active meshes smart array preventing retention point in mesh dispose.\r\n     */\r\n    public freeActiveMeshes(): void {\r\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\r\n            return;\r\n        }\r\n\r\n        this._activeMeshes.dispose();\r\n        if (this.activeCamera && this.activeCamera._activeMeshes) {\r\n            this.activeCamera._activeMeshes.dispose();\r\n        }\r\n        if (this.activeCameras) {\r\n            for (let i = 0; i < this.activeCameras.length; i++) {\r\n                const activeCamera = this.activeCameras[i];\r\n                if (activeCamera && activeCamera._activeMeshes) {\r\n                    activeCamera._activeMeshes.dispose();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\r\n            return;\r\n        }\r\n\r\n        if (this._renderingManager) {\r\n            this._renderingManager.freeRenderingGroups();\r\n        }\r\n        if (this.textures) {\r\n            for (let i = 0; i < this.textures.length; i++) {\r\n                const texture = this.textures[i];\r\n                if (texture && (<RenderTargetTexture>texture).renderList) {\r\n                    (<RenderTargetTexture>texture).freeRenderingGroups();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _isInIntermediateRendering(): boolean {\r\n        return this._intermediateRendering;\r\n    }\r\n\r\n    /**\r\n     * Lambda returning the list of potentially active meshes.\r\n     */\r\n    public getActiveMeshCandidates: () => ISmartArrayLike<AbstractMesh>;\r\n\r\n    /**\r\n     * Lambda returning the list of potentially active sub meshes.\r\n     */\r\n    public getActiveSubMeshCandidates: (mesh: AbstractMesh) => ISmartArrayLike<SubMesh>;\r\n\r\n    /**\r\n     * Lambda returning the list of potentially intersecting sub meshes.\r\n     */\r\n    public getIntersectingSubMeshCandidates: (mesh: AbstractMesh, localRay: Ray) => ISmartArrayLike<SubMesh>;\r\n\r\n    /**\r\n     * Lambda returning the list of potentially colliding sub meshes.\r\n     */\r\n    public getCollidingSubMeshCandidates: (mesh: AbstractMesh, collider: Collider) => ISmartArrayLike<SubMesh>;\r\n\r\n    /** @internal */\r\n    public _activeMeshesFrozen = false;\r\n    /** @internal */\r\n    public _activeMeshesFrozenButKeepClipping = false;\r\n    private _skipEvaluateActiveMeshesCompletely = false;\r\n\r\n    /**\r\n     * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\r\n     * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\r\n     * @param onSuccess optional success callback\r\n     * @param onError optional error callback\r\n     * @param freezeMeshes defines if meshes should be frozen (true by default)\r\n     * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)\r\n     * @returns the current scene\r\n     */\r\n    public freezeActiveMeshes(\r\n        skipEvaluateActiveMeshes = false,\r\n        onSuccess?: () => void,\r\n        onError?: (message: string) => void,\r\n        freezeMeshes = true,\r\n        keepFrustumCulling = false\r\n    ): Scene {\r\n        this.executeWhenReady(() => {\r\n            if (!this.activeCamera) {\r\n                onError && onError(\"No active camera found\");\r\n                return;\r\n            }\r\n\r\n            if (!this._frustumPlanes) {\r\n                this.updateTransformMatrix();\r\n            }\r\n\r\n            this._evaluateActiveMeshes();\r\n            this._activeMeshesFrozen = true;\r\n            this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;\r\n            this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\r\n\r\n            if (freezeMeshes) {\r\n                for (let index = 0; index < this._activeMeshes.length; index++) {\r\n                    this._activeMeshes.data[index]._freeze();\r\n                }\r\n            }\r\n            onSuccess && onSuccess();\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this function to restart evaluating active meshes on every frame\r\n     * @returns the current scene\r\n     */\r\n    public unfreezeActiveMeshes(): Scene {\r\n        for (let index = 0; index < this.meshes.length; index++) {\r\n            const mesh = this.meshes[index];\r\n            if (mesh._internalAbstractMeshDataInfo) {\r\n                mesh._internalAbstractMeshDataInfo._isActive = false;\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._activeMeshes.length; index++) {\r\n            this._activeMeshes.data[index]._unFreeze();\r\n        }\r\n\r\n        this._activeMeshesFrozen = false;\r\n        return this;\r\n    }\r\n\r\n    private _executeActiveContainerCleanup(container: SmartArray<any>) {\r\n        const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST;\r\n\r\n        if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\r\n            return; // Do not execute in frozen mode\r\n        }\r\n\r\n        // We need to ensure we are not in the rendering loop\r\n        this.onBeforeRenderObservable.addOnce(() => container.dispose());\r\n    }\r\n\r\n    private _evaluateActiveMeshes(): void {\r\n        if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST) {\r\n            if (this._activeMeshes.length > 0) {\r\n                this.activeCamera?._activeMeshes.reset();\r\n                this._activeMeshes.reset();\r\n                this._renderingManager.reset();\r\n                this._processedMaterials.reset();\r\n                this._activeParticleSystems.reset();\r\n                this._activeSkeletons.reset();\r\n                this._softwareSkinnedMeshes.reset();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this._activeMeshesFrozen && this._activeMeshes.length) {\r\n            if (!this._skipEvaluateActiveMeshesCompletely) {\r\n                const len = this._activeMeshes.length;\r\n                for (let i = 0; i < len; i++) {\r\n                    const mesh = this._activeMeshes.data[i];\r\n                    mesh.computeWorldMatrix();\r\n                }\r\n            }\r\n\r\n            if (this._activeParticleSystems) {\r\n                const psLength = this._activeParticleSystems.length;\r\n                for (let i = 0; i < psLength; i++) {\r\n                    this._activeParticleSystems.data[i].animate();\r\n                }\r\n            }\r\n\r\n            this._renderingManager.resetSprites();\r\n\r\n            return;\r\n        }\r\n\r\n        if (!this.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\r\n\r\n        this.activeCamera._activeMeshes.reset();\r\n        this._activeMeshes.reset();\r\n        this._renderingManager.reset();\r\n        this._processedMaterials.reset();\r\n        this._activeParticleSystems.reset();\r\n        this._activeSkeletons.reset();\r\n        this._softwareSkinnedMeshes.reset();\r\n        this._materialsRenderTargets.reset();\r\n\r\n        for (const step of this._beforeEvaluateActiveMeshStage) {\r\n            step.action();\r\n        }\r\n\r\n        // Determine mesh candidates\r\n        const meshes = this.getActiveMeshCandidates();\r\n\r\n        // Check each mesh\r\n        const len = meshes.length;\r\n        for (let i = 0; i < len; i++) {\r\n            const mesh = meshes.data[i];\r\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\r\n            if (mesh.isBlocked) {\r\n                continue;\r\n            }\r\n\r\n            this._totalVertices.addCount(mesh.getTotalVertices(), false);\r\n\r\n            if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {\r\n                continue;\r\n            }\r\n\r\n            mesh.computeWorldMatrix();\r\n\r\n            // Intersections\r\n            if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(Constants.ACTION_OnIntersectionEnterTrigger, Constants.ACTION_OnIntersectionExitTrigger)) {\r\n                this._meshesForIntersections.pushNoDuplicate(mesh);\r\n            }\r\n\r\n            // Switch to current LOD\r\n            let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\r\n            mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\r\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\r\n            if (meshToRender === undefined || meshToRender === null) {\r\n                continue;\r\n            }\r\n\r\n            // Compute world matrix if LOD is billboard\r\n            if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\r\n                meshToRender.computeWorldMatrix();\r\n            }\r\n\r\n            mesh._preActivate();\r\n\r\n            if (\r\n                mesh.isVisible &&\r\n                mesh.visibility > 0 &&\r\n                (mesh.layerMask & this.activeCamera.layerMask) !== 0 &&\r\n                (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))\r\n            ) {\r\n                this._activeMeshes.push(mesh);\r\n                this.activeCamera._activeMeshes.push(mesh);\r\n\r\n                if (meshToRender !== mesh) {\r\n                    meshToRender._activate(this._renderId, false);\r\n                }\r\n\r\n                for (const step of this._preActiveMeshStage) {\r\n                    step.action(mesh);\r\n                }\r\n\r\n                if (mesh._activate(this._renderId, false)) {\r\n                    if (!mesh.isAnInstance) {\r\n                        meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\r\n                    } else {\r\n                        if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\r\n                            meshToRender = mesh;\r\n                        }\r\n                    }\r\n                    meshToRender._internalAbstractMeshDataInfo._isActive = true;\r\n                    this._activeMesh(mesh, meshToRender);\r\n                }\r\n\r\n                mesh._postActivate();\r\n            }\r\n        }\r\n\r\n        this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\r\n\r\n        // Particle systems\r\n        if (this.particlesEnabled) {\r\n            this.onBeforeParticlesRenderingObservable.notifyObservers(this);\r\n            for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\r\n                const particleSystem = this.particleSystems[particleIndex];\r\n\r\n                if (!particleSystem.isStarted() || !particleSystem.emitter) {\r\n                    continue;\r\n                }\r\n\r\n                const emitter = <any>particleSystem.emitter;\r\n                if (!emitter.position || emitter.isEnabled()) {\r\n                    this._activeParticleSystems.push(particleSystem);\r\n                    particleSystem.animate();\r\n                    this._renderingManager.dispatchParticles(particleSystem);\r\n                }\r\n            }\r\n            this.onAfterParticlesRenderingObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    private _activeMesh(sourceMesh: AbstractMesh, mesh: AbstractMesh): void {\r\n        if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\r\n            if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\r\n                mesh.skeleton.prepare();\r\n                this._activeBones.addCount(mesh.skeleton.bones.length, false);\r\n            }\r\n\r\n            if (!mesh.computeBonesUsingShaders) {\r\n                this._softwareSkinnedMeshes.pushNoDuplicate(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;\r\n\r\n        if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {\r\n            const subMeshes = this.getActiveSubMeshCandidates(mesh);\r\n            const len = subMeshes.length;\r\n            forcePush = forcePush || len === 1;\r\n            for (let i = 0; i < len; i++) {\r\n                const subMesh = subMeshes.data[i];\r\n                this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the transform matrix to update from the current active camera\r\n     * @param force defines a boolean used to force the update even if cache is up to date\r\n     */\r\n    public updateTransformMatrix(force?: boolean): void {\r\n        if (!this.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        if (this.activeCamera._renderingMultiview) {\r\n            const leftCamera = this.activeCamera._rigCameras[0];\r\n            const rightCamera = this.activeCamera._rigCameras[1];\r\n            this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\r\n        } else {\r\n            this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\r\n        }\r\n    }\r\n\r\n    private _bindFrameBuffer(camera: Nullable<Camera>, clear = true) {\r\n        if (camera && camera._multiviewTexture) {\r\n            camera._multiviewTexture._bindFrameBuffer();\r\n        } else if (camera && camera.outputRenderTarget) {\r\n            camera.outputRenderTarget._bindFrameBuffer();\r\n        } else {\r\n            if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\r\n                this._engine.restoreDefaultFramebuffer();\r\n            }\r\n        }\r\n        if (clear) {\r\n            this._clearFrameBuffer(camera);\r\n        }\r\n    }\r\n\r\n    private _clearFrameBuffer(camera: Nullable<Camera>) {\r\n        // we assume the framebuffer currently bound is the right one\r\n        if (camera && camera._multiviewTexture) {\r\n            // no clearing?\r\n        } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {\r\n            const rtt = camera.outputRenderTarget;\r\n            if (rtt.onClearObservable.hasObservers()) {\r\n                rtt.onClearObservable.notifyObservers(this._engine);\r\n            } else if (!rtt.skipInitialClear) {\r\n                if (this.autoClear) {\r\n                    this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\r\n                }\r\n                rtt._cleared = true;\r\n            }\r\n        } else {\r\n            if (!this._defaultFrameBufferCleared) {\r\n                this._defaultFrameBufferCleared = true;\r\n                this._clear();\r\n            } else {\r\n                this._engine.clear(null, false, true, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _allowPostProcessClearColor = true;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _renderForCamera(camera: Camera, rigParent?: Camera, bindFrameBuffer = true): void {\r\n        if (camera && camera._skipRendering) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n\r\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\r\n        this._activeCamera = camera;\r\n\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        // Viewport\r\n        engine.setViewport(this.activeCamera.viewport);\r\n\r\n        // Camera\r\n        this.resetCachedMaterial();\r\n        this._renderId++;\r\n\r\n        if (!this.prePass && bindFrameBuffer) {\r\n            let skipInitialClear = true;\r\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\r\n                skipInitialClear = camera.outputRenderTarget.skipInitialClear;\r\n                if (this.autoClear) {\r\n                    this._defaultFrameBufferCleared = false;\r\n                    camera.outputRenderTarget.skipInitialClear = false;\r\n                }\r\n            }\r\n            this._bindFrameBuffer(this._activeCamera);\r\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\r\n                camera.outputRenderTarget.skipInitialClear = skipInitialClear;\r\n            }\r\n        }\r\n\r\n        this.updateTransformMatrix();\r\n\r\n        this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\r\n\r\n        // Meshes\r\n        this._evaluateActiveMeshes();\r\n\r\n        // Software skinning\r\n        for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\r\n            const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\r\n\r\n            mesh.applySkeleton(<Skeleton>mesh.skeleton);\r\n        }\r\n\r\n        // Render targets\r\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\r\n\r\n        this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\r\n\r\n        if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\r\n            this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\r\n        }\r\n\r\n        if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\r\n            this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\r\n        }\r\n\r\n        if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\r\n            this._renderTargets.pushNoDuplicate(this.environmentTexture as RenderTargetTexture);\r\n        }\r\n\r\n        // Collects render targets from external components.\r\n        for (const step of this._gatherActiveCameraRenderTargetsStage) {\r\n            step.action(this._renderTargets);\r\n        }\r\n\r\n        let needRebind = false;\r\n        if (this.renderTargetsEnabled) {\r\n            this._intermediateRendering = true;\r\n\r\n            if (this._renderTargets.length > 0) {\r\n                Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\r\n                for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\r\n                    const renderTarget = this._renderTargets.data[renderIndex];\r\n                    if (renderTarget._shouldRender()) {\r\n                        this._renderId++;\r\n                        const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\r\n                        renderTarget.render(<boolean>hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n                Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\r\n\r\n                this._renderId++;\r\n            }\r\n\r\n            for (const step of this._cameraDrawRenderTargetStage) {\r\n                needRebind = step.action(this.activeCamera) || needRebind;\r\n            }\r\n\r\n            this._intermediateRendering = false;\r\n        }\r\n\r\n        this._engine.currentRenderPassId = camera.outputRenderTarget?.renderPassId ?? camera.renderPassId ?? Constants.RENDERPASS_MAIN;\r\n\r\n        // Restore framebuffer after rendering to targets\r\n        if (needRebind && !this.prePass) {\r\n            this._bindFrameBuffer(this._activeCamera, false);\r\n        }\r\n\r\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\r\n\r\n        // Prepare Frame\r\n        if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\r\n            this.postProcessManager._prepareFrame();\r\n        }\r\n\r\n        // Before Camera Draw\r\n        for (const step of this._beforeCameraDrawStage) {\r\n            step.action(this.activeCamera);\r\n        }\r\n\r\n        // Render\r\n        this.onBeforeDrawPhaseObservable.notifyObservers(this);\r\n\r\n        if (engine.snapshotRendering && engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST) {\r\n            this.finalizeSceneUbo();\r\n        }\r\n        this._renderingManager.render(null, null, true, true);\r\n        this.onAfterDrawPhaseObservable.notifyObservers(this);\r\n\r\n        // After Camera Draw\r\n        for (const step of this._afterCameraDrawStage) {\r\n            step.action(this.activeCamera);\r\n        }\r\n\r\n        // Finalize frame\r\n        if (this.postProcessManager && !camera._multiviewTexture) {\r\n            // if the camera has an output render target, render the post process to the render target\r\n            const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget! : undefined;\r\n            this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\r\n        }\r\n\r\n        // After post process\r\n        for (const step of this._afterCameraPostProcessStage) {\r\n            step.action(this.activeCamera);\r\n        }\r\n\r\n        // Reset some special arrays\r\n        this._renderTargets.reset();\r\n\r\n        this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\r\n    }\r\n\r\n    private _processSubCameras(camera: Camera, bindFrameBuffer = true): void {\r\n        if (camera.cameraRigMode === Constants.RIG_MODE_NONE || camera._renderingMultiview) {\r\n            if (camera._renderingMultiview && !this._multiviewSceneUbo) {\r\n                this._createMultiviewUbo();\r\n            }\r\n            this._renderForCamera(camera, undefined, bindFrameBuffer);\r\n            this.onAfterRenderCameraObservable.notifyObservers(camera);\r\n            return;\r\n        }\r\n\r\n        if (camera._useMultiviewToSingleView) {\r\n            this._renderMultiviewToSingleView(camera);\r\n        } else {\r\n            // rig cameras\r\n            this.onBeforeCameraRenderObservable.notifyObservers(camera);\r\n            for (let index = 0; index < camera._rigCameras.length; index++) {\r\n                this._renderForCamera(camera._rigCameras[index], camera);\r\n            }\r\n        }\r\n\r\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\r\n        this._activeCamera = camera;\r\n        this.updateTransformMatrix();\r\n        this.onAfterRenderCameraObservable.notifyObservers(camera);\r\n    }\r\n\r\n    private _checkIntersections(): void {\r\n        for (let index = 0; index < this._meshesForIntersections.length; index++) {\r\n            const sourceMesh = this._meshesForIntersections.data[index];\r\n\r\n            if (!sourceMesh.actionManager) {\r\n                continue;\r\n            }\r\n\r\n            for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\r\n                const action: IAction = sourceMesh.actionManager.actions[actionIndex];\r\n\r\n                if (action.trigger === Constants.ACTION_OnIntersectionEnterTrigger || action.trigger === Constants.ACTION_OnIntersectionExitTrigger) {\r\n                    const parameters = action.getTriggerParameter();\r\n                    const otherMesh = parameters.mesh ? parameters.mesh : parameters;\r\n\r\n                    const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\r\n                    const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\r\n\r\n                    if (areIntersecting && currentIntersectionInProgress === -1) {\r\n                        if (action.trigger === Constants.ACTION_OnIntersectionEnterTrigger) {\r\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\r\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\r\n                        } else if (action.trigger === Constants.ACTION_OnIntersectionExitTrigger) {\r\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\r\n                        }\r\n                    } else if (!areIntersecting && currentIntersectionInProgress > -1) {\r\n                        //They intersected, and now they don't.\r\n\r\n                        //is this trigger an exit trigger? execute an event.\r\n                        if (action.trigger === Constants.ACTION_OnIntersectionExitTrigger) {\r\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\r\n                        }\r\n\r\n                        //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\r\n                        if (\r\n                            !sourceMesh.actionManager.hasSpecificTrigger(Constants.ACTION_OnIntersectionExitTrigger, (parameter) => {\r\n                                const parameterMesh = parameter.mesh ? parameter.mesh : parameter;\r\n                                return otherMesh === parameterMesh;\r\n                            }) ||\r\n                            action.trigger === Constants.ACTION_OnIntersectionExitTrigger\r\n                        ) {\r\n                            sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _advancePhysicsEngineStep(step: number) {\r\n        // Do nothing. Code will be replaced if physics engine component is referenced\r\n    }\r\n\r\n    /**\r\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\r\n     */\r\n    public getDeterministicFrameTime: () => number = () => {\r\n        return this._engine.getTimeStep();\r\n    };\r\n\r\n    /** @internal */\r\n    public _animate(): void {\r\n        // Nothing to do as long as Animatable have not been imported.\r\n    }\r\n\r\n    /** Execute all animations (for a frame) */\r\n    public animate() {\r\n        if (this._engine.isDeterministicLockStep()) {\r\n            let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\r\n\r\n            const defaultFrameTime = this._engine.getTimeStep();\r\n            const defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\r\n\r\n            let stepsTaken = 0;\r\n\r\n            const maxSubSteps = this._engine.getLockstepMaxSteps();\r\n\r\n            let internalSteps = Math.floor(deltaTime / defaultFrameTime);\r\n            internalSteps = Math.min(internalSteps, maxSubSteps);\r\n\r\n            while (deltaTime > 0 && stepsTaken < internalSteps) {\r\n                this.onBeforeStepObservable.notifyObservers(this);\r\n\r\n                // Animations\r\n                this._animationRatio = defaultFrameTime * defaultFPS;\r\n                this._animate();\r\n                this.onAfterAnimationsObservable.notifyObservers(this);\r\n\r\n                // Physics\r\n                if (this.physicsEnabled) {\r\n                    this._advancePhysicsEngineStep(defaultFrameTime);\r\n                }\r\n\r\n                this.onAfterStepObservable.notifyObservers(this);\r\n                this._currentStepId++;\r\n\r\n                stepsTaken++;\r\n                deltaTime -= defaultFrameTime;\r\n            }\r\n\r\n            this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\r\n        } else {\r\n            // Animations\r\n            const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\r\n            this._animationRatio = deltaTime * (60.0 / 1000.0);\r\n            this._animate();\r\n            this.onAfterAnimationsObservable.notifyObservers(this);\r\n\r\n            // Physics\r\n            if (this.physicsEnabled) {\r\n                this._advancePhysicsEngineStep(deltaTime);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _clear(): void {\r\n        if (this.autoClearDepthAndStencil || this.autoClear) {\r\n            this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\r\n        }\r\n    }\r\n\r\n    private _checkCameraRenderTarget(camera: Nullable<Camera>) {\r\n        if (camera?.outputRenderTarget && !camera?.isRigCamera) {\r\n            camera.outputRenderTarget._cleared = false;\r\n        }\r\n        if (camera?.rigCameras?.length) {\r\n            for (let i = 0; i < camera.rigCameras.length; ++i) {\r\n                const rtt = camera.rigCameras[i].outputRenderTarget;\r\n                if (rtt) {\r\n                    rtt._cleared = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache of all meshes\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     */\r\n    public resetDrawCache(passId?: number): void {\r\n        if (!this.meshes) {\r\n            return;\r\n        }\r\n\r\n        for (const mesh of this.meshes) {\r\n            mesh.resetDrawCache(passId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render the scene\r\n     * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\r\n     * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\r\n     */\r\n    public render(updateCameras = true, ignoreAnimations = false): void {\r\n        if (this.isDisposed) {\r\n            return;\r\n        }\r\n\r\n        if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\r\n            this._checkIsReady();\r\n        }\r\n\r\n        this._frameId++;\r\n        this._defaultFrameBufferCleared = false;\r\n        this._checkCameraRenderTarget(this.activeCamera);\r\n        if (this.activeCameras?.length) {\r\n            this.activeCameras.forEach(this._checkCameraRenderTarget);\r\n        }\r\n\r\n        // Register components that have been associated lately to the scene.\r\n        this._registerTransientComponents();\r\n\r\n        this._activeParticles.fetchNewFrame();\r\n        this._totalVertices.fetchNewFrame();\r\n        this._activeIndices.fetchNewFrame();\r\n        this._activeBones.fetchNewFrame();\r\n        this._meshesForIntersections.reset();\r\n        this.resetCachedMaterial();\r\n\r\n        this.onBeforeAnimationsObservable.notifyObservers(this);\r\n\r\n        // Actions\r\n        if (this.actionManager) {\r\n            this.actionManager.processTrigger(Constants.ACTION_OnEveryFrameTrigger);\r\n        }\r\n\r\n        // Animations\r\n        if (!ignoreAnimations) {\r\n            this.animate();\r\n        }\r\n\r\n        // Before camera update steps\r\n        for (const step of this._beforeCameraUpdateStage) {\r\n            step.action();\r\n        }\r\n\r\n        // Update Cameras\r\n        if (updateCameras) {\r\n            if (this.activeCameras && this.activeCameras.length > 0) {\r\n                for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\r\n                    const camera = this.activeCameras[cameraIndex];\r\n                    camera.update();\r\n                    if (camera.cameraRigMode !== Constants.RIG_MODE_NONE) {\r\n                        // rig cameras\r\n                        for (let index = 0; index < camera._rigCameras.length; index++) {\r\n                            camera._rigCameras[index].update();\r\n                        }\r\n                    }\r\n                }\r\n            } else if (this.activeCamera) {\r\n                this.activeCamera.update();\r\n                if (this.activeCamera.cameraRigMode !== Constants.RIG_MODE_NONE) {\r\n                    // rig cameras\r\n                    for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {\r\n                        this.activeCamera._rigCameras[index].update();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Before render\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        const engine = this.getEngine();\r\n\r\n        // Customs render targets\r\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\r\n\r\n        const currentActiveCamera = this.activeCameras?.length ? this.activeCameras[0] : this.activeCamera;\r\n        if (this.renderTargetsEnabled) {\r\n            Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\r\n            this._intermediateRendering = true;\r\n            for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\r\n                const renderTarget = this.customRenderTargets[customIndex];\r\n                if (renderTarget._shouldRender()) {\r\n                    this._renderId++;\r\n\r\n                    this.activeCamera = renderTarget.activeCamera || this.activeCamera;\r\n\r\n                    if (!this.activeCamera) {\r\n                        throw new Error(\"Active camera not set\");\r\n                    }\r\n\r\n                    // Viewport\r\n                    engine.setViewport(this.activeCamera.viewport);\r\n\r\n                    // Camera\r\n                    this.updateTransformMatrix();\r\n\r\n                    renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\r\n            this._intermediateRendering = false;\r\n            this._renderId++;\r\n        }\r\n\r\n        this._engine.currentRenderPassId = currentActiveCamera?.renderPassId ?? Constants.RENDERPASS_MAIN;\r\n\r\n        // Restore back buffer\r\n        this.activeCamera = currentActiveCamera;\r\n        if (this._activeCamera && this._activeCamera.cameraRigMode !== Constants.RIG_MODE_CUSTOM && !this.prePass) {\r\n            this._bindFrameBuffer(this._activeCamera, false);\r\n        }\r\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\r\n\r\n        for (const step of this._beforeClearStage) {\r\n            step.action();\r\n        }\r\n\r\n        // Clear\r\n        this._clearFrameBuffer(this.activeCamera);\r\n\r\n        // Collects render targets from external components.\r\n        for (const step of this._gatherRenderTargetsStage) {\r\n            step.action(this._renderTargets);\r\n        }\r\n\r\n        // Multi-cameras?\r\n        if (this.activeCameras && this.activeCameras.length > 0) {\r\n            for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\r\n                this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);\r\n            }\r\n        } else {\r\n            if (!this.activeCamera) {\r\n                throw new Error(\"No camera defined\");\r\n            }\r\n\r\n            this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\r\n        }\r\n\r\n        // Intersection checks\r\n        this._checkIntersections();\r\n\r\n        // Executes the after render stage actions.\r\n        for (const step of this._afterRenderStage) {\r\n            step.action();\r\n        }\r\n\r\n        // After render\r\n        if (this.afterRender) {\r\n            this.afterRender();\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n\r\n        // Cleaning\r\n        if (this._toBeDisposed.length) {\r\n            for (let index = 0; index < this._toBeDisposed.length; index++) {\r\n                const data = this._toBeDisposed[index];\r\n                if (data) {\r\n                    data.dispose();\r\n                }\r\n            }\r\n\r\n            this._toBeDisposed.length = 0;\r\n        }\r\n\r\n        if (this.dumpNextRenderTargets) {\r\n            this.dumpNextRenderTargets = false;\r\n        }\r\n\r\n        this._activeBones.addCount(0, true);\r\n        this._activeIndices.addCount(0, true);\r\n        this._activeParticles.addCount(0, true);\r\n\r\n        this._engine.restoreDefaultFramebuffer();\r\n    }\r\n\r\n    /**\r\n     * Freeze all materials\r\n     * A frozen material will not be updatable but should be faster to render\r\n     * Note: multimaterials will not be frozen, but their submaterials will\r\n     */\r\n    public freezeMaterials(): void {\r\n        for (let i = 0; i < this.materials.length; i++) {\r\n            this.materials[i].freeze();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unfreeze all materials\r\n     * A frozen material will not be updatable but should be faster to render\r\n     */\r\n    public unfreezeMaterials(): void {\r\n        for (let i = 0; i < this.materials.length; i++) {\r\n            this.materials[i].unfreeze();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases all held resources\r\n     */\r\n    public dispose(): void {\r\n        if (this.isDisposed) {\r\n            return;\r\n        }\r\n\r\n        this.beforeRender = null;\r\n        this.afterRender = null;\r\n        this.metadata = null;\r\n\r\n        this.skeletons.length = 0;\r\n        this.morphTargetManagers.length = 0;\r\n        this._transientComponents.length = 0;\r\n        this._isReadyForMeshStage.clear();\r\n        this._beforeEvaluateActiveMeshStage.clear();\r\n        this._evaluateSubMeshStage.clear();\r\n        this._preActiveMeshStage.clear();\r\n        this._cameraDrawRenderTargetStage.clear();\r\n        this._beforeCameraDrawStage.clear();\r\n        this._beforeRenderTargetDrawStage.clear();\r\n        this._beforeRenderingGroupDrawStage.clear();\r\n        this._beforeRenderingMeshStage.clear();\r\n        this._afterRenderingMeshStage.clear();\r\n        this._afterRenderingGroupDrawStage.clear();\r\n        this._afterCameraDrawStage.clear();\r\n        this._afterRenderTargetDrawStage.clear();\r\n        this._afterRenderStage.clear();\r\n        this._beforeCameraUpdateStage.clear();\r\n        this._beforeClearStage.clear();\r\n        this._gatherRenderTargetsStage.clear();\r\n        this._gatherActiveCameraRenderTargetsStage.clear();\r\n        this._pointerMoveStage.clear();\r\n        this._pointerDownStage.clear();\r\n        this._pointerUpStage.clear();\r\n\r\n        this.importedMeshesFiles = new Array<string>();\r\n\r\n        if (this.stopAllAnimations) {\r\n            // Ensures that no animatable notifies a callback that could start a new animation group, constantly adding new animatables to the active list...\r\n            this._activeAnimatables.forEach((animatable) => {\r\n                animatable.onAnimationEndObservable.clear();\r\n                animatable.onAnimationEnd = null;\r\n            });\r\n            this.stopAllAnimations();\r\n        }\r\n\r\n        this.resetCachedMaterial();\r\n\r\n        // Smart arrays\r\n        if (this.activeCamera) {\r\n            this.activeCamera._activeMeshes.dispose();\r\n            this.activeCamera = null;\r\n        }\r\n        this.activeCameras = null;\r\n\r\n        this._activeMeshes.dispose();\r\n        this._renderingManager.dispose();\r\n        this._processedMaterials.dispose();\r\n        this._activeParticleSystems.dispose();\r\n        this._activeSkeletons.dispose();\r\n        this._softwareSkinnedMeshes.dispose();\r\n        this._renderTargets.dispose();\r\n        this._materialsRenderTargets.dispose();\r\n        this._registeredForLateAnimationBindings.dispose();\r\n        this._meshesForIntersections.dispose();\r\n        this._toBeDisposed.length = 0;\r\n\r\n        // Abort active requests\r\n        const activeRequests = this._activeRequests.slice();\r\n        for (const request of activeRequests) {\r\n            request.abort();\r\n        }\r\n        this._activeRequests.length = 0;\r\n\r\n        // Events\r\n        try {\r\n            this.onDisposeObservable.notifyObservers(this);\r\n        } catch (e) {\r\n            console.error(\"An error occurred while calling onDisposeObservable!\", e);\r\n        }\r\n\r\n        this.detachControl();\r\n\r\n        // Detach cameras\r\n        const canvas = this._engine.getInputElement();\r\n\r\n        if (canvas) {\r\n            for (let index = 0; index < this.cameras.length; index++) {\r\n                this.cameras[index].detachControl();\r\n            }\r\n        }\r\n\r\n        // Release animation groups\r\n        this._disposeList(this.animationGroups);\r\n\r\n        // Release lights\r\n        this._disposeList(this.lights);\r\n\r\n        // Release meshes\r\n        this._disposeList(this.meshes, (item) => item.dispose(true));\r\n        this._disposeList(this.transformNodes, (item) => item.dispose(true));\r\n\r\n        // Release cameras\r\n        const cameras = this.cameras;\r\n        this._disposeList(cameras);\r\n\r\n        // Release materials\r\n        if (this._defaultMaterial) {\r\n            this._defaultMaterial.dispose();\r\n        }\r\n        this._disposeList(this.multiMaterials);\r\n        this._disposeList(this.materials);\r\n\r\n        // Release particles\r\n        this._disposeList(this.particleSystems);\r\n\r\n        // Release postProcesses\r\n        this._disposeList(this.postProcesses);\r\n\r\n        // Release textures\r\n        this._disposeList(this.textures);\r\n\r\n        // Release morph targets\r\n        this._disposeList(this.morphTargetManagers);\r\n\r\n        // Release UBO\r\n        this._sceneUbo.dispose();\r\n\r\n        if (this._multiviewSceneUbo) {\r\n            this._multiviewSceneUbo.dispose();\r\n        }\r\n\r\n        // Post-processes\r\n        this.postProcessManager.dispose();\r\n\r\n        // Components\r\n        this._disposeList(this._components);\r\n\r\n        // Remove from engine\r\n        let index = this._engine.scenes.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._engine.scenes.splice(index, 1);\r\n        }\r\n\r\n        if (EngineStore._LastCreatedScene === this) {\r\n            if (this._engine.scenes.length > 0) {\r\n                EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\r\n            } else {\r\n                EngineStore._LastCreatedScene = null;\r\n            }\r\n        }\r\n\r\n        index = this._engine._virtualScenes.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._engine._virtualScenes.splice(index, 1);\r\n        }\r\n\r\n        this._engine.wipeCaches(true);\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderTargetsRenderObservable.clear();\r\n        this.onAfterRenderTargetsRenderObservable.clear();\r\n        this.onAfterStepObservable.clear();\r\n        this.onBeforeStepObservable.clear();\r\n        this.onBeforeActiveMeshesEvaluationObservable.clear();\r\n        this.onAfterActiveMeshesEvaluationObservable.clear();\r\n        this.onBeforeParticlesRenderingObservable.clear();\r\n        this.onAfterParticlesRenderingObservable.clear();\r\n        this.onBeforeDrawPhaseObservable.clear();\r\n        this.onAfterDrawPhaseObservable.clear();\r\n        this.onBeforeAnimationsObservable.clear();\r\n        this.onAfterAnimationsObservable.clear();\r\n        this.onDataLoadedObservable.clear();\r\n        this.onBeforeRenderingGroupObservable.clear();\r\n        this.onAfterRenderingGroupObservable.clear();\r\n        this.onMeshImportedObservable.clear();\r\n        this.onBeforeCameraRenderObservable.clear();\r\n        this.onAfterCameraRenderObservable.clear();\r\n        this.onAfterRenderCameraObservable.clear();\r\n        this.onReadyObservable.clear();\r\n        this.onNewCameraAddedObservable.clear();\r\n        this.onCameraRemovedObservable.clear();\r\n        this.onNewLightAddedObservable.clear();\r\n        this.onLightRemovedObservable.clear();\r\n        this.onNewGeometryAddedObservable.clear();\r\n        this.onGeometryRemovedObservable.clear();\r\n        this.onNewTransformNodeAddedObservable.clear();\r\n        this.onTransformNodeRemovedObservable.clear();\r\n        this.onNewMeshAddedObservable.clear();\r\n        this.onMeshRemovedObservable.clear();\r\n        this.onNewSkeletonAddedObservable.clear();\r\n        this.onSkeletonRemovedObservable.clear();\r\n        this.onNewMaterialAddedObservable.clear();\r\n        this.onNewMultiMaterialAddedObservable.clear();\r\n        this.onMaterialRemovedObservable.clear();\r\n        this.onMultiMaterialRemovedObservable.clear();\r\n        this.onNewTextureAddedObservable.clear();\r\n        this.onTextureRemovedObservable.clear();\r\n        this.onPrePointerObservable.clear();\r\n        this.onPointerObservable.clear();\r\n        this.onPreKeyboardObservable.clear();\r\n        this.onKeyboardObservable.clear();\r\n        this.onActiveCameraChanged.clear();\r\n        this.onScenePerformancePriorityChangedObservable.clear();\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    private _disposeList<T extends IDisposable>(items: T[], callback?: (item: T) => void): void {\r\n        const itemsCopy = items.slice(0);\r\n        callback = callback ?? ((item) => item.dispose());\r\n        for (const item of itemsCopy) {\r\n            callback(item);\r\n        }\r\n        items.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets if the scene is already disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Call this function to reduce memory footprint of the scene.\r\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n     */\r\n    public clearCachedVertexData(): void {\r\n        for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n            const mesh = this.meshes[meshIndex];\r\n            const geometry = (<Mesh>mesh).geometry;\r\n\r\n            if (geometry) {\r\n                geometry.clearCachedData();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will remove the local cached buffer data from texture.\r\n     * It will save memory but will prevent the texture from being rebuilt\r\n     */\r\n    public cleanCachedTextureBuffer(): void {\r\n        for (const baseTexture of this.textures) {\r\n            const buffer = (<Texture>baseTexture)._buffer;\r\n\r\n            if (buffer) {\r\n                (<Texture>baseTexture)._buffer = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world extend vectors with an optional filter\r\n     *\r\n     * @param filterPredicate the predicate - which meshes should be included when calculating the world size\r\n     * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\r\n     */\r\n    public getWorldExtends(filterPredicate?: (mesh: AbstractMesh) => boolean): { min: Vector3; max: Vector3 } {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n        filterPredicate = filterPredicate || (() => true);\r\n        this.meshes.filter(filterPredicate).forEach((mesh) => {\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\r\n                return;\r\n            }\r\n\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n\r\n            const minBox = boundingInfo.boundingBox.minimumWorld;\r\n            const maxBox = boundingInfo.boundingBox.maximumWorld;\r\n\r\n            Vector3.CheckExtends(minBox, min, max);\r\n            Vector3.CheckExtends(maxBox, min, max);\r\n        });\r\n\r\n        return {\r\n            min: min,\r\n            max: max,\r\n        };\r\n    }\r\n\r\n    // Picking\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n     * @param camera defines the camera to use for the picking\r\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n     * @returns a Ray\r\n     */\r\n    public createPickingRay(x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n     * @param result defines the ray where to store the picking ray\r\n     * @param camera defines the camera to use for the picking\r\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns the current scene\r\n     */\r\n    public createPickingRayToRef(\r\n        x: number,\r\n        y: number,\r\n        world: Nullable<Matrix>,\r\n        result: Ray,\r\n        camera: Nullable<Camera>,\r\n        cameraViewSpace = false,\r\n        enableDistantPicking = false\r\n    ): Scene {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param camera defines the camera to use for the picking\r\n     * @returns a Ray\r\n     */\r\n    public createPickingRayInCameraSpace(x: number, y: number, camera?: Camera): Ray {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param result defines the ray where to store the picking ray\r\n     * @param camera defines the camera to use for the picking\r\n     * @returns the current scene\r\n     */\r\n    public createPickingRayInCameraSpaceToRef(x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /** @internal */\r\n    public get _pickingAvailable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _registeredActions: number = 0;\r\n\r\n    /** Launch a ray to try to pick a mesh in the scene\r\n     * @param x position on screen\r\n     * @param y position on screen\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns a PickingInfo\r\n     */\r\n    public pick(\r\n        x: number,\r\n        y: number,\r\n        predicate?: (mesh: AbstractMesh) => boolean,\r\n        fastCheck?: boolean,\r\n        camera?: Nullable<Camera>,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): PickingInfo {\r\n        // Dummy info if picking as not been imported\r\n        return new PickingInfo();\r\n    }\r\n\r\n    /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\r\n     * @param x position on screen\r\n     * @param y position on screen\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n     * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\r\n     */\r\n    public pickWithBoundingInfo(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n        // Dummy info if picking as not been imported\r\n        return new PickingInfo();\r\n    }\r\n\r\n    /**\r\n     * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param ray The ray to use to pick meshes\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns a PickingInfo\r\n     */\r\n    public pickWithRay(ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param x X position on screen\r\n     * @param y Y position on screen\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns an array of PickingInfo\r\n     */\r\n    public multiPick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Launch a ray to try to pick a mesh in the scene\r\n     * @param ray Ray to use\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns an array of PickingInfo\r\n     */\r\n    public multiPickWithRay(ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Force the value of meshUnderPointer\r\n     * @param mesh defines the mesh to use\r\n     * @param pointerId optional pointer id when using more than one pointer\r\n     * @param pickResult optional pickingInfo data used to find mesh\r\n     */\r\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId?: number, pickResult?: Nullable<PickingInfo>): void {\r\n        this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh under the pointer\r\n     * @returns a Mesh or null if no mesh is under the pointer\r\n     */\r\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\r\n        return this._inputManager.getPointerOverMesh();\r\n    }\r\n\r\n    // Misc.\r\n    /** @internal */\r\n    public _rebuildGeometries(): void {\r\n        for (const geometry of this.geometries) {\r\n            geometry._rebuild();\r\n        }\r\n\r\n        for (const mesh of this.meshes) {\r\n            mesh._rebuild();\r\n        }\r\n\r\n        if (this.postProcessManager) {\r\n            this.postProcessManager._rebuild();\r\n        }\r\n\r\n        for (const component of this._components) {\r\n            component.rebuild();\r\n        }\r\n\r\n        for (const system of this.particleSystems) {\r\n            system.rebuild();\r\n        }\r\n\r\n        if (this.spriteManagers) {\r\n            for (const spriteMgr of this.spriteManagers) {\r\n                spriteMgr.rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuildTextures(): void {\r\n        for (const texture of this.textures) {\r\n            texture._rebuild();\r\n        }\r\n\r\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Get from a list of objects by tags\r\n     * @param list the list of objects to use\r\n     * @param tagsQuery the query to use\r\n     * @param filter a predicate to filter for tags\r\n     * @returns\r\n     */\r\n    private _getByTags(list: any[], tagsQuery: string, filter?: (item: any) => boolean): any[] {\r\n        if (tagsQuery === undefined) {\r\n            // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\r\n            return list;\r\n        }\r\n\r\n        const listByTags = [];\r\n\r\n        for (const i in list) {\r\n            const item = list[i];\r\n            if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {\r\n                listByTags.push(item);\r\n            }\r\n        }\r\n\r\n        return listByTags;\r\n    }\r\n\r\n    /**\r\n     * Get a list of meshes by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Mesh\r\n     */\r\n    public getMeshesByTags(tagsQuery: string, filter?: (mesh: AbstractMesh) => boolean): Mesh[] {\r\n        return this._getByTags(this.meshes, tagsQuery, filter);\r\n    }\r\n\r\n    /**\r\n     * Get a list of cameras by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Camera\r\n     */\r\n    public getCamerasByTags(tagsQuery: string, filter?: (camera: Camera) => boolean): Camera[] {\r\n        return this._getByTags(this.cameras, tagsQuery, filter);\r\n    }\r\n\r\n    /**\r\n     * Get a list of lights by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Light\r\n     */\r\n    public getLightsByTags(tagsQuery: string, filter?: (light: Light) => boolean): Light[] {\r\n        return this._getByTags(this.lights, tagsQuery, filter);\r\n    }\r\n\r\n    /**\r\n     * Get a list of materials by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Material\r\n     */\r\n    public getMaterialByTags(tagsQuery: string, filter?: (material: Material) => boolean): Material[] {\r\n        return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));\r\n    }\r\n\r\n    /**\r\n     * Get a list of transform nodes by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of TransformNode\r\n     */\r\n    public getTransformNodesByTags(tagsQuery: string, filter?: (transform: TransformNode) => boolean): TransformNode[] {\r\n        return this._getByTags(this.transformNodes, tagsQuery, filter);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversly depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ): void {\r\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._renderingManager.getAutoClearDepthStencilSetup(index);\r\n    }\r\n\r\n    private _blockMaterialDirtyMechanism = false;\r\n\r\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\r\n    public get blockMaterialDirtyMechanism(): boolean {\r\n        return this._blockMaterialDirtyMechanism;\r\n    }\r\n\r\n    public set blockMaterialDirtyMechanism(value: boolean) {\r\n        if (this._blockMaterialDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockMaterialDirtyMechanism = value;\r\n\r\n        if (!value) {\r\n            // Do a complete update\r\n            this.markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will flag all materials as dirty to trigger new shader compilation\r\n     * @param flag defines the flag used to specify which material part must be marked as dirty\r\n     * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\r\n     */\r\n    public markAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void {\r\n        if (this._blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        for (const material of this.materials) {\r\n            if (predicate && !predicate(material)) {\r\n                continue;\r\n            }\r\n            material.markAsDirty(flag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        useOfflineSupport?: boolean,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add((request) => {\r\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFileAsync(\r\n        fileOrUrl: File | string,\r\n        onProgress?: (data: any) => void,\r\n        useOfflineSupport?: boolean,\r\n        useArrayBuffer?: boolean,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): Promise<string | ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadFile(\r\n                fileOrUrl,\r\n                (data) => {\r\n                    resolve(data);\r\n                },\r\n                onProgress,\r\n                useOfflineSupport,\r\n                useArrayBuffer,\r\n                (request, exception) => {\r\n                    reject(exception);\r\n                },\r\n                onOpened\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _requestFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, request?: WebRequest) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        useOfflineSupport?: boolean,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (error: RequestFileError) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add((request) => {\r\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _requestFileAsync(\r\n        url: string,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        useOfflineSupport?: boolean,\r\n        useArrayBuffer?: boolean,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): Promise<string | ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            this._requestFile(\r\n                url,\r\n                (data) => {\r\n                    resolve(data);\r\n                },\r\n                onProgress,\r\n                useOfflineSupport,\r\n                useArrayBuffer,\r\n                (error) => {\r\n                    reject(error);\r\n                },\r\n                onOpened\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readFile(\r\n        file: File,\r\n        onSuccess: (data: string | ArrayBuffer) => void,\r\n        onProgress?: (ev: ProgressEvent) => any,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (error: ReadFileError) => void\r\n    ): IFileRequest {\r\n        const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add((request) => {\r\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readFileAsync(file: File, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean): Promise<string | ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            this._readFile(\r\n                file,\r\n                (data) => {\r\n                    resolve(data);\r\n                },\r\n                onProgress,\r\n                useArrayBuffer,\r\n                (error) => {\r\n                    reject(error);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Internal perfCollector instance used for sharing between inspector and playground.\r\n     * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\r\n     */\r\n    protected _perfCollector: Nullable<PerformanceViewerCollector> = null;\r\n\r\n    /**\r\n     * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\r\n     * @returns the perf collector belonging to the scene.\r\n     */\r\n    public getPerfCollector(): PerformanceViewerCollector {\r\n        throw _WarnImport(\"performanceViewerSceneExtension\");\r\n    }\r\n\r\n    // deprecated\r\n\r\n    /**\r\n     * Sets the active camera of the scene using its Id\r\n     * @param id defines the camera's Id\r\n     * @returns the new active camera or null if none found.\r\n     * @deprecated Please use setActiveCameraById instead\r\n     */\r\n    setActiveCameraByID(id: string): Nullable<Camera> {\r\n        return this.setActiveCameraById(id);\r\n    }\r\n    /**\r\n     * Get a material using its id\r\n     * @param id defines the material's Id\r\n     * @returns the material or null if none found.\r\n     * @deprecated Please use getMaterialById instead\r\n     */\r\n    getMaterialByID(id: string): Nullable<Material> {\r\n        return this.getMaterialById(id);\r\n    }\r\n    /**\r\n     * Gets a the last added material using a given id\r\n     * @param id defines the material's Id\r\n     * @returns the last material with the given id or null if none found.\r\n     * @deprecated Please use getLastMaterialById instead\r\n     */\r\n    getLastMaterialByID(id: string): Nullable<Material> {\r\n        return this.getLastMaterialById(id);\r\n    }\r\n\r\n    /**\r\n     * Get a texture using its unique id\r\n     * @param uniqueId defines the texture's unique id\r\n     * @returns the texture or null if none found.\r\n     * @deprecated Please use getTextureByUniqueId instead\r\n     */\r\n    getTextureByUniqueID(uniqueId: number): Nullable<BaseTexture> {\r\n        return this.getTextureByUniqueId(uniqueId);\r\n    }\r\n    /**\r\n     * Gets a camera using its Id\r\n     * @param id defines the Id to look for\r\n     * @returns the camera or null if not found\r\n     * @deprecated Please use getCameraById instead\r\n     */\r\n    getCameraByID(id: string): Nullable<Camera> {\r\n        return this.getCameraById(id);\r\n    }\r\n    /**\r\n     * Gets a camera using its unique Id\r\n     * @param uniqueId defines the unique Id to look for\r\n     * @returns the camera or null if not found\r\n     * @deprecated Please use getCameraByUniqueId instead\r\n     */\r\n    getCameraByUniqueID(uniqueId: number): Nullable<Camera> {\r\n        return this.getCameraByUniqueId(uniqueId);\r\n    }\r\n    /**\r\n     * Gets a bone using its Id\r\n     * @param id defines the bone's Id\r\n     * @returns the bone or null if not found\r\n     * @deprecated Please use getBoneById instead\r\n     */\r\n    getBoneByID(id: string): Nullable<Bone> {\r\n        return this.getBoneById(id);\r\n    }\r\n    /**\r\n     * Gets a light node using its Id\r\n     * @param id defines the light's Id\r\n     * @returns the light or null if none found.\r\n     * @deprecated Please use getLightById instead\r\n     */\r\n    getLightByID(id: string): Nullable<Light> {\r\n        return this.getLightById(id);\r\n    }\r\n    /**\r\n     * Gets a light node using its scene-generated unique Id\r\n     * @param uniqueId defines the light's unique Id\r\n     * @returns the light or null if none found.\r\n     * @deprecated Please use getLightByUniqueId instead\r\n     */\r\n    getLightByUniqueID(uniqueId: number): Nullable<Light> {\r\n        return this.getLightByUniqueId(uniqueId);\r\n    }\r\n    /**\r\n     * Gets a particle system by Id\r\n     * @param id defines the particle system Id\r\n     * @returns the corresponding system or null if none found\r\n     * @deprecated Please use getParticleSystemById instead\r\n     */\r\n    getParticleSystemByID(id: string): Nullable<IParticleSystem> {\r\n        return this.getParticleSystemById(id);\r\n    }\r\n    /**\r\n     * Gets a geometry using its Id\r\n     * @param id defines the geometry's Id\r\n     * @returns the geometry or null if none found.\r\n     * @deprecated Please use getGeometryById instead\r\n     */\r\n    getGeometryByID(id: string): Nullable<Geometry> {\r\n        return this.getGeometryById(id);\r\n    }\r\n    /**\r\n     * Gets the first added mesh found of a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the mesh found or null if not found at all\r\n     * @deprecated Please use getMeshById instead\r\n     */\r\n    getMeshByID(id: string): Nullable<AbstractMesh> {\r\n        return this.getMeshById(id);\r\n    }\r\n    /**\r\n     * Gets a mesh with its auto-generated unique Id\r\n     * @param uniqueId defines the unique Id to search for\r\n     * @returns the found mesh or null if not found at all.\r\n     * @deprecated Please use getMeshByUniqueId instead\r\n     */\r\n    getMeshByUniqueID(uniqueId: number): Nullable<AbstractMesh> {\r\n        return this.getMeshByUniqueId(uniqueId);\r\n    }\r\n    /**\r\n     * Gets a the last added mesh using a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found mesh or null if not found at all.\r\n     * @deprecated Please use getLastMeshById instead\r\n     */\r\n    getLastMeshByID(id: string): Nullable<AbstractMesh> {\r\n        return this.getLastMeshById(id);\r\n    }\r\n    /**\r\n     * Gets a list of meshes using their Id\r\n     * @param id defines the Id to search for\r\n     * @returns a list of meshes\r\n     * @deprecated Please use getMeshesById instead\r\n     */\r\n    getMeshesByID(id: string): Array<AbstractMesh> {\r\n        return this.getMeshesById(id);\r\n    }\r\n    /**\r\n     * Gets the first added transform node found of a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found transform node or null if not found at all.\r\n     * @deprecated Please use getTransformNodeById instead\r\n     */\r\n    getTransformNodeByID(id: string): Nullable<TransformNode> {\r\n        return this.getTransformNodeById(id);\r\n    }\r\n    /**\r\n     * Gets a transform node with its auto-generated unique Id\r\n     * @param uniqueId defines the unique Id to search for\r\n     * @returns the found transform node or null if not found at all.\r\n     * @deprecated Please use getTransformNodeByUniqueId instead\r\n     */\r\n    getTransformNodeByUniqueID(uniqueId: number): Nullable<TransformNode> {\r\n        return this.getTransformNodeByUniqueId(uniqueId);\r\n    }\r\n    /**\r\n     * Gets a list of transform nodes using their Id\r\n     * @param id defines the Id to search for\r\n     * @returns a list of transform nodes\r\n     * @deprecated Please use getTransformNodesById instead\r\n     */\r\n    getTransformNodesByID(id: string): Array<TransformNode> {\r\n        return this.getTransformNodesById(id);\r\n    }\r\n    /**\r\n     * Gets a node (Mesh, Camera, Light) using a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found node or null if not found at all\r\n     * @deprecated Please use getNodeById instead\r\n     */\r\n    getNodeByID(id: string): Nullable<Node> {\r\n        return this.getNodeById(id);\r\n    }\r\n    /**\r\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\r\n     * @param id defines the Id to search for\r\n     * @returns the found node or null if not found at all\r\n     * @deprecated Please use getLastEntryById instead\r\n     */\r\n    getLastEntryByID(id: string): Nullable<Node> {\r\n        return this.getLastEntryById(id);\r\n    }\r\n    /**\r\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\r\n     * @param id defines the Id to search for\r\n     * @returns the found skeleton or null if not found at all.\r\n     * @deprecated Please use getLastSkeletonById instead\r\n     */\r\n    getLastSkeletonByID(id: string): Nullable<Skeleton> {\r\n        return this.getLastSkeletonById(id);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}