{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Buffer, VertexBuffer } from \"./buffer.js\";\nconst isLittleEndian = (() => {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !!((view[0] = 1) & array[0]);\n})();\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteStride\", {\n  get: function () {\n    return this._alignedBuffer && this._alignedBuffer.byteStride || this.byteStride;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteOffset\", {\n  get: function () {\n    return this._alignedBuffer ? 0 : this.byteOffset;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(VertexBuffer.prototype, \"effectiveBuffer\", {\n  get: function () {\n    return this._alignedBuffer && this._alignedBuffer.getBuffer() || this._buffer.getBuffer();\n  },\n  enumerable: true,\n  configurable: true\n});\nVertexBuffer.prototype._rebuild = function () {\n  var _a, _b;\n  (_a = this._buffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n  (_b = this._alignedBuffer) === null || _b === void 0 ? void 0 : _b._rebuild();\n};\nVertexBuffer.prototype.dispose = function () {\n  var _a;\n  if (this._ownsBuffer) {\n    this._buffer.dispose();\n  }\n  (_a = this._alignedBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n  this._alignedBuffer = undefined;\n  this._isDisposed = true;\n};\nVertexBuffer.prototype._alignBuffer = function () {\n  var _a, _b;\n  const data = this._buffer.getData();\n  if (!this.engine._features.forceVertexBufferStrideMultiple4Bytes || this.byteStride % 4 === 0 || !data) {\n    return;\n  }\n  const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\n  const alignedByteStride = this.byteStride + 3 & ~3;\n  const alignedSize = alignedByteStride / typeByteLength;\n  const totalVertices = this.totalVertices;\n  const totalByteLength = totalVertices * alignedByteStride;\n  const totalLength = totalByteLength / typeByteLength;\n  let sourceData;\n  if (Array.isArray(data)) {\n    const sourceDataAsFloat = new Float32Array(data);\n    sourceData = new DataView(sourceDataAsFloat.buffer, sourceDataAsFloat.byteOffset, sourceDataAsFloat.byteLength);\n  } else if (data instanceof ArrayBuffer) {\n    sourceData = new DataView(data, 0, data.byteLength);\n  } else {\n    sourceData = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  }\n  let alignedData;\n  if (this.type === VertexBuffer.BYTE) {\n    alignedData = new Int8Array(totalLength);\n  } else if (this.type === VertexBuffer.UNSIGNED_BYTE) {\n    alignedData = new Uint8Array(totalLength);\n  } else if (this.type === VertexBuffer.SHORT) {\n    alignedData = new Int16Array(totalLength);\n  } else if (this.type === VertexBuffer.UNSIGNED_SHORT) {\n    alignedData = new Uint16Array(totalLength);\n  } else if (this.type === VertexBuffer.INT) {\n    alignedData = new Int32Array(totalLength);\n  } else if (this.type === VertexBuffer.UNSIGNED_INT) {\n    alignedData = new Uint32Array(totalLength);\n  } else {\n    alignedData = new Float32Array(totalLength);\n  }\n  const numComponents = this.getSize();\n  let sourceOffset = this.byteOffset;\n  for (let i = 0; i < totalVertices; ++i) {\n    for (let j = 0; j < numComponents; ++j) {\n      switch (this.type) {\n        case VertexBuffer.BYTE:\n          alignedData[i * alignedSize + j] = sourceData.getInt8(sourceOffset + j);\n          break;\n        case VertexBuffer.UNSIGNED_BYTE:\n          alignedData[i * alignedSize + j] = sourceData.getUint8(sourceOffset + j);\n          break;\n        case VertexBuffer.SHORT:\n          alignedData[i * alignedSize + j] = sourceData.getInt16(sourceOffset + j * 2, isLittleEndian);\n          break;\n        case VertexBuffer.UNSIGNED_SHORT:\n          alignedData[i * alignedSize + j] = sourceData.getUint16(sourceOffset + j * 2, isLittleEndian);\n          break;\n        case VertexBuffer.INT:\n          alignedData[i * alignedSize + j] = sourceData.getInt32(sourceOffset + j * 4, isLittleEndian);\n          break;\n        case VertexBuffer.UNSIGNED_INT:\n          alignedData[i * alignedSize + j] = sourceData.getUint32(sourceOffset + j * 4, isLittleEndian);\n          break;\n        case VertexBuffer.FLOAT:\n          alignedData[i * alignedSize + j] = sourceData.getFloat32(sourceOffset + j * 4, isLittleEndian);\n          break;\n      }\n    }\n    sourceOffset += this.byteStride;\n  }\n  (_a = this._alignedBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n  this._alignedBuffer = new Buffer(this.engine, alignedData, false, alignedByteStride, false, this.getIsInstanced(), true, this.instanceDivisor, ((_b = this._label) !== null && _b !== void 0 ? _b : \"VertexBuffer\") + \"_aligned\");\n};","map":{"version":3,"names":["Buffer","VertexBuffer","isLittleEndian","array","Uint8Array","view","Uint32Array","buffer","Object","defineProperty","prototype","get","_alignedBuffer","byteStride","enumerable","configurable","byteOffset","getBuffer","_buffer","_rebuild","_a","_b","dispose","_ownsBuffer","undefined","_isDisposed","_alignBuffer","data","getData","engine","_features","forceVertexBufferStrideMultiple4Bytes","typeByteLength","GetTypeByteLength","type","alignedByteStride","alignedSize","totalVertices","totalByteLength","totalLength","sourceData","Array","isArray","sourceDataAsFloat","Float32Array","DataView","byteLength","ArrayBuffer","alignedData","BYTE","Int8Array","UNSIGNED_BYTE","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","INT","Int32Array","UNSIGNED_INT","numComponents","getSize","sourceOffset","i","j","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","FLOAT","getFloat32","getIsInstanced","instanceDivisor","_label"],"sources":["../../../../dev/core/src/Buffers/buffer.align.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { DataBuffer } from \"./dataBuffer\";\r\nimport { Buffer, VertexBuffer } from \"./buffer\";\r\n\r\nconst isLittleEndian = (() => {\r\n    const array = new Uint8Array(4);\r\n    const view = new Uint32Array(array.buffer);\r\n\r\n    return !!((view[0] = 1) & array[0]);\r\n})();\r\n\r\ndeclare module \"./buffer\" {\r\n    export interface VertexBuffer {\r\n        /**\r\n         * Gets the effective byte stride, that is the byte stride of the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.byteStride if a new buffer must be created under the hood because of the forceVertexBufferStrideMultiple4Bytes engine flag.\r\n         */\r\n        effectiveByteStride: number;\r\n\r\n        /**\r\n         * Gets the effective byte offset, that is the byte offset of the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.byteOffset if a new buffer must be created under the hood because of the forceVertexBufferStrideMultiple4Bytes engine flag.\r\n         */\r\n        effectiveByteOffset: number;\r\n\r\n        /**\r\n         * Gets the effective buffer, that is the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.getBuffer() if a new buffer must be created under the hood because of the forceVertexBufferStrideMultiple4Bytes engine flag.\r\n         */\r\n        effectiveBuffer: Nullable<DataBuffer>;\r\n\r\n        /** @internal */\r\n        _alignBuffer(): void;\r\n\r\n        /** @internal */\r\n        _alignedBuffer?: Buffer;\r\n    }\r\n}\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteStride\", {\r\n    get: function (this: VertexBuffer) {\r\n        return (this._alignedBuffer && this._alignedBuffer.byteStride) || this.byteStride;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteOffset\", {\r\n    get: function (this: VertexBuffer) {\r\n        return this._alignedBuffer ? 0 : this.byteOffset;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveBuffer\", {\r\n    get: function (this: VertexBuffer) {\r\n        return (this._alignedBuffer && this._alignedBuffer.getBuffer()) || this._buffer.getBuffer();\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nVertexBuffer.prototype._rebuild = function (): void {\r\n    this._buffer?._rebuild();\r\n    this._alignedBuffer?._rebuild();\r\n};\r\n\r\nVertexBuffer.prototype.dispose = function (): void {\r\n    if (this._ownsBuffer) {\r\n        this._buffer.dispose();\r\n    }\r\n\r\n    this._alignedBuffer?.dispose();\r\n    this._alignedBuffer = undefined;\r\n\r\n    this._isDisposed = true;\r\n};\r\n\r\nVertexBuffer.prototype._alignBuffer = function (): void {\r\n    const data = this._buffer.getData();\r\n\r\n    if (!this.engine._features.forceVertexBufferStrideMultiple4Bytes || this.byteStride % 4 === 0 || !data) {\r\n        return;\r\n    }\r\n\r\n    const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\r\n    const alignedByteStride = (this.byteStride + 3) & ~3;\r\n    const alignedSize = alignedByteStride / typeByteLength;\r\n    const totalVertices = this.totalVertices;\r\n    const totalByteLength = totalVertices * alignedByteStride;\r\n    const totalLength = totalByteLength / typeByteLength;\r\n\r\n    let sourceData: DataView;\r\n\r\n    if (Array.isArray(data)) {\r\n        const sourceDataAsFloat = new Float32Array(data);\r\n        sourceData = new DataView(sourceDataAsFloat.buffer, sourceDataAsFloat.byteOffset, sourceDataAsFloat.byteLength);\r\n    } else if (data instanceof ArrayBuffer) {\r\n        sourceData = new DataView(data, 0, data.byteLength);\r\n    } else {\r\n        sourceData = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    }\r\n\r\n    let alignedData: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;\r\n\r\n    if (this.type === VertexBuffer.BYTE) {\r\n        alignedData = new Int8Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_BYTE) {\r\n        alignedData = new Uint8Array(totalLength);\r\n    } else if (this.type === VertexBuffer.SHORT) {\r\n        alignedData = new Int16Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_SHORT) {\r\n        alignedData = new Uint16Array(totalLength);\r\n    } else if (this.type === VertexBuffer.INT) {\r\n        alignedData = new Int32Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_INT) {\r\n        alignedData = new Uint32Array(totalLength);\r\n    } else {\r\n        alignedData = new Float32Array(totalLength);\r\n    }\r\n\r\n    const numComponents = this.getSize();\r\n\r\n    let sourceOffset = this.byteOffset;\r\n\r\n    for (let i = 0; i < totalVertices; ++i) {\r\n        for (let j = 0; j < numComponents; ++j) {\r\n            switch (this.type) {\r\n                case VertexBuffer.BYTE:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt8(sourceOffset + j);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_BYTE:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint8(sourceOffset + j);\r\n                    break;\r\n                case VertexBuffer.SHORT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt16(sourceOffset + j * 2, isLittleEndian);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_SHORT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint16(sourceOffset + j * 2, isLittleEndian);\r\n                    break;\r\n                case VertexBuffer.INT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt32(sourceOffset + j * 4, isLittleEndian);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_INT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint32(sourceOffset + j * 4, isLittleEndian);\r\n                    break;\r\n                case VertexBuffer.FLOAT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getFloat32(sourceOffset + j * 4, isLittleEndian);\r\n                    break;\r\n            }\r\n        }\r\n        sourceOffset += this.byteStride;\r\n    }\r\n\r\n    this._alignedBuffer?.dispose();\r\n    this._alignedBuffer = new Buffer(\r\n        this.engine,\r\n        alignedData,\r\n        false,\r\n        alignedByteStride,\r\n        false,\r\n        this.getIsInstanced(),\r\n        true,\r\n        this.instanceDivisor,\r\n        (this._label ?? \"VertexBuffer\") + \"_aligned\"\r\n    );\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}