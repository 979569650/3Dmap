{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Measure } from \"../../measure.js\";\nimport { Container } from \"../container.js\";\nimport { ValueAndUnit } from \"../../valueAndUnit.js\";\nimport { Control } from \"../control.js\";\n/**\n * Class used to hold a the container for ScrollViewer\n * @internal\n */\nexport class _ScrollViewerWindow extends Container {\n  get freezeControls() {\n    return this._freezeControls;\n  }\n  set freezeControls(value) {\n    if (this._freezeControls === value) {\n      return;\n    }\n    if (!value) {\n      this._restoreMeasures();\n    }\n    // trigger a full normal layout calculation to be sure all children have their measures up to date\n    this._freezeControls = false;\n    const textureSize = this.host.getSize();\n    const renderWidth = textureSize.width;\n    const renderHeight = textureSize.height;\n    const context = this.host.getContext();\n    const measure = new Measure(0, 0, renderWidth, renderHeight);\n    this.host._numLayoutCalls = 0;\n    this.host._rootContainer._layout(measure, context);\n    // in freeze mode, prepare children measures accordingly\n    if (value) {\n      this._updateMeasures();\n      if (this._useBuckets()) {\n        this._makeBuckets();\n      }\n    }\n    this._freezeControls = value;\n    this.host.markAsDirty(); // redraw with the (new) current settings\n  }\n\n  get bucketWidth() {\n    return this._bucketWidth;\n  }\n  get bucketHeight() {\n    return this._bucketHeight;\n  }\n  setBucketSizes(width, height) {\n    this._bucketWidth = width;\n    this._bucketHeight = height;\n    if (this._useBuckets()) {\n      if (this._freezeControls) {\n        this._makeBuckets();\n      }\n    } else {\n      this._buckets = {};\n    }\n  }\n  _useBuckets() {\n    return this._bucketWidth > 0 && this._bucketHeight > 0;\n  }\n  _makeBuckets() {\n    this._buckets = {};\n    this._bucketLen = Math.ceil(this.widthInPixels / this._bucketWidth);\n    this._dispatchInBuckets(this._children);\n    this._oldLeft = null;\n    this._oldTop = null;\n  }\n  _dispatchInBuckets(children) {\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i];\n      const bStartX = Math.max(0, Math.floor((child._customData._origLeft - this._customData.origLeft) / this._bucketWidth)),\n        bEndX = Math.floor((child._customData._origLeft - this._customData.origLeft + child._currentMeasure.width - 1) / this._bucketWidth),\n        bEndY = Math.floor((child._customData._origTop - this._customData.origTop + child._currentMeasure.height - 1) / this._bucketHeight);\n      let bStartY = Math.max(0, Math.floor((child._customData._origTop - this._customData.origTop) / this._bucketHeight));\n      while (bStartY <= bEndY) {\n        for (let x = bStartX; x <= bEndX; ++x) {\n          const bucket = bStartY * this._bucketLen + x;\n          let lstc = this._buckets[bucket];\n          if (!lstc) {\n            lstc = [];\n            this._buckets[bucket] = lstc;\n          }\n          lstc.push(child);\n        }\n        bStartY++;\n      }\n      if (child instanceof Container && child._children.length > 0) {\n        this._dispatchInBuckets(child._children);\n      }\n    }\n  }\n  // reset left and top measures for the window and all its children\n  _updateMeasures() {\n    const left = this.leftInPixels | 0,\n      top = this.topInPixels | 0;\n    this._measureForChildren.left -= left;\n    this._measureForChildren.top -= top;\n    this._currentMeasure.left -= left;\n    this._currentMeasure.top -= top;\n    this._customData.origLeftForChildren = this._measureForChildren.left;\n    this._customData.origTopForChildren = this._measureForChildren.top;\n    this._customData.origLeft = this._currentMeasure.left;\n    this._customData.origTop = this._currentMeasure.top;\n    this._updateChildrenMeasures(this._children, left, top);\n  }\n  _updateChildrenMeasures(children, left, top) {\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i];\n      child._currentMeasure.left -= left;\n      child._currentMeasure.top -= top;\n      child._customData._origLeft = child._currentMeasure.left; // save the original left and top values for each child\n      child._customData._origTop = child._currentMeasure.top;\n      if (child instanceof Container && child._children.length > 0) {\n        this._updateChildrenMeasures(child._children, left, top);\n      }\n    }\n  }\n  _restoreMeasures() {\n    const left = this.leftInPixels | 0,\n      top = this.topInPixels | 0;\n    this._measureForChildren.left = this._customData.origLeftForChildren + left;\n    this._measureForChildren.top = this._customData.origTopForChildren + top;\n    this._currentMeasure.left = this._customData.origLeft + left;\n    this._currentMeasure.top = this._customData.origTop + top;\n  }\n  /**\n   * Creates a new ScrollViewerWindow\n   * @param name of ScrollViewerWindow\n   */\n  constructor(name) {\n    super(name);\n    this._freezeControls = false;\n    this._bucketWidth = 0;\n    this._bucketHeight = 0;\n    this._buckets = {};\n  }\n  _getTypeName() {\n    return \"ScrollViewerWindow\";\n  }\n  /**\n   * @internal\n   */\n  _additionalProcessing(parentMeasure, context) {\n    super._additionalProcessing(parentMeasure, context);\n    this._parentMeasure = parentMeasure;\n    this._measureForChildren.left = this._currentMeasure.left;\n    this._measureForChildren.top = this._currentMeasure.top;\n    this._measureForChildren.width = parentMeasure.width;\n    this._measureForChildren.height = parentMeasure.height;\n  }\n  /**\n   * @internal\n   */\n  _layout(parentMeasure, context) {\n    if (this._freezeControls) {\n      this.invalidateRect(); // will trigger a redraw of the window\n      return false;\n    }\n    return super._layout(parentMeasure, context);\n  }\n  _scrollChildren(children, left, top) {\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i];\n      child._currentMeasure.left = child._customData._origLeft + left;\n      child._currentMeasure.top = child._customData._origTop + top;\n      child._isClipped = false; // clipping will be handled by _draw and the call to _intersectsRect()\n      if (child instanceof Container && child._children.length > 0) {\n        this._scrollChildren(child._children, left, top);\n      }\n    }\n  }\n  _scrollChildrenWithBuckets(left, top, scrollLeft, scrollTop) {\n    const bStartX = Math.max(0, Math.floor(-left / this._bucketWidth)),\n      bEndX = Math.floor((-left + this._parentMeasure.width - 1) / this._bucketWidth),\n      bEndY = Math.floor((-top + this._parentMeasure.height - 1) / this._bucketHeight);\n    let bStartY = Math.max(0, Math.floor(-top / this._bucketHeight));\n    while (bStartY <= bEndY) {\n      for (let x = bStartX; x <= bEndX; ++x) {\n        const bucket = bStartY * this._bucketLen + x,\n          lstc = this._buckets[bucket];\n        if (lstc) {\n          for (let i = 0; i < lstc.length; ++i) {\n            const child = lstc[i];\n            child._currentMeasure.left = child._customData._origLeft + scrollLeft;\n            child._currentMeasure.top = child._customData._origTop + scrollTop;\n            child._isClipped = false; // clipping will be handled by _draw and the call to _intersectsRect()\n          }\n        }\n      }\n\n      bStartY++;\n    }\n  }\n  /**\n   * @internal\n   */\n  _draw(context, invalidatedRectangle) {\n    if (!this._freezeControls) {\n      super._draw(context, invalidatedRectangle);\n      return;\n    }\n    this._localDraw(context);\n    if (this.clipChildren) {\n      this._clipForChildren(context);\n    }\n    const left = this.leftInPixels | 0,\n      top = this.topInPixels | 0;\n    if (this._useBuckets()) {\n      if (this._oldLeft !== null && this._oldTop !== null) {\n        this._scrollChildrenWithBuckets(this._oldLeft, this._oldTop, left, top);\n        this._scrollChildrenWithBuckets(left, top, left, top);\n      } else {\n        this._scrollChildren(this._children, left, top);\n      }\n    } else {\n      this._scrollChildren(this._children, left, top);\n    }\n    this._oldLeft = left;\n    this._oldTop = top;\n    for (const child of this._children) {\n      if (!child._intersectsRect(this._parentMeasure)) {\n        continue;\n      }\n      child._render(context, this._parentMeasure);\n    }\n  }\n  _postMeasure() {\n    if (this._freezeControls) {\n      super._postMeasure();\n      return;\n    }\n    let maxWidth = this.parentClientWidth;\n    let maxHeight = this.parentClientHeight;\n    for (const child of this.children) {\n      if (!child.isVisible || child.notRenderable) {\n        continue;\n      }\n      if (child.horizontalAlignment === Control.HORIZONTAL_ALIGNMENT_CENTER) {\n        child._offsetLeft(this._currentMeasure.left - child._currentMeasure.left);\n      }\n      if (child.verticalAlignment === Control.VERTICAL_ALIGNMENT_CENTER) {\n        child._offsetTop(this._currentMeasure.top - child._currentMeasure.top);\n      }\n      maxWidth = Math.max(maxWidth, child._currentMeasure.left - this._currentMeasure.left + child._currentMeasure.width + child.paddingRightInPixels);\n      maxHeight = Math.max(maxHeight, child._currentMeasure.top - this._currentMeasure.top + child._currentMeasure.height + child.paddingBottomInPixels);\n    }\n    if (this._currentMeasure.width !== maxWidth) {\n      this._width.updateInPlace(maxWidth, ValueAndUnit.UNITMODE_PIXEL);\n      this._currentMeasure.width = maxWidth;\n      this._rebuildLayout = true;\n      this._isDirty = true;\n    }\n    if (this._currentMeasure.height !== maxHeight) {\n      this._height.updateInPlace(maxHeight, ValueAndUnit.UNITMODE_PIXEL);\n      this._currentMeasure.height = maxHeight;\n      this._rebuildLayout = true;\n      this._isDirty = true;\n    }\n    super._postMeasure();\n  }\n}","map":{"version":3,"names":["Measure","Container","ValueAndUnit","Control","_ScrollViewerWindow","freezeControls","_freezeControls","value","_restoreMeasures","textureSize","host","getSize","renderWidth","width","renderHeight","height","context","getContext","measure","_numLayoutCalls","_rootContainer","_layout","_updateMeasures","_useBuckets","_makeBuckets","markAsDirty","bucketWidth","_bucketWidth","bucketHeight","_bucketHeight","setBucketSizes","_buckets","_bucketLen","Math","ceil","widthInPixels","_dispatchInBuckets","_children","_oldLeft","_oldTop","children","i","length","child","bStartX","max","floor","_customData","_origLeft","origLeft","bEndX","_currentMeasure","bEndY","_origTop","origTop","bStartY","x","bucket","lstc","push","left","leftInPixels","top","topInPixels","_measureForChildren","origLeftForChildren","origTopForChildren","_updateChildrenMeasures","constructor","name","_getTypeName","_additionalProcessing","parentMeasure","_parentMeasure","invalidateRect","_scrollChildren","_isClipped","_scrollChildrenWithBuckets","scrollLeft","scrollTop","_draw","invalidatedRectangle","_localDraw","clipChildren","_clipForChildren","_intersectsRect","_render","_postMeasure","maxWidth","parentClientWidth","maxHeight","parentClientHeight","isVisible","notRenderable","horizontalAlignment","HORIZONTAL_ALIGNMENT_CENTER","_offsetLeft","verticalAlignment","VERTICAL_ALIGNMENT_CENTER","_offsetTop","paddingRightInPixels","paddingBottomInPixels","_width","updateInPlace","UNITMODE_PIXEL","_rebuildLayout","_isDirty","_height"],"sources":["../../../../../../dev/gui/src/2D/controls/scrollViewers/scrollViewerWindow.ts"],"sourcesContent":["import { Measure } from \"../../measure\";\r\nimport { Container } from \"../container\";\r\nimport { ValueAndUnit } from \"../../valueAndUnit\";\r\nimport { Control } from \"../control\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to hold a the container for ScrollViewer\r\n * @internal\r\n */\r\nexport class _ScrollViewerWindow extends Container {\r\n    public parentClientWidth: number;\r\n    public parentClientHeight: number;\r\n\r\n    private _freezeControls = false;\r\n    private _parentMeasure: Measure;\r\n    private _oldLeft: number | null;\r\n    private _oldTop: number | null;\r\n\r\n    public get freezeControls(): boolean {\r\n        return this._freezeControls;\r\n    }\r\n\r\n    public set freezeControls(value: boolean) {\r\n        if (this._freezeControls === value) {\r\n            return;\r\n        }\r\n\r\n        if (!value) {\r\n            this._restoreMeasures();\r\n        }\r\n\r\n        // trigger a full normal layout calculation to be sure all children have their measures up to date\r\n        this._freezeControls = false;\r\n\r\n        const textureSize = this.host.getSize();\r\n        const renderWidth = textureSize.width;\r\n        const renderHeight = textureSize.height;\r\n\r\n        const context = this.host.getContext();\r\n\r\n        const measure = new Measure(0, 0, renderWidth, renderHeight);\r\n\r\n        this.host._numLayoutCalls = 0;\r\n\r\n        this.host._rootContainer._layout(measure, context);\r\n\r\n        // in freeze mode, prepare children measures accordingly\r\n        if (value) {\r\n            this._updateMeasures();\r\n            if (this._useBuckets()) {\r\n                this._makeBuckets();\r\n            }\r\n        }\r\n\r\n        this._freezeControls = value;\r\n\r\n        this.host.markAsDirty(); // redraw with the (new) current settings\r\n    }\r\n\r\n    private _bucketWidth: number = 0;\r\n    private _bucketHeight: number = 0;\r\n    private _buckets: { [key: number]: Array<Control> } = {};\r\n    private _bucketLen: number;\r\n\r\n    public get bucketWidth(): number {\r\n        return this._bucketWidth;\r\n    }\r\n\r\n    public get bucketHeight(): number {\r\n        return this._bucketHeight;\r\n    }\r\n\r\n    public setBucketSizes(width: number, height: number): void {\r\n        this._bucketWidth = width;\r\n        this._bucketHeight = height;\r\n\r\n        if (this._useBuckets()) {\r\n            if (this._freezeControls) {\r\n                this._makeBuckets();\r\n            }\r\n        } else {\r\n            this._buckets = {};\r\n        }\r\n    }\r\n\r\n    private _useBuckets(): boolean {\r\n        return this._bucketWidth > 0 && this._bucketHeight > 0;\r\n    }\r\n\r\n    private _makeBuckets(): void {\r\n        this._buckets = {};\r\n        this._bucketLen = Math.ceil(this.widthInPixels / this._bucketWidth);\r\n        this._dispatchInBuckets(this._children);\r\n        this._oldLeft = null;\r\n        this._oldTop = null;\r\n    }\r\n\r\n    private _dispatchInBuckets(children: Control[]): void {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const child = children[i];\r\n\r\n            const bStartX = Math.max(0, Math.floor((child._customData._origLeft - this._customData.origLeft) / this._bucketWidth)),\r\n                bEndX = Math.floor((child._customData._origLeft - this._customData.origLeft + child._currentMeasure.width - 1) / this._bucketWidth),\r\n                bEndY = Math.floor((child._customData._origTop - this._customData.origTop + child._currentMeasure.height - 1) / this._bucketHeight);\r\n            let bStartY = Math.max(0, Math.floor((child._customData._origTop - this._customData.origTop) / this._bucketHeight));\r\n\r\n            while (bStartY <= bEndY) {\r\n                for (let x = bStartX; x <= bEndX; ++x) {\r\n                    const bucket = bStartY * this._bucketLen + x;\r\n                    let lstc = this._buckets[bucket];\r\n\r\n                    if (!lstc) {\r\n                        lstc = [];\r\n                        this._buckets[bucket] = lstc;\r\n                    }\r\n\r\n                    lstc.push(child);\r\n                }\r\n                bStartY++;\r\n            }\r\n\r\n            if (child instanceof Container && child._children.length > 0) {\r\n                this._dispatchInBuckets(child._children);\r\n            }\r\n        }\r\n    }\r\n\r\n    // reset left and top measures for the window and all its children\r\n    private _updateMeasures(): void {\r\n        const left = this.leftInPixels | 0,\r\n            top = this.topInPixels | 0;\r\n\r\n        this._measureForChildren.left -= left;\r\n        this._measureForChildren.top -= top;\r\n        this._currentMeasure.left -= left;\r\n        this._currentMeasure.top -= top;\r\n\r\n        this._customData.origLeftForChildren = this._measureForChildren.left;\r\n        this._customData.origTopForChildren = this._measureForChildren.top;\r\n        this._customData.origLeft = this._currentMeasure.left;\r\n        this._customData.origTop = this._currentMeasure.top;\r\n\r\n        this._updateChildrenMeasures(this._children, left, top);\r\n    }\r\n\r\n    private _updateChildrenMeasures(children: Control[], left: number, top: number): void {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const child = children[i];\r\n\r\n            child._currentMeasure.left -= left;\r\n            child._currentMeasure.top -= top;\r\n\r\n            child._customData._origLeft = child._currentMeasure.left; // save the original left and top values for each child\r\n            child._customData._origTop = child._currentMeasure.top;\r\n\r\n            if (child instanceof Container && child._children.length > 0) {\r\n                this._updateChildrenMeasures(child._children, left, top);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _restoreMeasures(): void {\r\n        const left = this.leftInPixels | 0,\r\n            top = this.topInPixels | 0;\r\n\r\n        this._measureForChildren.left = this._customData.origLeftForChildren + left;\r\n        this._measureForChildren.top = this._customData.origTopForChildren + top;\r\n        this._currentMeasure.left = this._customData.origLeft + left;\r\n        this._currentMeasure.top = this._customData.origTop + top;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ScrollViewerWindow\r\n     * @param name of ScrollViewerWindow\r\n     */\r\n    constructor(name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"ScrollViewerWindow\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._parentMeasure = parentMeasure;\r\n\r\n        this._measureForChildren.left = this._currentMeasure.left;\r\n        this._measureForChildren.top = this._currentMeasure.top;\r\n\r\n        this._measureForChildren.width = parentMeasure.width;\r\n        this._measureForChildren.height = parentMeasure.height;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _layout(parentMeasure: Measure, context: ICanvasRenderingContext): boolean {\r\n        if (this._freezeControls) {\r\n            this.invalidateRect(); // will trigger a redraw of the window\r\n            return false;\r\n        }\r\n\r\n        return super._layout(parentMeasure, context);\r\n    }\r\n\r\n    private _scrollChildren(children: Control[], left: number, top: number): void {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const child = children[i];\r\n\r\n            child._currentMeasure.left = child._customData._origLeft + left;\r\n            child._currentMeasure.top = child._customData._origTop + top;\r\n            child._isClipped = false; // clipping will be handled by _draw and the call to _intersectsRect()\r\n\r\n            if (child instanceof Container && child._children.length > 0) {\r\n                this._scrollChildren(child._children, left, top);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _scrollChildrenWithBuckets(left: number, top: number, scrollLeft: number, scrollTop: number): void {\r\n        const bStartX = Math.max(0, Math.floor(-left / this._bucketWidth)),\r\n            bEndX = Math.floor((-left + this._parentMeasure.width - 1) / this._bucketWidth),\r\n            bEndY = Math.floor((-top + this._parentMeasure.height - 1) / this._bucketHeight);\r\n        let bStartY = Math.max(0, Math.floor(-top / this._bucketHeight));\r\n\r\n        while (bStartY <= bEndY) {\r\n            for (let x = bStartX; x <= bEndX; ++x) {\r\n                const bucket = bStartY * this._bucketLen + x,\r\n                    lstc = this._buckets[bucket];\r\n\r\n                if (lstc) {\r\n                    for (let i = 0; i < lstc.length; ++i) {\r\n                        const child = lstc[i];\r\n                        child._currentMeasure.left = child._customData._origLeft + scrollLeft;\r\n                        child._currentMeasure.top = child._customData._origTop + scrollTop;\r\n                        child._isClipped = false; // clipping will be handled by _draw and the call to _intersectsRect()\r\n                    }\r\n                }\r\n            }\r\n            bStartY++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(context: ICanvasRenderingContext, invalidatedRectangle?: Measure): void {\r\n        if (!this._freezeControls) {\r\n            super._draw(context, invalidatedRectangle);\r\n            return;\r\n        }\r\n\r\n        this._localDraw(context);\r\n\r\n        if (this.clipChildren) {\r\n            this._clipForChildren(context);\r\n        }\r\n\r\n        const left = this.leftInPixels | 0,\r\n            top = this.topInPixels | 0;\r\n\r\n        if (this._useBuckets()) {\r\n            if (this._oldLeft !== null && this._oldTop !== null) {\r\n                this._scrollChildrenWithBuckets(this._oldLeft, this._oldTop, left, top);\r\n                this._scrollChildrenWithBuckets(left, top, left, top);\r\n            } else {\r\n                this._scrollChildren(this._children, left, top);\r\n            }\r\n        } else {\r\n            this._scrollChildren(this._children, left, top);\r\n        }\r\n\r\n        this._oldLeft = left;\r\n        this._oldTop = top;\r\n\r\n        for (const child of this._children) {\r\n            if (!child._intersectsRect(this._parentMeasure)) {\r\n                continue;\r\n            }\r\n            child._render(context, this._parentMeasure);\r\n        }\r\n    }\r\n\r\n    protected _postMeasure(): void {\r\n        if (this._freezeControls) {\r\n            super._postMeasure();\r\n            return;\r\n        }\r\n\r\n        let maxWidth = this.parentClientWidth;\r\n        let maxHeight = this.parentClientHeight;\r\n        for (const child of this.children) {\r\n            if (!child.isVisible || child.notRenderable) {\r\n                continue;\r\n            }\r\n\r\n            if (child.horizontalAlignment === Control.HORIZONTAL_ALIGNMENT_CENTER) {\r\n                child._offsetLeft(this._currentMeasure.left - child._currentMeasure.left);\r\n            }\r\n\r\n            if (child.verticalAlignment === Control.VERTICAL_ALIGNMENT_CENTER) {\r\n                child._offsetTop(this._currentMeasure.top - child._currentMeasure.top);\r\n            }\r\n\r\n            maxWidth = Math.max(maxWidth, child._currentMeasure.left - this._currentMeasure.left + child._currentMeasure.width + child.paddingRightInPixels);\r\n            maxHeight = Math.max(maxHeight, child._currentMeasure.top - this._currentMeasure.top + child._currentMeasure.height + child.paddingBottomInPixels);\r\n        }\r\n\r\n        if (this._currentMeasure.width !== maxWidth) {\r\n            this._width.updateInPlace(maxWidth, ValueAndUnit.UNITMODE_PIXEL);\r\n            this._currentMeasure.width = maxWidth;\r\n            this._rebuildLayout = true;\r\n            this._isDirty = true;\r\n        }\r\n\r\n        if (this._currentMeasure.height !== maxHeight) {\r\n            this._height.updateInPlace(maxHeight, ValueAndUnit.UNITMODE_PIXEL);\r\n            this._currentMeasure.height = maxHeight;\r\n            this._rebuildLayout = true;\r\n            this._isDirty = true;\r\n        }\r\n\r\n        super._postMeasure();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}