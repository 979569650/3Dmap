{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { Buffer, VertexBuffer } from \"../Buffers/buffer.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport \"../Engines/Extensions/engine.dynamicBuffer.js\";\nimport \"../Shaders/sprites.fragment.js\";\nimport \"../Shaders/sprites.vertex.js\";\n/**\n * Class used to render sprites.\n *\n * It can be used either to render Sprites or ThinSprites with ThinEngine only.\n */\nexport class SpriteRenderer {\n  /**\n   * Gets the capacity of the manager\n   */\n  get capacity() {\n    return this._capacity;\n  }\n  /**\n   * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering\n   * Note that pixel perfect mode is not supported in WebGL 1\n   */\n  get pixelPerfect() {\n    return this._pixelPerfect;\n  }\n  set pixelPerfect(value) {\n    if (this._pixelPerfect === value) {\n      return;\n    }\n    this._pixelPerfect = value;\n    this._createEffects();\n  }\n  /**\n   * Creates a new sprite Renderer\n   * @param engine defines the engine the renderer works with\n   * @param capacity defines the maximum allowed number of sprites\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\n   * @param scene defines the hosting scene\n   */\n  constructor(engine, capacity, epsilon = 0.01, scene = null) {\n    /**\n     * Blend mode use to render the particle, it can be any of\n     * the static undefined properties provided in this class.\n     * Default value is 2\n     */\n    this.blendMode = 2;\n    /**\n     * Gets or sets a boolean indicating if alpha mode is automatically\n     * reset.\n     */\n    this.autoResetAlpha = true;\n    /**\n     * Disables writing to the depth buffer when rendering the sprites.\n     * It can be handy to disable depth writing when using textures without alpha channel\n     * and setting some specific blend modes.\n     */\n    this.disableDepthWrite = false;\n    /**\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\n     */\n    this.fogEnabled = true;\n    this._pixelPerfect = false;\n    this._useVAO = false;\n    this._useInstancing = false;\n    this._vertexBuffers = {};\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._engine = engine;\n    this._useInstancing = engine.getCaps().instancedArrays && engine._features.supportSpriteInstancing;\n    this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\n    this._scene = scene;\n    if (!this._useInstancing) {\n      this._buildIndexBuffer();\n    }\n    // VBO\n    // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\n    // 16 when using instances\n    this._vertexBufferSize = this._useInstancing ? 16 : 18;\n    this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n    this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n    const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\n    const options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\n    let offset = 6;\n    let offsets;\n    if (this._useInstancing) {\n      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\n    } else {\n      offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\n      offset += 2;\n    }\n    const inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\n    const cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\n    const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    this._vertexBuffers[\"options\"] = options;\n    this._vertexBuffers[\"offsets\"] = offsets;\n    this._vertexBuffers[\"inverts\"] = inverts;\n    this._vertexBuffers[\"cellInfo\"] = cellInfo;\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    this._createEffects();\n  }\n  _createEffects() {\n    var _a, _b, _c, _d;\n    (_a = this._drawWrapperBase) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this._drawWrapperFog) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this._drawWrapperDepth) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this._drawWrapperFogDepth) === null || _d === void 0 ? void 0 : _d.dispose();\n    this._drawWrapperBase = new DrawWrapper(this._engine);\n    this._drawWrapperFog = new DrawWrapper(this._engine);\n    this._drawWrapperDepth = new DrawWrapper(this._engine, false);\n    this._drawWrapperFogDepth = new DrawWrapper(this._engine, false);\n    if (this._drawWrapperBase.drawContext) {\n      this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;\n    }\n    if (this._drawWrapperFog.drawContext) {\n      this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;\n    }\n    if (this._drawWrapperDepth.drawContext) {\n      this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;\n    }\n    if (this._drawWrapperFogDepth.drawContext) {\n      this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;\n    }\n    const defines = this._pixelPerfect ? \"#define PIXEL_PERFECT\\n\" : \"\";\n    this._drawWrapperBase.effect = this._engine.createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], defines);\n    this._drawWrapperDepth.effect = this._drawWrapperBase.effect;\n    this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;\n    if (this._scene) {\n      this._drawWrapperFog.effect = this._scene.getEngine().createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], defines + \"#define FOG\");\n      this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;\n      this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;\n    }\n  }\n  /**\n   * Render all child sprites\n   * @param sprites defines the list of sprites to render\n   * @param deltaTime defines the time since last frame\n   * @param viewMatrix defines the viewMatrix to use to render the sprites\n   * @param projectionMatrix defines the projectionMatrix to use to render the sprites\n   * @param customSpriteUpdate defines a custom function to update the sprites data before they render\n   */\n  render(sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate = null) {\n    if (!this.texture || !this.texture.isReady() || !sprites.length) {\n      return;\n    }\n    let drawWrapper = this._drawWrapperBase;\n    let drawWrapperDepth = this._drawWrapperDepth;\n    let shouldRenderFog = false;\n    if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\n      drawWrapper = this._drawWrapperFog;\n      drawWrapperDepth = this._drawWrapperFogDepth;\n      shouldRenderFog = true;\n    }\n    const effect = drawWrapper.effect;\n    // Check\n    if (!effect.isReady()) {\n      return;\n    }\n    const engine = this._engine;\n    const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\n    const baseSize = this.texture.getBaseSize();\n    // Sprites\n    const max = Math.min(this._capacity, sprites.length);\n    let offset = 0;\n    let noSprite = true;\n    for (let index = 0; index < max; index++) {\n      const sprite = sprites[index];\n      if (!sprite || !sprite.isVisible) {\n        continue;\n      }\n      noSprite = false;\n      sprite._animate(deltaTime);\n      this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n      if (!this._useInstancing) {\n        this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n        this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n        this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n      }\n    }\n    if (noSprite) {\n      return;\n    }\n    this._buffer.update(this._vertexData);\n    const culling = !!engine.depthCullingState.cull;\n    const zOffset = engine.depthCullingState.zOffset;\n    const zOffsetUnits = engine.depthCullingState.zOffsetUnits;\n    engine.setState(culling, zOffset, false, false, undefined, undefined, zOffsetUnits);\n    // Render\n    engine.enableEffect(drawWrapper);\n    effect.setTexture(\"diffuseSampler\", this.texture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", projectionMatrix);\n    // Scene Info\n    if (shouldRenderFog) {\n      const scene = this._scene;\n      // Fog\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n      effect.setColor3(\"vFogColor\", scene.fogColor);\n    }\n    if (this._useVAO) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n      engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    }\n    // Draw order\n    engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? 518 : 515;\n    if (!this.disableDepthWrite) {\n      effect.setBool(\"alphaTest\", true);\n      engine.setColorWrite(false);\n      engine.enableEffect(drawWrapperDepth);\n      if (this._useInstancing) {\n        engine.drawArraysType(7, 0, 4, offset);\n      } else {\n        engine.drawElementsType(0, 0, offset / 4 * 6);\n      }\n      engine.enableEffect(drawWrapper);\n      engine.setColorWrite(true);\n      effect.setBool(\"alphaTest\", false);\n    }\n    engine.setAlphaMode(this.blendMode);\n    if (this._useInstancing) {\n      engine.drawArraysType(7, 0, 4, offset);\n    } else {\n      engine.drawElementsType(0, 0, offset / 4 * 6);\n    }\n    if (this.autoResetAlpha) {\n      engine.setAlphaMode(0);\n    }\n    // Restore Right Handed\n    if (useRightHandedSystem) {\n      this._scene.getEngine().setState(culling, zOffset, false, true, undefined, undefined, zOffsetUnits);\n    }\n    engine.unbindInstanceAttributes();\n  }\n  _appendSpriteVertex(index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {\n    let arrayOffset = index * this._vertexBufferSize;\n    if (offsetX === 0) {\n      offsetX = this._epsilon;\n    } else if (offsetX === 1) {\n      offsetX = 1 - this._epsilon;\n    }\n    if (offsetY === 0) {\n      offsetY = this._epsilon;\n    } else if (offsetY === 1) {\n      offsetY = 1 - this._epsilon;\n    }\n    if (customSpriteUpdate) {\n      customSpriteUpdate(sprite, baseSize);\n    } else {\n      if (!sprite.cellIndex) {\n        sprite.cellIndex = 0;\n      }\n      const rowSize = baseSize.width / this.cellWidth;\n      const offset = sprite.cellIndex / rowSize >> 0;\n      sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;\n      sprite._yOffset = offset * this.cellHeight / baseSize.height;\n      sprite._xSize = this.cellWidth;\n      sprite._ySize = this.cellHeight;\n    }\n    // Positions\n    this._vertexData[arrayOffset] = sprite.position.x;\n    this._vertexData[arrayOffset + 1] = sprite.position.y;\n    this._vertexData[arrayOffset + 2] = sprite.position.z;\n    this._vertexData[arrayOffset + 3] = sprite.angle;\n    // Options\n    this._vertexData[arrayOffset + 4] = sprite.width;\n    this._vertexData[arrayOffset + 5] = sprite.height;\n    if (!this._useInstancing) {\n      this._vertexData[arrayOffset + 6] = offsetX;\n      this._vertexData[arrayOffset + 7] = offsetY;\n    } else {\n      arrayOffset -= 2;\n    }\n    // Inverts according to Right Handed\n    if (useRightHandedSystem) {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\n    } else {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\n    }\n    this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\n    this._vertexData[arrayOffset + 10] = sprite._xOffset;\n    this._vertexData[arrayOffset + 11] = sprite._yOffset;\n    this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\n    this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;\n    // Color\n    this._vertexData[arrayOffset + 14] = sprite.color.r;\n    this._vertexData[arrayOffset + 15] = sprite.color.g;\n    this._vertexData[arrayOffset + 16] = sprite.color.b;\n    this._vertexData[arrayOffset + 17] = sprite.color.a;\n  }\n  _buildIndexBuffer() {\n    const indices = [];\n    let index = 0;\n    for (let count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      index += 4;\n    }\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  }\n  /**\n   * Rebuilds the renderer (after a context lost, for eg)\n   */\n  rebuild() {\n    var _a;\n    if (this._indexBuffer) {\n      this._buildIndexBuffer();\n    }\n    if (this._useVAO) {\n      this._vertexArrayObject = undefined;\n    }\n    this._buffer._rebuild();\n    for (const key in this._vertexBuffers) {\n      const vertexBuffer = this._vertexBuffers[key];\n      vertexBuffer._rebuild();\n    }\n    (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._buffer) {\n      this._buffer.dispose();\n      this._buffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n    this._drawWrapperBase.dispose();\n    this._drawWrapperFog.dispose();\n    this._drawWrapperDepth.dispose();\n    this._drawWrapperFogDepth.dispose();\n  }\n}","map":{"version":3,"names":["Buffer","VertexBuffer","DrawWrapper","SpriteRenderer","capacity","_capacity","pixelPerfect","_pixelPerfect","value","_createEffects","constructor","engine","epsilon","scene","blendMode","autoResetAlpha","disableDepthWrite","fogEnabled","_useVAO","_useInstancing","_vertexBuffers","_epsilon","_engine","getCaps","instancedArrays","_features","supportSpriteInstancing","vertexArrayObject","disableVertexArrayObjects","_scene","_buildIndexBuffer","_vertexBufferSize","_vertexData","Float32Array","_buffer","positions","createVertexBuffer","PositionKind","options","offset","offsets","spriteData","_spriteBuffer","inverts","cellInfo","colors","ColorKind","_a","_drawWrapperBase","dispose","_b","_drawWrapperFog","_c","_drawWrapperDepth","_d","_drawWrapperFogDepth","drawContext","useInstancing","defines","effect","createEffect","materialContext","getEngine","render","sprites","deltaTime","viewMatrix","projectionMatrix","customSpriteUpdate","texture","isReady","length","drawWrapper","drawWrapperDepth","shouldRenderFog","fogMode","useRightHandedSystem","baseSize","getBaseSize","max","Math","min","noSprite","index","sprite","isVisible","_animate","_appendSpriteVertex","update","culling","depthCullingState","cull","zOffset","zOffsetUnits","setState","undefined","enableEffect","setTexture","setMatrix","setFloat4","fogStart","fogEnd","fogDensity","setColor3","fogColor","_vertexArrayObject","recordVertexArrayObject","_indexBuffer","bindVertexArrayObject","bindBuffers","depthFunc","useReverseDepthBuffer","setBool","setColorWrite","drawArraysType","drawElementsType","setAlphaMode","unbindInstanceAttributes","offsetX","offsetY","arrayOffset","cellIndex","rowSize","width","cellWidth","_xOffset","_yOffset","cellHeight","height","_xSize","_ySize","position","x","y","z","angle","invertU","invertV","color","r","g","b","a","indices","count","push","createIndexBuffer","rebuild","_rebuild","key","vertexBuffer","_releaseBuffer","releaseVertexArrayObject"],"sources":["../../../../dev/core/src/Sprites/spriteRenderer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { IMatrixLike } from \"../Maths/math.like\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Buffer, VertexBuffer } from \"../Buffers/buffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { ThinSprite } from \"./thinSprite\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\n\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\n\r\nimport \"../Shaders/sprites.fragment\";\r\nimport \"../Shaders/sprites.vertex\";\r\n\r\n/**\r\n * Class used to render sprites.\r\n *\r\n * It can be used either to render Sprites or ThinSprites with ThinEngine only.\r\n */\r\nexport class SpriteRenderer {\r\n    /**\r\n     * Defines the texture of the spritesheet\r\n     */\r\n    public texture: Nullable<ThinTexture>;\r\n\r\n    /**\r\n     * Defines the default width of a cell in the spritesheet\r\n     */\r\n    public cellWidth: number;\r\n\r\n    /**\r\n     * Defines the default height of a cell in the spritesheet\r\n     */\r\n    public cellHeight: number;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static Constants.ALPHA_x properties provided in this class.\r\n     * Default value is Constants.ALPHA_COMBINE\r\n     */\r\n    public blendMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if alpha mode is automatically\r\n     * reset.\r\n     */\r\n    public autoResetAlpha = true;\r\n\r\n    /**\r\n     * Disables writing to the depth buffer when rendering the sprites.\r\n     * It can be handy to disable depth writing when using textures without alpha channel\r\n     * and setting some specific blend modes.\r\n     */\r\n    public disableDepthWrite: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\r\n     */\r\n    public fogEnabled = true;\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._capacity;\r\n    }\r\n\r\n    private _pixelPerfect = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering\r\n     * Note that pixel perfect mode is not supported in WebGL 1\r\n     */\r\n    public get pixelPerfect() {\r\n        return this._pixelPerfect;\r\n    }\r\n\r\n    public set pixelPerfect(value: boolean) {\r\n        if (this._pixelPerfect === value) {\r\n            return;\r\n        }\r\n\r\n        this._pixelPerfect = value;\r\n        this._createEffects();\r\n    }\r\n\r\n    private readonly _engine: ThinEngine;\r\n    private readonly _useVAO: boolean = false;\r\n    private readonly _useInstancing: boolean = false;\r\n    private readonly _scene: Nullable<Scene>;\r\n\r\n    private readonly _capacity: number;\r\n    private readonly _epsilon: number;\r\n\r\n    private _vertexBufferSize: number;\r\n    private _vertexData: Float32Array;\r\n    private _buffer: Buffer;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: DataBuffer;\r\n    private _drawWrapperBase: DrawWrapper;\r\n    private _drawWrapperFog: DrawWrapper;\r\n    private _drawWrapperDepth: DrawWrapper;\r\n    private _drawWrapperFogDepth: DrawWrapper;\r\n    private _vertexArrayObject: WebGLVertexArrayObject;\r\n\r\n    /**\r\n     * Creates a new sprite Renderer\r\n     * @param engine defines the engine the renderer works with\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(engine: ThinEngine, capacity: number, epsilon: number = 0.01, scene: Nullable<Scene> = null) {\r\n        this._capacity = capacity;\r\n        this._epsilon = epsilon;\r\n\r\n        this._engine = engine;\r\n        this._useInstancing = engine.getCaps().instancedArrays && engine._features.supportSpriteInstancing;\r\n        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\r\n        this._scene = scene;\r\n\r\n        if (!this._useInstancing) {\r\n            this._buildIndexBuffer();\r\n        }\r\n\r\n        // VBO\r\n        // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\r\n        // 16 when using instances\r\n        this._vertexBufferSize = this._useInstancing ? 16 : 18;\r\n        this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\r\n        this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\r\n\r\n        const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\r\n        const options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\r\n\r\n        let offset = 6;\r\n        let offsets: VertexBuffer;\r\n\r\n        if (this._useInstancing) {\r\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\r\n        } else {\r\n            offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n            offset += 2;\r\n        }\r\n\r\n        const inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n        const cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\r\n        const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        this._vertexBuffers[\"options\"] = options;\r\n        this._vertexBuffers[\"offsets\"] = offsets;\r\n        this._vertexBuffers[\"inverts\"] = inverts;\r\n        this._vertexBuffers[\"cellInfo\"] = cellInfo;\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n\r\n        this._createEffects();\r\n    }\r\n\r\n    private _createEffects() {\r\n        this._drawWrapperBase?.dispose();\r\n        this._drawWrapperFog?.dispose();\r\n        this._drawWrapperDepth?.dispose();\r\n        this._drawWrapperFogDepth?.dispose();\r\n\r\n        this._drawWrapperBase = new DrawWrapper(this._engine);\r\n        this._drawWrapperFog = new DrawWrapper(this._engine);\r\n        this._drawWrapperDepth = new DrawWrapper(this._engine, false);\r\n        this._drawWrapperFogDepth = new DrawWrapper(this._engine, false);\r\n\r\n        if (this._drawWrapperBase.drawContext) {\r\n            this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperFog.drawContext) {\r\n            this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperDepth.drawContext) {\r\n            this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperFogDepth.drawContext) {\r\n            this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n\r\n        const defines = this._pixelPerfect ? \"#define PIXEL_PERFECT\\n\" : \"\";\r\n\r\n        this._drawWrapperBase.effect = this._engine.createEffect(\r\n            \"sprites\",\r\n            [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n            [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"],\r\n            [\"diffuseSampler\"],\r\n            defines\r\n        );\r\n\r\n        this._drawWrapperDepth.effect = this._drawWrapperBase.effect;\r\n        this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;\r\n\r\n        if (this._scene) {\r\n            this._drawWrapperFog.effect = this._scene\r\n                .getEngine()\r\n                .createEffect(\r\n                    \"sprites\",\r\n                    [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n                    [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"],\r\n                    [\"diffuseSampler\"],\r\n                    defines + \"#define FOG\"\r\n                );\r\n            this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;\r\n            this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     * @param sprites defines the list of sprites to render\r\n     * @param deltaTime defines the time since last frame\r\n     * @param viewMatrix defines the viewMatrix to use to render the sprites\r\n     * @param projectionMatrix defines the projectionMatrix to use to render the sprites\r\n     * @param customSpriteUpdate defines a custom function to update the sprites data before they render\r\n     */\r\n    public render(\r\n        sprites: ThinSprite[],\r\n        deltaTime: number,\r\n        viewMatrix: IMatrixLike,\r\n        projectionMatrix: IMatrixLike,\r\n        customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void> = null\r\n    ): void {\r\n        if (!this.texture || !this.texture.isReady() || !sprites.length) {\r\n            return;\r\n        }\r\n\r\n        let drawWrapper = this._drawWrapperBase;\r\n        let drawWrapperDepth = this._drawWrapperDepth;\r\n        let shouldRenderFog = false;\r\n        if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\r\n            drawWrapper = this._drawWrapperFog;\r\n            drawWrapperDepth = this._drawWrapperFogDepth;\r\n            shouldRenderFog = true;\r\n        }\r\n\r\n        const effect = drawWrapper.effect!;\r\n\r\n        // Check\r\n        if (!effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\r\n        const baseSize = this.texture.getBaseSize();\r\n\r\n        // Sprites\r\n        const max = Math.min(this._capacity, sprites.length);\r\n\r\n        let offset = 0;\r\n        let noSprite = true;\r\n        for (let index = 0; index < max; index++) {\r\n            const sprite = sprites[index];\r\n            if (!sprite || !sprite.isVisible) {\r\n                continue;\r\n            }\r\n\r\n            noSprite = false;\r\n            sprite._animate(deltaTime);\r\n\r\n            this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            if (!this._useInstancing) {\r\n                this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            }\r\n        }\r\n\r\n        if (noSprite) {\r\n            return;\r\n        }\r\n\r\n        this._buffer.update(this._vertexData);\r\n\r\n        const culling = !!engine.depthCullingState.cull;\r\n        const zOffset = engine.depthCullingState.zOffset;\r\n        const zOffsetUnits = engine.depthCullingState.zOffsetUnits;\r\n\r\n        engine.setState(culling, zOffset, false, false, undefined, undefined, zOffsetUnits);\r\n\r\n        // Render\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        effect.setTexture(\"diffuseSampler\", this.texture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", projectionMatrix);\r\n\r\n        // Scene Info\r\n        if (shouldRenderFog) {\r\n            const scene = this._scene!;\r\n\r\n            // Fog\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            if (!this._vertexArrayObject) {\r\n                this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\r\n            }\r\n            engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\r\n        } else {\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n        }\r\n\r\n        // Draw order\r\n        engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? Constants.GEQUAL : Constants.LEQUAL;\r\n        if (!this.disableDepthWrite) {\r\n            effect.setBool(\"alphaTest\", true);\r\n            engine.setColorWrite(false);\r\n            engine.enableEffect(drawWrapperDepth);\r\n            if (this._useInstancing) {\r\n                engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, offset);\r\n            } else {\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, (offset / 4) * 6);\r\n            }\r\n            engine.enableEffect(drawWrapper);\r\n            engine.setColorWrite(true);\r\n            effect.setBool(\"alphaTest\", false);\r\n        }\r\n\r\n        engine.setAlphaMode(this.blendMode);\r\n        if (this._useInstancing) {\r\n            engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, offset);\r\n        } else {\r\n            engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, (offset / 4) * 6);\r\n        }\r\n\r\n        if (this.autoResetAlpha) {\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._scene!.getEngine().setState(culling, zOffset, false, true, undefined, undefined, zOffsetUnits);\r\n        }\r\n\r\n        engine.unbindInstanceAttributes();\r\n    }\r\n\r\n    private _appendSpriteVertex(\r\n        index: number,\r\n        sprite: ThinSprite,\r\n        offsetX: number,\r\n        offsetY: number,\r\n        baseSize: ISize,\r\n        useRightHandedSystem: boolean,\r\n        customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void>\r\n    ): void {\r\n        let arrayOffset = index * this._vertexBufferSize;\r\n\r\n        if (offsetX === 0) {\r\n            offsetX = this._epsilon;\r\n        } else if (offsetX === 1) {\r\n            offsetX = 1 - this._epsilon;\r\n        }\r\n\r\n        if (offsetY === 0) {\r\n            offsetY = this._epsilon;\r\n        } else if (offsetY === 1) {\r\n            offsetY = 1 - this._epsilon;\r\n        }\r\n\r\n        if (customSpriteUpdate) {\r\n            customSpriteUpdate(sprite, baseSize);\r\n        } else {\r\n            if (!sprite.cellIndex) {\r\n                sprite.cellIndex = 0;\r\n            }\r\n\r\n            const rowSize = baseSize.width / this.cellWidth;\r\n            const offset = (sprite.cellIndex / rowSize) >> 0;\r\n            sprite._xOffset = ((sprite.cellIndex - offset * rowSize) * this.cellWidth) / baseSize.width;\r\n            sprite._yOffset = (offset * this.cellHeight) / baseSize.height;\r\n            sprite._xSize = this.cellWidth;\r\n            sprite._ySize = this.cellHeight;\r\n        }\r\n\r\n        // Positions\r\n        this._vertexData[arrayOffset] = sprite.position.x;\r\n        this._vertexData[arrayOffset + 1] = sprite.position.y;\r\n        this._vertexData[arrayOffset + 2] = sprite.position.z;\r\n        this._vertexData[arrayOffset + 3] = sprite.angle;\r\n        // Options\r\n        this._vertexData[arrayOffset + 4] = sprite.width;\r\n        this._vertexData[arrayOffset + 5] = sprite.height;\r\n\r\n        if (!this._useInstancing) {\r\n            this._vertexData[arrayOffset + 6] = offsetX;\r\n            this._vertexData[arrayOffset + 7] = offsetY;\r\n        } else {\r\n            arrayOffset -= 2;\r\n        }\r\n\r\n        // Inverts according to Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\r\n        } else {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\r\n        }\r\n\r\n        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\r\n\r\n        this._vertexData[arrayOffset + 10] = sprite._xOffset;\r\n        this._vertexData[arrayOffset + 11] = sprite._yOffset;\r\n        this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\r\n        this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;\r\n\r\n        // Color\r\n        this._vertexData[arrayOffset + 14] = sprite.color.r;\r\n        this._vertexData[arrayOffset + 15] = sprite.color.g;\r\n        this._vertexData[arrayOffset + 16] = sprite.color.b;\r\n        this._vertexData[arrayOffset + 17] = sprite.color.a;\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        const indices = [];\r\n        let index = 0;\r\n        for (let count = 0; count < this._capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the renderer (after a context lost, for eg)\r\n     */\r\n    public rebuild(): void {\r\n        if (this._indexBuffer) {\r\n            this._buildIndexBuffer();\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            this._vertexArrayObject = undefined as any;\r\n        }\r\n\r\n        this._buffer._rebuild();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n\r\n        this._spriteBuffer?._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._buffer) {\r\n            this._buffer.dispose();\r\n            (<any>this._buffer) = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            (<any>this._indexBuffer) = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            (<any>this._vertexArrayObject) = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            (<any>this.texture) = null;\r\n        }\r\n        this._drawWrapperBase.dispose();\r\n        this._drawWrapperFog.dispose();\r\n        this._drawWrapperDepth.dispose();\r\n        this._drawWrapperFogDepth.dispose();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}