{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport \"../../Engines/Extensions/engine.multiRender.js\";\n/**\n * A multi render target, like a render target provides the ability to render to a texture.\n * Unlike the render target, it can render to several draw buffers in one draw.\n * This is specially interesting in deferred rendering or for any effects requiring more than\n * just one color from a single pass.\n */\nexport class MultiRenderTarget extends RenderTargetTexture {\n  /**\n   * Get if draw buffers are currently supported by the used hardware and browser.\n   */\n  get isSupported() {\n    var _a, _b;\n    return (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.getCaps().drawBuffersExtension) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\n   * Get the list of textures generated by the multi render target.\n   */\n  get textures() {\n    return this._textures;\n  }\n  /**\n   * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\n   */\n  get count() {\n    return this._count;\n  }\n  /**\n   * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\n   */\n  get depthTexture() {\n    return this._textures[this._textures.length - 1];\n  }\n  /**\n   * Set the wrapping mode on U of all the textures we are rendering to.\n   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n   */\n  set wrapU(wrap) {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i].wrapU = wrap;\n      }\n    }\n  }\n  /**\n   * Set the wrapping mode on V of all the textures we are rendering to.\n   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n   */\n  set wrapV(wrap) {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i].wrapV = wrap;\n      }\n    }\n  }\n  /**\n   * Instantiate a new multi render target texture.\n   * A multi render target, like a render target provides the ability to render to a texture.\n   * Unlike the render target, it can render to several draw buffers in one draw.\n   * This is specially interesting in deferred rendering or for any effects requiring more than\n   * just one color from a single pass.\n   * @param name Define the name of the texture\n   * @param size Define the size of the buffers to render to\n   * @param count Define the number of target we are rendering into\n   * @param scene Define the scene the texture belongs to\n   * @param options Define the options used to create the multi render target\n   * @param textureNames Define the names to set to the textures (if count > 0 - optional)\n   */\n  constructor(name, size, count, scene, options, textureNames) {\n    const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n    const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n    const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;\n    const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n    const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\n    super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\n    if (!this.isSupported) {\n      this.dispose();\n      return;\n    }\n    this._textureNames = textureNames;\n    const types = [];\n    const samplingModes = [];\n    const useSRGBBuffers = [];\n    const formats = [];\n    const targetTypes = [];\n    const faceIndex = [];\n    const layerIndex = [];\n    const layerCounts = [];\n    this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\n    const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    this._multiRenderTargetOptions = {\n      samplingModes: samplingModes,\n      generateMipMaps: generateMipMaps,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer,\n      generateDepthTexture: generateDepthTexture,\n      depthTextureFormat: depthTextureFormat,\n      types: types,\n      textureCount: count,\n      useSRGBBuffers: useSRGBBuffers,\n      formats: formats,\n      targetTypes: targetTypes,\n      faceIndex: faceIndex,\n      layerIndex: layerIndex,\n      layerCounts: layerCounts\n    };\n    this._count = count;\n    this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\n    if (count > 0) {\n      this._createInternalTextures();\n      this._createTextures(textureNames);\n    }\n  }\n  _initTypes(count, types, samplingModes, useSRGBBuffers, formats, targets, faceIndex, layerIndex, layerCounts, options) {\n    for (let i = 0; i < count; i++) {\n      if (options && options.types && options.types[i] !== undefined) {\n        types.push(options.types[i]);\n      } else {\n        types.push(options && options.defaultType ? options.defaultType : 0);\n      }\n      if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n        samplingModes.push(options.samplingModes[i]);\n      } else {\n        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n      }\n      if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\n        useSRGBBuffers.push(options.useSRGBBuffers[i]);\n      } else {\n        useSRGBBuffers.push(false);\n      }\n      if (options && options.formats && options.formats[i] !== undefined) {\n        formats.push(options.formats[i]);\n      } else {\n        formats.push(5);\n      }\n      if (options && options.targetTypes && options.targetTypes[i] !== undefined) {\n        targets.push(options.targetTypes[i]);\n      } else {\n        targets.push(3553);\n      }\n      if (options && options.faceIndex && options.faceIndex[i] !== undefined) {\n        faceIndex.push(options.faceIndex[i]);\n      } else {\n        faceIndex.push(0);\n      }\n      if (options && options.layerIndex && options.layerIndex[i] !== undefined) {\n        layerIndex.push(options.layerIndex[i]);\n      } else {\n        layerIndex.push(0);\n      }\n      if (options && options.layerCounts && options.layerCounts[i] !== undefined) {\n        layerCounts.push(options.layerCounts[i]);\n      } else {\n        layerCounts.push(1);\n      }\n    }\n  }\n  _createInternaTextureIndexMapping() {\n    const mapMainInternalTexture2Index = {};\n    const mapInternalTexture2MainIndex = [];\n    if (!this._renderTarget) {\n      return mapInternalTexture2MainIndex;\n    }\n    const internalTextures = this._renderTarget.textures;\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = internalTextures[i];\n      if (!texture) {\n        continue;\n      }\n      const mainIndex = mapMainInternalTexture2Index[texture.uniqueId];\n      if (mainIndex !== undefined) {\n        mapInternalTexture2MainIndex[i] = mainIndex;\n      } else {\n        mapMainInternalTexture2Index[texture.uniqueId] = i;\n      }\n    }\n    return mapInternalTexture2MainIndex;\n  }\n  /**\n   * @internal\n   */\n  _rebuild(forceFullRebuild = false, textureNames) {\n    if (this._count < 1) {\n      return;\n    }\n    const mapInternalTexture2MainIndex = this._createInternaTextureIndexMapping();\n    this.releaseInternalTextures();\n    this._createInternalTextures();\n    if (forceFullRebuild) {\n      this._releaseTextures();\n      this._createTextures(textureNames);\n    }\n    const internalTextures = this._renderTarget.textures;\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = this._textures[i];\n      if (mapInternalTexture2MainIndex[i] !== undefined) {\n        this._renderTarget.setTexture(internalTextures[mapInternalTexture2MainIndex[i]], i);\n      }\n      texture._texture = internalTextures[i];\n      if (texture._texture) {\n        texture._noMipmap = !texture._texture.useMipMaps;\n        texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\n      }\n    }\n    if (this.samples !== 1) {\n      this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\n    }\n  }\n  _createInternalTextures() {\n    this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\n    this._texture = this._renderTarget.texture;\n  }\n  _releaseTextures() {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\n        this._textures[i].dispose();\n      }\n    }\n  }\n  _createTextures(textureNames) {\n    const internalTextures = this._renderTarget.textures;\n    this._textures = [];\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = new Texture(null, this.getScene());\n      if (textureNames === null || textureNames === void 0 ? void 0 : textureNames[i]) {\n        texture.name = textureNames[i];\n      }\n      texture._texture = internalTextures[i];\n      if (texture._texture) {\n        texture._noMipmap = !texture._texture.useMipMaps;\n        texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\n      }\n      this._textures.push(texture);\n    }\n  }\n  /**\n   * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\n   * @param texture The new texture to set in the MRT\n   * @param index The index of the texture to replace\n   * @param disposePrevious Set to true if the previous internal texture should be disposed\n   */\n  setInternalTexture(texture, index, disposePrevious = true) {\n    var _a, _b;\n    if (!this.renderTarget) {\n      return;\n    }\n    if (index === 0) {\n      this._texture = texture;\n    }\n    this.renderTarget.setTexture(texture, index, disposePrevious);\n    if (!this.textures[index]) {\n      this.textures[index] = new Texture(null, this.getScene());\n      this.textures[index].name = (_b = (_a = this._textureNames) === null || _a === void 0 ? void 0 : _a[index]) !== null && _b !== void 0 ? _b : this.textures[index].name;\n    }\n    this.textures[index]._texture = texture;\n    this.textures[index]._noMipmap = !texture.useMipMaps;\n    this.textures[index]._useSRGBBuffer = texture._useSRGBBuffer;\n    this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\n    if (this._multiRenderTargetOptions.types) {\n      this._multiRenderTargetOptions.types[index] = texture.type;\n    }\n    if (this._multiRenderTargetOptions.samplingModes) {\n      this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\n    }\n    if (this._multiRenderTargetOptions.useSRGBBuffers) {\n      this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\n    }\n    if (this._multiRenderTargetOptions.targetTypes && this._multiRenderTargetOptions.targetTypes[index] !== -1) {\n      let target = 0;\n      if (texture.is2DArray) {\n        target = 35866;\n      } else if (texture.isCube) {\n        target = 34067;\n      } /*else if (texture.isCubeArray) {\n          target = 3735928559;\n        }*/else if (texture.is3D) {\n        target = 32879;\n      } else {\n        target = 3553;\n      }\n      this._multiRenderTargetOptions.targetTypes[index] = target;\n    }\n  }\n  /**\n   * Changes an attached texture's face index or layer.\n   * @param index The index of the texture to modify the attachment of\n   * @param layerIndex The layer index of the texture to be attached to the framebuffer\n   * @param faceIndex The face index of the texture to be attached to the framebuffer\n   */\n  setLayerAndFaceIndex(index, layerIndex = -1, faceIndex = -1) {\n    if (!this.textures[index] || !this.renderTarget) {\n      return;\n    }\n    if (this._multiRenderTargetOptions.layerIndex) {\n      this._multiRenderTargetOptions.layerIndex[index] = layerIndex;\n    }\n    if (this._multiRenderTargetOptions.faceIndex) {\n      this._multiRenderTargetOptions.faceIndex[index] = faceIndex;\n    }\n    this.renderTarget.setLayerAndFaceIndex(index, layerIndex, faceIndex);\n  }\n  /**\n   * Changes every attached texture's face index or layer.\n   * @param layerIndices The layer indices of the texture to be attached to the framebuffer\n   * @param faceIndices The face indices of the texture to be attached to the framebuffer\n   */\n  setLayerAndFaceIndices(layerIndices, faceIndices) {\n    if (!this.renderTarget) {\n      return;\n    }\n    this._multiRenderTargetOptions.layerIndex = layerIndices;\n    this._multiRenderTargetOptions.faceIndex = faceIndices;\n    this.renderTarget.setLayerAndFaceIndices(layerIndices, faceIndices);\n  }\n  /**\n   * Define the number of samples used if MSAA is enabled.\n   */\n  get samples() {\n    return this._samples;\n  }\n  set samples(value) {\n    if (this._renderTarget) {\n      this._samples = this._renderTarget.setSamples(value);\n    } else {\n      // In case samples are set with 0 textures created, we must save the desired samples value\n      this._samples = value;\n    }\n  }\n  /**\n   * Resize all the textures in the multi render target.\n   * Be careful as it will recreate all the data in the new texture.\n   * @param size Define the new size\n   */\n  resize(size) {\n    this._processSizeParameter(size, false);\n    this._rebuild(undefined, this._textureNames);\n  }\n  /**\n   * Changes the number of render targets in this MRT\n   * Be careful as it will recreate all the data in the new texture.\n   * @param count new texture count\n   * @param options Specifies texture types and sampling modes for new textures\n   * @param textureNames Specifies the names of the textures (optional)\n   */\n  updateCount(count, options, textureNames) {\n    this._multiRenderTargetOptions.textureCount = count;\n    this._count = count;\n    const types = [];\n    const samplingModes = [];\n    const useSRGBBuffers = [];\n    const formats = [];\n    const targetTypes = [];\n    const faceIndex = [];\n    const layerIndex = [];\n    const layerCounts = [];\n    this._textureNames = textureNames;\n    this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\n    this._multiRenderTargetOptions.types = types;\n    this._multiRenderTargetOptions.samplingModes = samplingModes;\n    this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\n    this._multiRenderTargetOptions.formats = formats;\n    this._multiRenderTargetOptions.targetTypes = targetTypes;\n    this._multiRenderTargetOptions.faceIndex = faceIndex;\n    this._multiRenderTargetOptions.layerIndex = layerIndex;\n    this._multiRenderTargetOptions.layerCounts = layerCounts;\n    this._rebuild(true, textureNames);\n  }\n  _unbindFrameBuffer(engine, faceIndex) {\n    if (this._renderTarget) {\n      engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\n        this.onAfterRenderObservable.notifyObservers(faceIndex);\n      });\n    }\n  }\n  /**\n   * Dispose the render targets and their associated resources\n   * @param doNotDisposeInternalTextures\n   */\n  dispose(doNotDisposeInternalTextures = false) {\n    this._releaseTextures();\n    if (!doNotDisposeInternalTextures) {\n      this.releaseInternalTextures();\n    } else {\n      // Prevent internal texture dispose in super.dispose\n      this._texture = null;\n    }\n    super.dispose();\n  }\n  /**\n   * Release all the underlying texture used as draw buffers.\n   */\n  releaseInternalTextures() {\n    var _a, _b;\n    const internalTextures = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.textures;\n    if (!internalTextures) {\n      return;\n    }\n    for (let i = internalTextures.length - 1; i >= 0; i--) {\n      this._textures[i]._texture = null;\n    }\n    (_b = this._renderTarget) === null || _b === void 0 ? void 0 : _b.dispose();\n    this._renderTarget = null;\n  }\n}","map":{"version":3,"names":["Texture","RenderTargetTexture","MultiRenderTarget","isSupported","_b","_a","_engine","getCaps","drawBuffersExtension","textures","_textures","count","_count","depthTexture","length","wrapU","wrap","i","wrapV","constructor","name","size","scene","options","textureNames","generateMipMaps","generateDepthTexture","depthTextureFormat","doNotChangeAspectRatio","undefined","drawOnlyOnFirstAttachmentByDefault","dispose","_textureNames","types","samplingModes","useSRGBBuffers","formats","targetTypes","faceIndex","layerIndex","layerCounts","_initTypes","generateDepthBuffer","generateStencilBuffer","_multiRenderTargetOptions","textureCount","_drawOnlyOnFirstAttachmentByDefault","_createInternalTextures","_createTextures","targets","push","defaultType","BILINEAR_SAMPLINGMODE","_createInternaTextureIndexMapping","mapMainInternalTexture2Index","mapInternalTexture2MainIndex","_renderTarget","internalTextures","texture","mainIndex","uniqueId","_rebuild","forceFullRebuild","releaseInternalTextures","_releaseTextures","setTexture","_texture","_noMipmap","useMipMaps","_useSRGBBuffer","samples","setSamples","_getEngine","createMultipleRenderTarget","_size","getScene","setInternalTexture","index","disposePrevious","renderTarget","type","samplingMode","target","is2DArray","isCube","is3D","setLayerAndFaceIndex","setLayerAndFaceIndices","layerIndices","faceIndices","_samples","value","resize","_processSizeParameter","updateCount","_unbindFrameBuffer","engine","unBindMultiColorAttachmentFramebuffer","onAfterRenderObservable","notifyObservers","doNotDisposeInternalTextures"],"sources":["../../../../../dev/core/src/Materials/Textures/multiRenderTarget.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport \"../../Engines/Extensions/engine.multiRender\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Creation options of the multi render target texture.\r\n */\r\nexport interface IMultiRenderTargetOptions {\r\n    /**\r\n     * Define if the texture needs to create mip maps after render.\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Define the types of all the draw buffers we want to create\r\n     */\r\n    types?: number[];\r\n    /**\r\n     * Define the sampling modes of all the draw buffers we want to create\r\n     */\r\n    samplingModes?: number[];\r\n    /**\r\n     * Define if sRGB format should be used for each of the draw buffers we want to create\r\n     */\r\n    useSRGBBuffers?: boolean[];\r\n    /**\r\n     * Define if a depth buffer is required\r\n     */\r\n    generateDepthBuffer?: boolean;\r\n    /**\r\n     * Define if a stencil buffer is required\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n    /**\r\n     * Define if a depth texture is required instead of a depth buffer\r\n     */\r\n    generateDepthTexture?: boolean;\r\n    /**\r\n     * Define the internal format of the buffer in the RTT (RED, RG, RGB, RGBA (default), ALPHA...) of all the draw buffers we want to create\r\n     */\r\n    formats?: number[];\r\n    /**\r\n     * Define depth texture format to use\r\n     */\r\n    depthTextureFormat?: number;\r\n    /**\r\n     * Define the number of desired draw buffers\r\n     */\r\n    textureCount?: number;\r\n    /**\r\n     * Define if aspect ratio should be adapted to the texture or stay the scene one\r\n     */\r\n    doNotChangeAspectRatio?: boolean;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    defaultType?: number;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    drawOnlyOnFirstAttachmentByDefault?: boolean;\r\n    /**\r\n     * Define the type of texture at each attahment index (of Constants.TEXTURE_2D, .TEXTURE_2D_ARRAY, .TEXTURE_CUBE_MAP, .TEXTURE_CUBE_MAP_ARRAY, .TEXTURE_3D).\r\n     * You can also use the -1 value to indicate that no texture should be created but that you will assign a texture to that attachment index later.\r\n     * Can be useful when you want to attach several layers of the same 2DArrayTexture / 3DTexture or several faces of the same CubeMapTexture: Use the setInternalTexture\r\n     * method for that purpose, after the MultiRenderTarget has been created.\r\n     */\r\n    targetTypes?: number[];\r\n    /**\r\n     * Define the face index of each texture in the textures array (if applicable, given the corresponding targetType) at creation time (for Constants.TEXTURE_CUBE_MAP and .TEXTURE_CUBE_MAP_ARRAY).\r\n     * Can be changed at any time by calling setLayerAndFaceIndices or setLayerAndFaceIndex\r\n     */\r\n    faceIndex?: number[];\r\n    /**\r\n     * Define the layer index of each texture in the textures array (if applicable, given the corresponding targetType) at creation time (for Constants.TEXTURE_3D, .TEXTURE_2D_ARRAY, and .TEXTURE_CUBE_MAP_ARRAY).\r\n     * Can be changed at any time by calling setLayerAndFaceIndices or setLayerAndFaceIndex\r\n     */\r\n    layerIndex?: number[];\r\n    /**\r\n     * Define the number of layer of each texture in the textures array (if applicable, given the corresponding targetType) (for Constants.TEXTURE_3D, .TEXTURE_2D_ARRAY, and .TEXTURE_CUBE_MAP_ARRAY)\r\n     */\r\n    layerCounts?: number[];\r\n}\r\n\r\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\r\nexport class MultiRenderTarget extends RenderTargetTexture {\r\n    private _textures: Texture[];\r\n    private _multiRenderTargetOptions: IMultiRenderTargetOptions;\r\n    private _count: number;\r\n    private _drawOnlyOnFirstAttachmentByDefault: boolean;\r\n    private _textureNames?: string[];\r\n\r\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._engine?.getCaps().drawBuffersExtension ?? false;\r\n    }\r\n\r\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\r\n    public get textures(): Texture[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\r\n    public get count(): number {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\r\n    public get depthTexture(): Texture {\r\n        return this._textures[this._textures.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapU(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapU = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapV(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapV = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new multi render target texture.\r\n     * A multi render target, like a render target provides the ability to render to a texture.\r\n     * Unlike the render target, it can render to several draw buffers in one draw.\r\n     * This is specially interesting in deferred rendering or for any effects requiring more than\r\n     * just one color from a single pass.\r\n     * @param name Define the name of the texture\r\n     * @param size Define the size of the buffers to render to\r\n     * @param count Define the number of target we are rendering into\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param options Define the options used to create the multi render target\r\n     * @param textureNames Define the names to set to the textures (if count > 0 - optional)\r\n     */\r\n    constructor(name: string, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\r\n        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\r\n        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : Constants.TEXTUREFORMAT_DEPTH16;\r\n        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\r\n        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\r\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n\r\n        if (!this.isSupported) {\r\n            this.dispose();\r\n            return;\r\n        }\r\n\r\n        this._textureNames = textureNames;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        const useSRGBBuffers: boolean[] = [];\r\n        const formats: number[] = [];\r\n        const targetTypes: number[] = [];\r\n        const faceIndex: number[] = [];\r\n        const layerIndex: number[] = [];\r\n        const layerCounts: number[] = [];\r\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\r\n\r\n        const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n\r\n        this._multiRenderTargetOptions = {\r\n            samplingModes: samplingModes,\r\n            generateMipMaps: generateMipMaps,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            generateDepthTexture: generateDepthTexture,\r\n            depthTextureFormat: depthTextureFormat,\r\n            types: types,\r\n            textureCount: count,\r\n            useSRGBBuffers: useSRGBBuffers,\r\n            formats: formats,\r\n            targetTypes: targetTypes,\r\n            faceIndex: faceIndex,\r\n            layerIndex: layerIndex,\r\n            layerCounts: layerCounts,\r\n        };\r\n\r\n        this._count = count;\r\n        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\r\n\r\n        if (count > 0) {\r\n            this._createInternalTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n    }\r\n\r\n    private _initTypes(\r\n        count: number,\r\n        types: number[],\r\n        samplingModes: number[],\r\n        useSRGBBuffers: boolean[],\r\n        formats: number[],\r\n        targets: number[],\r\n        faceIndex: number[],\r\n        layerIndex: number[],\r\n        layerCounts: number[],\r\n        options?: IMultiRenderTargetOptions\r\n    ) {\r\n        for (let i = 0; i < count; i++) {\r\n            if (options && options.types && options.types[i] !== undefined) {\r\n                types.push(options.types[i]);\r\n            } else {\r\n                types.push(options && options.defaultType ? options.defaultType : Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            }\r\n\r\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\r\n                samplingModes.push(options.samplingModes[i]);\r\n            } else {\r\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\r\n            }\r\n\r\n            if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\r\n                useSRGBBuffers.push(options.useSRGBBuffers[i]);\r\n            } else {\r\n                useSRGBBuffers.push(false);\r\n            }\r\n\r\n            if (options && options.formats && options.formats[i] !== undefined) {\r\n                formats.push(options.formats[i]);\r\n            } else {\r\n                formats.push(Constants.TEXTUREFORMAT_RGBA);\r\n            }\r\n\r\n            if (options && options.targetTypes && options.targetTypes[i] !== undefined) {\r\n                targets.push(options.targetTypes[i]);\r\n            } else {\r\n                targets.push(Constants.TEXTURE_2D);\r\n            }\r\n\r\n            if (options && options.faceIndex && options.faceIndex[i] !== undefined) {\r\n                faceIndex.push(options.faceIndex[i]);\r\n            } else {\r\n                faceIndex.push(0);\r\n            }\r\n\r\n            if (options && options.layerIndex && options.layerIndex[i] !== undefined) {\r\n                layerIndex.push(options.layerIndex[i]);\r\n            } else {\r\n                layerIndex.push(0);\r\n            }\r\n\r\n            if (options && options.layerCounts && options.layerCounts[i] !== undefined) {\r\n                layerCounts.push(options.layerCounts[i]);\r\n            } else {\r\n                layerCounts.push(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createInternaTextureIndexMapping() {\r\n        const mapMainInternalTexture2Index: { [key: number]: number } = {};\r\n        const mapInternalTexture2MainIndex: number[] = [];\r\n\r\n        if (!this._renderTarget) {\r\n            return mapInternalTexture2MainIndex;\r\n        }\r\n\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = internalTextures[i];\r\n            if (!texture) {\r\n                continue;\r\n            }\r\n            const mainIndex = mapMainInternalTexture2Index[texture.uniqueId];\r\n            if (mainIndex !== undefined) {\r\n                mapInternalTexture2MainIndex[i] = mainIndex;\r\n            } else {\r\n                mapMainInternalTexture2Index[texture.uniqueId] = i;\r\n            }\r\n        }\r\n\r\n        return mapInternalTexture2MainIndex;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _rebuild(forceFullRebuild: boolean = false, textureNames?: string[]): void {\r\n        if (this._count < 1) {\r\n            return;\r\n        }\r\n\r\n        const mapInternalTexture2MainIndex = this._createInternaTextureIndexMapping();\r\n\r\n        this.releaseInternalTextures();\r\n        this._createInternalTextures();\r\n\r\n        if (forceFullRebuild) {\r\n            this._releaseTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = this._textures[i];\r\n            if (mapInternalTexture2MainIndex[i] !== undefined) {\r\n                this._renderTarget!.setTexture(internalTextures[mapInternalTexture2MainIndex[i]], i);\r\n            }\r\n            texture._texture = internalTextures[i];\r\n            if (texture._texture) {\r\n                texture._noMipmap = !texture._texture.useMipMaps;\r\n                texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\r\n            }\r\n        }\r\n\r\n        if (this.samples !== 1) {\r\n            this._renderTarget!.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\r\n        }\r\n    }\r\n\r\n    private _createInternalTextures(): void {\r\n        this._renderTarget = this._getEngine()!.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\r\n        this._texture = this._renderTarget.texture;\r\n    }\r\n\r\n    private _releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createTextures(textureNames?: string[]): void {\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        this._textures = [];\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = new Texture(null, this.getScene());\r\n            if (textureNames?.[i]) {\r\n                texture.name = textureNames[i];\r\n            }\r\n            texture._texture = internalTextures[i];\r\n            if (texture._texture) {\r\n                texture._noMipmap = !texture._texture.useMipMaps;\r\n                texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\r\n            }\r\n            this._textures.push(texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\r\n     * @param texture The new texture to set in the MRT\r\n     * @param index The index of the texture to replace\r\n     * @param disposePrevious Set to true if the previous internal texture should be disposed\r\n     */\r\n    public setInternalTexture(texture: InternalTexture, index: number, disposePrevious: boolean = true) {\r\n        if (!this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        if (index === 0) {\r\n            this._texture = texture;\r\n        }\r\n\r\n        this.renderTarget.setTexture(texture, index, disposePrevious);\r\n\r\n        if (!this.textures[index]) {\r\n            this.textures[index] = new Texture(null, this.getScene());\r\n            this.textures[index].name = this._textureNames?.[index] ?? this.textures[index].name;\r\n        }\r\n        this.textures[index]._texture = texture;\r\n        this.textures[index]._noMipmap = !texture.useMipMaps;\r\n        this.textures[index]._useSRGBBuffer = texture._useSRGBBuffer;\r\n\r\n        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\r\n\r\n        if (this._multiRenderTargetOptions.types) {\r\n            this._multiRenderTargetOptions.types[index] = texture.type;\r\n        }\r\n        if (this._multiRenderTargetOptions.samplingModes) {\r\n            this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\r\n        }\r\n        if (this._multiRenderTargetOptions.useSRGBBuffers) {\r\n            this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\r\n        }\r\n        if (this._multiRenderTargetOptions.targetTypes && this._multiRenderTargetOptions.targetTypes[index] !== -1) {\r\n            let target: number = 0;\r\n            if (texture.is2DArray) {\r\n                target = Constants.TEXTURE_2D_ARRAY;\r\n            } else if (texture.isCube) {\r\n                target = Constants.TEXTURE_CUBE_MAP;\r\n            } /*else if (texture.isCubeArray) {\r\n                target = Constants.TEXTURE_CUBE_MAP_ARRAY;\r\n            }*/ else if (texture.is3D) {\r\n                target = Constants.TEXTURE_3D;\r\n            } else {\r\n                target = Constants.TEXTURE_2D;\r\n            }\r\n            this._multiRenderTargetOptions.targetTypes[index] = target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes an attached texture's face index or layer.\r\n     * @param index The index of the texture to modify the attachment of\r\n     * @param layerIndex The layer index of the texture to be attached to the framebuffer\r\n     * @param faceIndex The face index of the texture to be attached to the framebuffer\r\n     */\r\n    public setLayerAndFaceIndex(index: number, layerIndex: number = -1, faceIndex: number = -1) {\r\n        if (!this.textures[index] || !this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        if (this._multiRenderTargetOptions.layerIndex) {\r\n            this._multiRenderTargetOptions.layerIndex[index] = layerIndex;\r\n        }\r\n        if (this._multiRenderTargetOptions.faceIndex) {\r\n            this._multiRenderTargetOptions.faceIndex[index] = faceIndex;\r\n        }\r\n\r\n        this.renderTarget.setLayerAndFaceIndex(index, layerIndex, faceIndex);\r\n    }\r\n\r\n    /**\r\n     * Changes every attached texture's face index or layer.\r\n     * @param layerIndices The layer indices of the texture to be attached to the framebuffer\r\n     * @param faceIndices The face indices of the texture to be attached to the framebuffer\r\n     */\r\n    public setLayerAndFaceIndices(layerIndices: number[], faceIndices: number[]) {\r\n        if (!this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        this._multiRenderTargetOptions.layerIndex = layerIndices;\r\n        this._multiRenderTargetOptions.faceIndex = faceIndices;\r\n\r\n        this.renderTarget.setLayerAndFaceIndices(layerIndices, faceIndices);\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._renderTarget) {\r\n            this._samples = this._renderTarget.setSamples(value);\r\n        } else {\r\n            // In case samples are set with 0 textures created, we must save the desired samples value\r\n            this._samples = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resize all the textures in the multi render target.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size\r\n     */\r\n    public resize(size: any) {\r\n        this._processSizeParameter(size, false);\r\n        this._rebuild(undefined, this._textureNames);\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        this._multiRenderTargetOptions.textureCount = count;\r\n        this._count = count;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        const useSRGBBuffers: boolean[] = [];\r\n        const formats: number[] = [];\r\n        const targetTypes: number[] = [];\r\n        const faceIndex: number[] = [];\r\n        const layerIndex: number[] = [];\r\n        const layerCounts: number[] = [];\r\n\r\n        this._textureNames = textureNames;\r\n\r\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\r\n        this._multiRenderTargetOptions.types = types;\r\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\r\n        this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\r\n        this._multiRenderTargetOptions.formats = formats;\r\n        this._multiRenderTargetOptions.targetTypes = targetTypes;\r\n        this._multiRenderTargetOptions.faceIndex = faceIndex;\r\n        this._multiRenderTargetOptions.layerIndex = layerIndex;\r\n        this._multiRenderTargetOptions.layerCounts = layerCounts;\r\n\r\n        this._rebuild(true, textureNames);\r\n    }\r\n\r\n    protected _unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (this._renderTarget) {\r\n            engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\r\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the render targets and their associated resources\r\n     * @param doNotDisposeInternalTextures\r\n     */\r\n    public dispose(doNotDisposeInternalTextures = false): void {\r\n        this._releaseTextures();\r\n        if (!doNotDisposeInternalTextures) {\r\n            this.releaseInternalTextures();\r\n        } else {\r\n            // Prevent internal texture dispose in super.dispose\r\n            this._texture = null;\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Release all the underlying texture used as draw buffers.\r\n     */\r\n    public releaseInternalTextures(): void {\r\n        const internalTextures = this._renderTarget?.textures;\r\n\r\n        if (!internalTextures) {\r\n            return;\r\n        }\r\n\r\n        for (let i = internalTextures.length - 1; i >= 0; i--) {\r\n            this._textures[i]._texture = null;\r\n        }\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}