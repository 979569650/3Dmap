{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Animation } from \"./animation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Tags } from \"../Misc/tags.js\";\n/**\n * This class defines the direct association between an animation and a target\n */\nexport class TargetedAnimation {\n  /**\n   * Returns the string \"TargetedAnimation\"\n   * @returns \"TargetedAnimation\"\n   */\n  getClassName() {\n    return \"TargetedAnimation\";\n  }\n  /**\n   * Serialize the object\n   * @returns the JSON object representing the current entity\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.animation = this.animation.serialize();\n    serializationObject.targetId = this.target.id;\n    return serializationObject;\n  }\n}\n/**\n * Use this class to create coordinated animations on multiple targets\n */\nexport class AnimationGroup {\n  /**\n   * Makes sure that the animations are either played or stopped according to the animation group mask.\n   * Note however that the call won't have any effect if the animation group has not been started yet.\n   * You should call this function if you modify the mask after the animation group has been started.\n   */\n  syncWithMask() {\n    if (!this.mask) {\n      this._numActiveAnimatables = this._targetedAnimations.length;\n      return;\n    }\n    this._numActiveAnimatables = 0;\n    for (let i = 0; i < this._animatables.length; ++i) {\n      const animatable = this._animatables[i];\n      if (this.mask.retainsTarget(animatable.target.name)) {\n        this._numActiveAnimatables++;\n        if (animatable.paused) {\n          animatable.restart();\n        }\n      } else {\n        if (!animatable.paused) {\n          animatable.pause();\n        }\n      }\n    }\n  }\n  /**\n   * Removes all animations for the targets not retained by the animation group mask.\n   * Use this function if you know you won't need those animations anymore and if you want to free memory.\n   */\n  removeUnmaskedAnimations() {\n    if (!this.mask) {\n      return;\n    }\n    // Removes all animatables (in case the animation group has already been started)\n    for (let i = 0; i < this._animatables.length; ++i) {\n      const animatable = this._animatables[i];\n      if (!this.mask.retainsTarget(animatable.target.name)) {\n        animatable.stop();\n        this._animatables.splice(i, 1);\n        --i;\n      }\n    }\n    // Removes the targeted animations\n    for (let index = 0; index < this._targetedAnimations.length; index++) {\n      const targetedAnimation = this._targetedAnimations[index];\n      if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\n        this._targetedAnimations.splice(index, 1);\n        --index;\n      }\n    }\n  }\n  /**\n   * Gets the first frame\n   */\n  get from() {\n    return this._from;\n  }\n  /**\n   * Gets the last frame\n   */\n  get to() {\n    return this._to;\n  }\n  /**\n   * Define if the animations are started\n   */\n  get isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a value indicating that the current group is playing\n   */\n  get isPlaying() {\n    return this._isStarted && !this._isPaused;\n  }\n  /**\n   * Gets or sets the speed ratio to use for all animations\n   */\n  get speedRatio() {\n    return this._speedRatio;\n  }\n  /**\n   * Gets or sets the speed ratio to use for all animations\n   */\n  set speedRatio(value) {\n    if (this._speedRatio === value) {\n      return;\n    }\n    this._speedRatio = value;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.speedRatio = this._speedRatio;\n    }\n  }\n  /**\n   * Gets or sets if all animations should loop or not\n   */\n  get loopAnimation() {\n    return this._loopAnimation;\n  }\n  set loopAnimation(value) {\n    if (this._loopAnimation === value) {\n      return;\n    }\n    this._loopAnimation = value;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.loopAnimation = this._loopAnimation;\n    }\n  }\n  /**\n   * Gets or sets if all animations should be evaluated additively\n   */\n  get isAdditive() {\n    return this._isAdditive;\n  }\n  set isAdditive(value) {\n    if (this._isAdditive === value) {\n      return;\n    }\n    this._isAdditive = value;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.isAdditive = this._isAdditive;\n    }\n  }\n  /**\n   * Gets or sets the weight to apply to all animations of the group\n   */\n  get weight() {\n    return this._weight;\n  }\n  set weight(value) {\n    if (this._weight === value) {\n      return;\n    }\n    this._weight = value;\n    this.setWeightForAllAnimatables(this._weight);\n  }\n  /**\n   * Gets the targeted animations for this animation group\n   */\n  get targetedAnimations() {\n    return this._targetedAnimations;\n  }\n  /**\n   * returning the list of animatables controlled by this animation group.\n   */\n  get animatables() {\n    return this._animatables;\n  }\n  /**\n   * Gets the list of target animations\n   */\n  get children() {\n    return this._targetedAnimations;\n  }\n  /**\n   * Gets or sets the order of play of the animation group (default: 0)\n   */\n  get playOrder() {\n    return this._playOrder;\n  }\n  set playOrder(value) {\n    if (this._playOrder === value) {\n      return;\n    }\n    this._playOrder = value;\n    if (this._animatables.length > 0) {\n      for (let i = 0; i < this._animatables.length; i++) {\n        this._animatables[i].playOrder = this._playOrder;\n      }\n      this._scene.sortActiveAnimatables();\n    }\n  }\n  /**\n   * Allows the animations of the animation group to blend with current running animations\n   * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\n   */\n  get enableBlending() {\n    return this._enableBlending;\n  }\n  set enableBlending(value) {\n    if (this._enableBlending === value) {\n      return;\n    }\n    this._enableBlending = value;\n    if (value !== null) {\n      for (let i = 0; i < this._targetedAnimations.length; ++i) {\n        this._targetedAnimations[i].animation.enableBlending = value;\n      }\n    }\n  }\n  /**\n   * Gets or sets the animation blending speed\n   * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\n   */\n  get blendingSpeed() {\n    return this._blendingSpeed;\n  }\n  set blendingSpeed(value) {\n    if (this._blendingSpeed === value) {\n      return;\n    }\n    this._blendingSpeed = value;\n    if (value !== null) {\n      for (let i = 0; i < this._targetedAnimations.length; ++i) {\n        this._targetedAnimations[i].animation.blendingSpeed = value;\n      }\n    }\n  }\n  /**\n   * Gets the length (in seconds) of the animation group\n   * This function assumes that all animations are played at the same framePerSecond speed!\n   * Note: you can only call this method after you've added at least one targeted animation!\n   * @param from Starting frame range (default is AnimationGroup.from)\n   * @param to Ending frame range (default is AnimationGroup.to)\n   * @returns The length in seconds\n   */\n  getLength(from, to) {\n    from = from !== null && from !== void 0 ? from : this._from;\n    to = to !== null && to !== void 0 ? to : this._to;\n    const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\n    return (to - from) / fps;\n  }\n  /**\n   * Merge the array of animation groups into a new animation group\n   * @param animationGroups List of animation groups to merge\n   * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\n   * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\n   * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\n   * @returns The new animation group or null if no animation groups were passed\n   */\n  static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {\n    if (animationGroups.length === 0) {\n      return null;\n    }\n    weight = weight !== null && weight !== void 0 ? weight : animationGroups[0].weight;\n    let beginFrame = Number.MAX_VALUE;\n    let endFrame = -Number.MAX_VALUE;\n    if (normalize) {\n      for (const animationGroup of animationGroups) {\n        if (animationGroup.from < beginFrame) {\n          beginFrame = animationGroup.from;\n        }\n        if (animationGroup.to > endFrame) {\n          endFrame = animationGroup.to;\n        }\n      }\n    }\n    const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\n    for (const animationGroup of animationGroups) {\n      if (normalize) {\n        animationGroup.normalize(beginFrame, endFrame);\n      }\n      for (const targetedAnimation of animationGroup.targetedAnimations) {\n        mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\n      }\n      if (disposeSource) {\n        animationGroup.dispose();\n      }\n    }\n    return mergedAnimationGroup;\n  }\n  /**\n   * Instantiates a new Animation Group.\n   * This helps managing several animations at once.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n   * @param name Defines the name of the group\n   * @param scene Defines the scene the group belongs to\n   * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\n   * @param playOrder Defines the order of play of the animation group (default is 0)\n   */\n  constructor( /** The name of the animation group */\n  name, scene = null, weight = -1, playOrder = 0) {\n    this.name = name;\n    this._targetedAnimations = new Array();\n    this._animatables = new Array();\n    this._from = Number.MAX_VALUE;\n    this._to = -Number.MAX_VALUE;\n    this._speedRatio = 1;\n    this._loopAnimation = false;\n    this._isAdditive = false;\n    this._weight = -1;\n    this._playOrder = 0;\n    this._enableBlending = null;\n    this._blendingSpeed = null;\n    this._numActiveAnimatables = 0;\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * This observable will notify when one animation have ended\n     */\n    this.onAnimationEndObservable = new Observable();\n    /**\n     * Observer raised when one animation loops\n     */\n    this.onAnimationLoopObservable = new Observable();\n    /**\n     * Observer raised when all animations have looped\n     */\n    this.onAnimationGroupLoopObservable = new Observable();\n    /**\n     * This observable will notify when all animations have ended.\n     */\n    this.onAnimationGroupEndObservable = new Observable();\n    /**\n     * This observable will notify when all animations have paused.\n     */\n    this.onAnimationGroupPauseObservable = new Observable();\n    /**\n     * This observable will notify when all animations are playing.\n     */\n    this.onAnimationGroupPlayObservable = new Observable();\n    /**\n     * Gets or sets an object used to store user defined information for the node\n     */\n    this.metadata = null;\n    this._animationLoopFlags = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._weight = weight;\n    this._playOrder = playOrder;\n    this.uniqueId = this._scene.getUniqueId();\n    this._scene.addAnimationGroup(this);\n  }\n  /**\n   * Add an animation (with its target) in the group\n   * @param animation defines the animation we want to add\n   * @param target defines the target of the animation\n   * @returns the TargetedAnimation object\n   */\n  addTargetedAnimation(animation, target) {\n    const targetedAnimation = new TargetedAnimation();\n    targetedAnimation.animation = animation;\n    targetedAnimation.target = target;\n    const keys = animation.getKeys();\n    if (this._from > keys[0].frame) {\n      this._from = keys[0].frame;\n    }\n    if (this._to < keys[keys.length - 1].frame) {\n      this._to = keys[keys.length - 1].frame;\n    }\n    if (this._enableBlending !== null) {\n      animation.enableBlending = this._enableBlending;\n    }\n    if (this._blendingSpeed !== null) {\n      animation.blendingSpeed = this._blendingSpeed;\n    }\n    this._targetedAnimations.push(targetedAnimation);\n    return targetedAnimation;\n  }\n  /**\n   * Remove an animation from the group\n   * @param animation defines the animation we want to remove\n   */\n  removeTargetedAnimation(animation) {\n    for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\n      const targetedAnimation = this._targetedAnimations[index];\n      if (targetedAnimation.animation === animation) {\n        this._targetedAnimations.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n   * It can add constant keys at begin or end\n   * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n   * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n   * @returns the animation group\n   */\n  normalize(beginFrame = null, endFrame = null) {\n    if (beginFrame == null) {\n      beginFrame = this._from;\n    }\n    if (endFrame == null) {\n      endFrame = this._to;\n    }\n    for (let index = 0; index < this._targetedAnimations.length; index++) {\n      const targetedAnimation = this._targetedAnimations[index];\n      const keys = targetedAnimation.animation.getKeys();\n      const startKey = keys[0];\n      const endKey = keys[keys.length - 1];\n      if (startKey.frame > beginFrame) {\n        const newKey = {\n          frame: beginFrame,\n          value: startKey.value,\n          inTangent: startKey.inTangent,\n          outTangent: startKey.outTangent,\n          interpolation: startKey.interpolation\n        };\n        keys.splice(0, 0, newKey);\n      }\n      if (endKey.frame < endFrame) {\n        const newKey = {\n          frame: endFrame,\n          value: endKey.value,\n          inTangent: endKey.inTangent,\n          outTangent: endKey.outTangent,\n          interpolation: endKey.interpolation\n        };\n        keys.push(newKey);\n      }\n    }\n    this._from = beginFrame;\n    this._to = endFrame;\n    return this;\n  }\n  _processLoop(animatable, targetedAnimation, index) {\n    animatable.onAnimationLoop = () => {\n      this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n      if (this._animationLoopFlags[index]) {\n        return;\n      }\n      this._animationLoopFlags[index] = true;\n      this._animationLoopCount++;\n      if (this._animationLoopCount === this._numActiveAnimatables) {\n        this.onAnimationGroupLoopObservable.notifyObservers(this);\n        this._animationLoopCount = 0;\n        this._animationLoopFlags.length = 0;\n      }\n    };\n  }\n  /**\n   * Start all animations on given targets\n   * @param loop defines if animations must loop\n   * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n   * @param from defines the from key (optional)\n   * @param to defines the to key (optional)\n   * @param isAdditive defines the additive state for the resulting animatables (optional)\n   * @returns the current animation group\n   */\n  start(loop = false, speedRatio = 1, from, to, isAdditive) {\n    if (this._isStarted || this._targetedAnimations.length === 0) {\n      return this;\n    }\n    this._loopAnimation = loop;\n    this._animationLoopCount = 0;\n    this._animationLoopFlags.length = 0;\n    for (let index = 0; index < this._targetedAnimations.length; index++) {\n      const targetedAnimation = this._targetedAnimations[index];\n      const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this._from, to !== undefined ? to : this._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this._isAdditive);\n      animatable.weight = this._weight;\n      animatable.playOrder = this._playOrder;\n      animatable.onAnimationEnd = () => {\n        this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n        this._checkAnimationGroupEnded(animatable);\n      };\n      this._processLoop(animatable, targetedAnimation, index);\n      this._animatables.push(animatable);\n    }\n    this.syncWithMask();\n    this._scene.sortActiveAnimatables();\n    this._speedRatio = speedRatio;\n    this._isStarted = true;\n    this._isPaused = false;\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Pause all animations\n   * @returns the animation group\n   */\n  pause() {\n    if (!this._isStarted) {\n      return this;\n    }\n    this._isPaused = true;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.pause();\n    }\n    this.onAnimationGroupPauseObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Play all animations to initial state\n   * This function will start() the animations if they were not started or will restart() them if they were paused\n   * @param loop defines if animations must loop\n   * @returns the animation group\n   */\n  play(loop) {\n    // only if all animatables are ready and exist\n    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\n      if (loop !== undefined) {\n        this.loopAnimation = loop;\n      }\n      this.restart();\n    } else {\n      this.stop();\n      this.start(loop, this._speedRatio);\n    }\n    this._isPaused = false;\n    return this;\n  }\n  /**\n   * Reset all animations to initial state\n   * @returns the animation group\n   */\n  reset() {\n    if (!this._isStarted) {\n      this.play();\n      this.goToFrame(0);\n      this.stop();\n      return this;\n    }\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.reset();\n    }\n    return this;\n  }\n  /**\n   * Restart animations from key 0\n   * @returns the animation group\n   */\n  restart() {\n    if (!this._isStarted) {\n      return this;\n    }\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.restart();\n    }\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Stop all animations\n   * @returns the animation group\n   */\n  stop() {\n    if (!this._isStarted) {\n      return this;\n    }\n    const list = this._animatables.slice();\n    for (let index = 0; index < list.length; index++) {\n      list[index].stop(undefined, undefined, true);\n    }\n    // We will take care of removing all stopped animatables\n    let curIndex = 0;\n    for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\n      const animatable = this._scene._activeAnimatables[index];\n      if (animatable._runtimeAnimations.length > 0) {\n        this._scene._activeAnimatables[curIndex++] = animatable;\n      }\n    }\n    this._scene._activeAnimatables.length = curIndex;\n    this._isStarted = false;\n    return this;\n  }\n  /**\n   * Set animation weight for all animatables\n   *\n   * @since 6.12.4\n   *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\n   *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\n   * @param weight defines the weight to use\n   * @returns the animationGroup\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n   */\n  setWeightForAllAnimatables(weight) {\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.weight = weight;\n    }\n    return this;\n  }\n  /**\n   * Synchronize and normalize all animatables with a source animatable\n   * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n   * @returns the animationGroup\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n   */\n  syncAllAnimationsWith(root) {\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.syncWith(root);\n    }\n    return this;\n  }\n  /**\n   * Goes to a specific frame in this animation group\n   * @param frame the frame number to go to\n   * @returns the animationGroup\n   */\n  goToFrame(frame) {\n    if (!this._isStarted) {\n      return this;\n    }\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.goToFrame(frame);\n    }\n    return this;\n  }\n  /**\n   * Dispose all associated resources\n   */\n  dispose() {\n    this._targetedAnimations.length = 0;\n    this._animatables.length = 0;\n    // Remove from scene\n    const index = this._scene.animationGroups.indexOf(this);\n    if (index > -1) {\n      this._scene.animationGroups.splice(index, 1);\n    }\n    if (this._parentContainer) {\n      const index = this._parentContainer.animationGroups.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.animationGroups.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    this.onAnimationEndObservable.clear();\n    this.onAnimationGroupEndObservable.clear();\n    this.onAnimationGroupPauseObservable.clear();\n    this.onAnimationGroupPlayObservable.clear();\n    this.onAnimationLoopObservable.clear();\n    this.onAnimationGroupLoopObservable.clear();\n  }\n  _checkAnimationGroupEnded(animatable) {\n    // animatable should be taken out of the array\n    const idx = this._animatables.indexOf(animatable);\n    if (idx > -1) {\n      this._animatables.splice(idx, 1);\n    }\n    // all animatables were removed? animation group ended!\n    if (this._animatables.length === 0) {\n      this._isStarted = false;\n      this.onAnimationGroupEndObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Clone the current animation group and returns a copy\n   * @param newName defines the name of the new group\n   * @param targetConverter defines an optional function used to convert current animation targets to new ones\n   * @param cloneAnimations defines if the animations should be cloned or referenced\n   * @returns the new animation group\n   */\n  clone(newName, targetConverter, cloneAnimations = false) {\n    const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\n    newGroup._from = this.from;\n    newGroup._to = this.to;\n    newGroup._speedRatio = this.speedRatio;\n    newGroup._loopAnimation = this.loopAnimation;\n    newGroup._isAdditive = this.isAdditive;\n    newGroup._enableBlending = this.enableBlending;\n    newGroup._blendingSpeed = this.blendingSpeed;\n    newGroup.metadata = this.metadata;\n    newGroup.mask = this.mask;\n    for (const targetAnimation of this._targetedAnimations) {\n      newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n    }\n    return newGroup;\n  }\n  /**\n   * Serializes the animationGroup to an object\n   * @returns Serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.from = this.from;\n    serializationObject.to = this.to;\n    serializationObject.speedRatio = this.speedRatio;\n    serializationObject.loopAnimation = this.loopAnimation;\n    serializationObject.isAdditive = this.isAdditive;\n    serializationObject.weight = this.weight;\n    serializationObject.playOrder = this.playOrder;\n    serializationObject.enableBlending = this.enableBlending;\n    serializationObject.blendingSpeed = this.blendingSpeed;\n    serializationObject.targetedAnimations = [];\n    for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n      const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n    }\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    // Metadata\n    if (this.metadata) {\n      serializationObject.metadata = this.metadata;\n    }\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Returns a new AnimationGroup object parsed from the source provided.\n   * @param parsedAnimationGroup defines the source\n   * @param scene defines the scene that will receive the animationGroup\n   * @returns a new AnimationGroup\n   */\n  static Parse(parsedAnimationGroup, scene) {\n    const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\n    for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n      const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n      const animation = Animation.Parse(targetedAnimation.animation);\n      const id = targetedAnimation.targetId;\n      if (targetedAnimation.animation.property === \"influence\") {\n        // morph target animation\n        const morphTarget = scene.getMorphTargetById(id);\n        if (morphTarget) {\n          animationGroup.addTargetedAnimation(animation, morphTarget);\n        }\n      } else {\n        const targetNode = scene.getNodeById(id);\n        if (targetNode != null) {\n          animationGroup.addTargetedAnimation(animation, targetNode);\n        }\n      }\n    }\n    if (Tags) {\n      Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n    }\n    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n    }\n    if (parsedAnimationGroup.speedRatio !== undefined) {\n      animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\n    }\n    if (parsedAnimationGroup.loopAnimation !== undefined) {\n      animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\n    }\n    if (parsedAnimationGroup.isAdditive !== undefined) {\n      animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\n    }\n    if (parsedAnimationGroup.weight !== undefined) {\n      animationGroup._weight = parsedAnimationGroup.weight;\n    }\n    if (parsedAnimationGroup.playOrder !== undefined) {\n      animationGroup._playOrder = parsedAnimationGroup.playOrder;\n    }\n    if (parsedAnimationGroup.enableBlending !== undefined) {\n      animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\n    }\n    if (parsedAnimationGroup.blendingSpeed !== undefined) {\n      animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\n    }\n    if (parsedAnimationGroup.metadata !== undefined) {\n      animationGroup.metadata = parsedAnimationGroup.metadata;\n    }\n    return animationGroup;\n  }\n  /** @internal */\n  static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n    let options;\n    if (typeof referenceFrameOrOptions === \"object\") {\n      options = referenceFrameOrOptions;\n    } else {\n      options = {\n        referenceFrame: referenceFrameOrOptions,\n        range: range,\n        cloneOriginalAnimationGroup: cloneOriginal,\n        clonedAnimationName: clonedName\n      };\n    }\n    let animationGroup = sourceAnimationGroup;\n    if (options.cloneOriginalAnimationGroup) {\n      animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\n    }\n    const targetedAnimations = animationGroup.targetedAnimations;\n    for (let index = 0; index < targetedAnimations.length; index++) {\n      const targetedAnimation = targetedAnimations[index];\n      targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\n    }\n    animationGroup.isAdditive = true;\n    if (options.clipKeys) {\n      // We need to recalculate the from/to frames for the animation group because some keys may have been removed\n      let from = Number.MAX_VALUE;\n      let to = -Number.MAX_VALUE;\n      const targetedAnimations = animationGroup.targetedAnimations;\n      for (let index = 0; index < targetedAnimations.length; index++) {\n        const targetedAnimation = targetedAnimations[index];\n        const animation = targetedAnimation.animation;\n        const keys = animation.getKeys();\n        if (from > keys[0].frame) {\n          from = keys[0].frame;\n        }\n        if (to < keys[keys.length - 1].frame) {\n          to = keys[keys.length - 1].frame;\n        }\n      }\n      animationGroup._from = from;\n      animationGroup._to = to;\n    }\n    return animationGroup;\n  }\n  /**\n   * Creates a new animation, keeping only the keys that are inside a given key range\n   * @param sourceAnimationGroup defines the animation group on which to operate\n   * @param fromKey defines the lower bound of the range\n   * @param toKey defines the upper bound of the range\n   * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n   * @returns a new animation group stripped from all the keys outside the given range\n   */\n  static ClipKeys(sourceAnimationGroup, fromKey, toKey, name, dontCloneAnimations) {\n    const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n    return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\n  }\n  /**\n   * Updates an existing animation, keeping only the keys that are inside a given key range\n   * @param animationGroup defines the animation group on which to operate\n   * @param fromKey defines the lower bound of the range\n   * @param toKey defines the upper bound of the range\n   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n   * @returns the animationGroup stripped from all the keys outside the given range\n   */\n  static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {\n    return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\n  }\n  /**\n   * Creates a new animation, keeping only the frames that are inside a given frame range\n   * @param sourceAnimationGroup defines the animation group on which to operate\n   * @param fromFrame defines the lower bound of the range\n   * @param toFrame defines the upper bound of the range\n   * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n   * @returns a new animation group stripped from all the frames outside the given range\n   */\n  static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name, dontCloneAnimations) {\n    const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n    return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\n  }\n  /**\n   * Updates an existing animation, keeping only the frames that are inside a given frame range\n   * @param animationGroup defines the animation group on which to operate\n   * @param fromFrame defines the lower bound of the range\n   * @param toFrame defines the upper bound of the range\n   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n   * @returns the animationGroup stripped from all the frames outside the given range\n   */\n  static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {\n    return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\n  }\n  /**\n   * Updates an existing animation, keeping only the keys that are inside a given key or frame range\n   * @param animationGroup defines the animation group on which to operate\n   * @param start defines the lower bound of the range\n   * @param end defines the upper bound of the range\n   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n   * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\n   * @returns the animationGroup stripped from all the keys outside the given range\n   */\n  static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {\n    let from = Number.MAX_VALUE;\n    let to = -Number.MAX_VALUE;\n    const targetedAnimations = animationGroup.targetedAnimations;\n    for (let index = 0; index < targetedAnimations.length; index++) {\n      const targetedAnimation = targetedAnimations[index];\n      const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\n      if (useFrame) {\n        // Make sure we have keys corresponding to the bounds of the frame range\n        animation.createKeyForFrame(start);\n        animation.createKeyForFrame(end);\n      }\n      const keys = animation.getKeys();\n      const newKeys = [];\n      let startFrame = Number.MAX_VALUE;\n      for (let k = 0; k < keys.length; k++) {\n        const key = keys[k];\n        if (!useFrame && k >= start && k <= end || useFrame && key.frame >= start && key.frame <= end) {\n          const newKey = {\n            frame: key.frame,\n            value: key.value.clone ? key.value.clone() : key.value,\n            inTangent: key.inTangent,\n            outTangent: key.outTangent,\n            interpolation: key.interpolation,\n            lockedTangent: key.lockedTangent\n          };\n          if (startFrame === Number.MAX_VALUE) {\n            startFrame = newKey.frame;\n          }\n          newKey.frame -= startFrame;\n          newKeys.push(newKey);\n        }\n      }\n      if (newKeys.length === 0) {\n        targetedAnimations.splice(index, 1);\n        index--;\n        continue;\n      }\n      if (from > newKeys[0].frame) {\n        from = newKeys[0].frame;\n      }\n      if (to < newKeys[newKeys.length - 1].frame) {\n        to = newKeys[newKeys.length - 1].frame;\n      }\n      animation.setKeys(newKeys, true);\n      targetedAnimation.animation = animation; // in case the animation has been cloned\n    }\n\n    animationGroup._from = from;\n    animationGroup._to = to;\n    return animationGroup;\n  }\n  /**\n   * Returns the string \"AnimationGroup\"\n   * @returns \"AnimationGroup\"\n   */\n  getClassName() {\n    return \"AnimationGroup\";\n  }\n  /**\n   * Creates a detailed string about the object\n   * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n   * @returns a string representing the object\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    ret += \", type: \" + this.getClassName();\n    if (fullDetails) {\n      ret += \", from: \" + this._from;\n      ret += \", to: \" + this._to;\n      ret += \", isStarted: \" + this._isStarted;\n      ret += \", speedRatio: \" + this._speedRatio;\n      ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n      ret += \", animatables length: \" + this._animatables;\n    }\n    return ret;\n  }\n}","map":{"version":3,"names":["Animation","Observable","EngineStore","Tags","TargetedAnimation","getClassName","serialize","serializationObject","animation","targetId","target","id","AnimationGroup","syncWithMask","mask","_numActiveAnimatables","_targetedAnimations","length","i","_animatables","animatable","retainsTarget","name","paused","restart","pause","removeUnmaskedAnimations","stop","splice","index","targetedAnimation","from","_from","to","_to","isStarted","_isStarted","isPlaying","_isPaused","speedRatio","_speedRatio","value","loopAnimation","_loopAnimation","isAdditive","_isAdditive","weight","_weight","setWeightForAllAnimatables","targetedAnimations","animatables","children","playOrder","_playOrder","_scene","sortActiveAnimatables","enableBlending","_enableBlending","blendingSpeed","_blendingSpeed","getLength","fps","framePerSecond","MergeAnimationGroups","animationGroups","disposeSource","normalize","beginFrame","Number","MAX_VALUE","endFrame","animationGroup","mergedAnimationGroup","addTargetedAnimation","dispose","constructor","scene","Array","_parentContainer","onAnimationEndObservable","onAnimationLoopObservable","onAnimationGroupLoopObservable","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","onAnimationGroupPlayObservable","metadata","_animationLoopFlags","LastCreatedScene","uniqueId","getUniqueId","addAnimationGroup","keys","getKeys","frame","push","removeTargetedAnimation","startKey","endKey","newKey","inTangent","outTangent","interpolation","_processLoop","onAnimationLoop","notifyObservers","_animationLoopCount","start","loop","beginDirectAnimation","undefined","onAnimationEnd","_checkAnimationGroupEnded","play","reset","goToFrame","list","slice","curIndex","_activeAnimatables","_runtimeAnimations","syncAllAnimationsWith","root","syncWith","indexOf","clear","idx","clone","newName","targetConverter","cloneAnimations","newGroup","targetAnimation","targetedAnimationIndex","HasTags","tags","GetTags","Parse","parsedAnimationGroup","property","morphTarget","getMorphTargetById","targetNode","getNodeById","AddTagsTo","MakeAnimationAdditive","sourceAnimationGroup","referenceFrameOrOptions","range","cloneOriginal","clonedName","options","referenceFrame","cloneOriginalAnimationGroup","clonedAnimationName","clonedAnimationGroupName","clipKeys","ClipKeys","fromKey","toKey","dontCloneAnimations","ClipKeysInPlace","ClipInPlace","ClipFrames","fromFrame","toFrame","ClipFramesInPlace","end","useFrame","createKeyForFrame","newKeys","startFrame","k","key","lockedTangent","setKeys","toString","fullDetails","ret"],"sources":["../../../../dev/core/src/Animations/animationGroup.ts"],"sourcesContent":["import type { Animatable } from \"./animatable\";\r\nimport { Animation } from \"./animation\";\r\nimport type { IMakeAnimationAdditiveOptions } from \"./animation\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { AnimationGroupMask } from \"./animationGroupMask\";\r\n\r\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\r\nexport class TargetedAnimation {\r\n    /**\r\n     * Animation to perform\r\n     */\r\n    public animation: Animation;\r\n    /**\r\n     * Target to animate\r\n     */\r\n    public target: any;\r\n\r\n    /**\r\n     * Returns the string \"TargetedAnimation\"\r\n     * @returns \"TargetedAnimation\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetedAnimation\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the object\r\n     * @returns the JSON object representing the current entity\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.animation = this.animation.serialize();\r\n        serializationObject.targetId = this.target.id;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n/**\r\n * Options to be used when creating an additive group animation\r\n */\r\nexport interface IMakeAnimationGroupAdditiveOptions extends IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * Defines if the animation group should be cloned or not (default is false)\r\n     */\r\n    cloneOriginalAnimationGroup?: boolean;\r\n    /**\r\n     * The name of the cloned animation group if cloneOriginalAnimationGroup is true\r\n     */\r\n    clonedAnimationGroupName?: string;\r\n}\r\n\r\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\r\nexport class AnimationGroup implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    private _targetedAnimations = new Array<TargetedAnimation>();\r\n    private _animatables = new Array<Animatable>();\r\n    private _from = Number.MAX_VALUE;\r\n    private _to = -Number.MAX_VALUE;\r\n    private _isStarted: boolean;\r\n    private _isPaused: boolean;\r\n    private _speedRatio = 1;\r\n    private _loopAnimation = false;\r\n    private _isAdditive = false;\r\n    private _weight = -1;\r\n    private _playOrder = 0;\r\n    private _enableBlending: Nullable<boolean> = null;\r\n    private _blendingSpeed: Nullable<number> = null;\r\n    private _numActiveAnimatables = 0;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\r\n    public onAnimationEndObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when one animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\r\n    public onAnimationGroupLoopObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\r\n    public onAnimationGroupEndObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\r\n    public onAnimationGroupPauseObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\r\n    public onAnimationGroupPlayObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\r\n     */\r\n    public mask?: AnimationGroupMask;\r\n\r\n    /**\r\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\r\n     * Note however that the call won't have any effect if the animation group has not been started yet.\r\n     * You should call this function if you modify the mask after the animation group has been started.\r\n     */\r\n    public syncWithMask() {\r\n        if (!this.mask) {\r\n            this._numActiveAnimatables = this._targetedAnimations.length;\r\n            return;\r\n        }\r\n\r\n        this._numActiveAnimatables = 0;\r\n\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (this.mask.retainsTarget(animatable.target.name)) {\r\n                this._numActiveAnimatables++;\r\n                if (animatable.paused) {\r\n                    animatable.restart();\r\n                }\r\n            } else {\r\n                if (!animatable.paused) {\r\n                    animatable.pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animations for the targets not retained by the animation group mask.\r\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\r\n     */\r\n    public removeUnmaskedAnimations() {\r\n        if (!this.mask) {\r\n            return;\r\n        }\r\n\r\n        // Removes all animatables (in case the animation group has already been started)\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (!this.mask.retainsTarget(animatable.target.name)) {\r\n                animatable.stop();\r\n                this._animatables.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n\r\n        // Removes the targeted animations\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n\r\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\r\n                this._targetedAnimations.splice(index, 1);\r\n                --index;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the first frame\r\n     */\r\n    public get from(): number {\r\n        return this._from;\r\n    }\r\n\r\n    /**\r\n     * Gets the last frame\r\n     */\r\n    public get to(): number {\r\n        return this._to;\r\n    }\r\n\r\n    /**\r\n     * Define if the animations are started\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._isStarted && !this._isPaused;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        if (this._speedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._speedRatio = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.speedRatio = this._speedRatio;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\r\n    public get loopAnimation(): boolean {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    public set loopAnimation(value: boolean) {\r\n        if (this._loopAnimation === value) {\r\n            return;\r\n        }\r\n\r\n        this._loopAnimation = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.loopAnimation = this._loopAnimation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._isAdditive;\r\n    }\r\n\r\n    public set isAdditive(value: boolean) {\r\n        if (this._isAdditive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isAdditive = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.isAdditive = this._isAdditive;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the weight to apply to all animations of the group\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (this._weight === value) {\r\n            return;\r\n        }\r\n\r\n        this._weight = value;\r\n        this.setWeightForAllAnimatables(this._weight);\r\n    }\r\n\r\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\r\n    public get targetedAnimations(): Array<TargetedAnimation> {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\r\n    public get animatables(): Array<Animatable> {\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of target animations\r\n     */\r\n    public get children() {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the order of play of the animation group (default: 0)\r\n     */\r\n    public get playOrder() {\r\n        return this._playOrder;\r\n    }\r\n\r\n    public set playOrder(value: number) {\r\n        if (this._playOrder === value) {\r\n            return;\r\n        }\r\n\r\n        this._playOrder = value;\r\n\r\n        if (this._animatables.length > 0) {\r\n            for (let i = 0; i < this._animatables.length; i++) {\r\n                this._animatables[i].playOrder = this._playOrder;\r\n            }\r\n\r\n            this._scene.sortActiveAnimatables();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows the animations of the animation group to blend with current running animations\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\r\n     */\r\n    public get enableBlending() {\r\n        return this._enableBlending;\r\n    }\r\n\r\n    public set enableBlending(value: Nullable<boolean>) {\r\n        if (this._enableBlending === value) {\r\n            return;\r\n        }\r\n\r\n        this._enableBlending = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.enableBlending = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animation blending speed\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\r\n     */\r\n    public get blendingSpeed() {\r\n        return this._blendingSpeed;\r\n    }\r\n\r\n    public set blendingSpeed(value: Nullable<number>) {\r\n        if (this._blendingSpeed === value) {\r\n            return;\r\n        }\r\n\r\n        this._blendingSpeed = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.blendingSpeed = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length (in seconds) of the animation group\r\n     * This function assumes that all animations are played at the same framePerSecond speed!\r\n     * Note: you can only call this method after you've added at least one targeted animation!\r\n     * @param from Starting frame range (default is AnimationGroup.from)\r\n     * @param to Ending frame range (default is AnimationGroup.to)\r\n     * @returns The length in seconds\r\n     */\r\n    public getLength(from?: number, to?: number): number {\r\n        from = from ?? this._from;\r\n        to = to ?? this._to;\r\n\r\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\r\n\r\n        return (to - from) / fps;\r\n    }\r\n\r\n    /**\r\n     * Merge the array of animation groups into a new animation group\r\n     * @param animationGroups List of animation groups to merge\r\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\r\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\r\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\r\n     * @returns The new animation group or null if no animation groups were passed\r\n     */\r\n    public static MergeAnimationGroups(animationGroups: Array<AnimationGroup>, disposeSource = true, normalize = false, weight?: number): Nullable<AnimationGroup> {\r\n        if (animationGroups.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        weight = weight ?? animationGroups[0].weight;\r\n\r\n        let beginFrame = Number.MAX_VALUE;\r\n        let endFrame = -Number.MAX_VALUE;\r\n\r\n        if (normalize) {\r\n            for (const animationGroup of animationGroups) {\r\n                if (animationGroup.from < beginFrame) {\r\n                    beginFrame = animationGroup.from;\r\n                }\r\n\r\n                if (animationGroup.to > endFrame) {\r\n                    endFrame = animationGroup.to;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\r\n\r\n        for (const animationGroup of animationGroups) {\r\n            if (normalize) {\r\n                animationGroup.normalize(beginFrame, endFrame);\r\n            }\r\n\r\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\r\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\r\n            }\r\n\r\n            if (disposeSource) {\r\n                animationGroup.dispose();\r\n            }\r\n        }\r\n\r\n        return mergedAnimationGroup;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Animation Group.\r\n     * This helps managing several animations at once.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     * @param name Defines the name of the group\r\n     * @param scene Defines the scene the group belongs to\r\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\r\n     * @param playOrder Defines the order of play of the animation group (default is 0)\r\n     */\r\n    public constructor(\r\n        /** The name of the animation group */\r\n        public name: string,\r\n        scene: Nullable<Scene> = null,\r\n        weight = -1,\r\n        playOrder = 0\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this._weight = weight;\r\n        this._playOrder = playOrder;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addAnimationGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Add an animation (with its target) in the group\r\n     * @param animation defines the animation we want to add\r\n     * @param target defines the target of the animation\r\n     * @returns the TargetedAnimation object\r\n     */\r\n    public addTargetedAnimation(animation: Animation, target: any): TargetedAnimation {\r\n        const targetedAnimation = new TargetedAnimation();\r\n        targetedAnimation.animation = animation;\r\n        targetedAnimation.target = target;\r\n\r\n        const keys = animation.getKeys();\r\n        if (this._from > keys[0].frame) {\r\n            this._from = keys[0].frame;\r\n        }\r\n\r\n        if (this._to < keys[keys.length - 1].frame) {\r\n            this._to = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        if (this._enableBlending !== null) {\r\n            animation.enableBlending = this._enableBlending;\r\n        }\r\n\r\n        if (this._blendingSpeed !== null) {\r\n            animation.blendingSpeed = this._blendingSpeed;\r\n        }\r\n\r\n        this._targetedAnimations.push(targetedAnimation);\r\n\r\n        return targetedAnimation;\r\n    }\r\n\r\n    /**\r\n     * Remove an animation from the group\r\n     * @param animation defines the animation we want to remove\r\n     */\r\n    public removeTargetedAnimation(animation: Animation) {\r\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            if (targetedAnimation.animation === animation) {\r\n                this._targetedAnimations.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n     * It can add constant keys at begin or end\r\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n     * @returns the animation group\r\n     */\r\n    public normalize(beginFrame: Nullable<number> = null, endFrame: Nullable<number> = null): AnimationGroup {\r\n        if (beginFrame == null) {\r\n            beginFrame = this._from;\r\n        }\r\n        if (endFrame == null) {\r\n            endFrame = this._to;\r\n        }\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const keys = targetedAnimation.animation.getKeys();\r\n            const startKey = keys[0];\r\n            const endKey = keys[keys.length - 1];\r\n\r\n            if (startKey.frame > beginFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: beginFrame,\r\n                    value: startKey.value,\r\n                    inTangent: startKey.inTangent,\r\n                    outTangent: startKey.outTangent,\r\n                    interpolation: startKey.interpolation,\r\n                };\r\n                keys.splice(0, 0, newKey);\r\n            }\r\n\r\n            if (endKey.frame < endFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: endFrame,\r\n                    value: endKey.value,\r\n                    inTangent: endKey.inTangent,\r\n                    outTangent: endKey.outTangent,\r\n                    interpolation: endKey.interpolation,\r\n                };\r\n                keys.push(newKey);\r\n            }\r\n        }\r\n\r\n        this._from = beginFrame;\r\n        this._to = endFrame;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _animationLoopCount: number;\r\n    private _animationLoopFlags: boolean[] = [];\r\n\r\n    private _processLoop(animatable: Animatable, targetedAnimation: TargetedAnimation, index: number) {\r\n        animatable.onAnimationLoop = () => {\r\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\r\n\r\n            if (this._animationLoopFlags[index]) {\r\n                return;\r\n            }\r\n\r\n            this._animationLoopFlags[index] = true;\r\n\r\n            this._animationLoopCount++;\r\n            if (this._animationLoopCount === this._numActiveAnimatables) {\r\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\r\n                this._animationLoopCount = 0;\r\n                this._animationLoopFlags.length = 0;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start all animations on given targets\r\n     * @param loop defines if animations must loop\r\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n     * @param from defines the from key (optional)\r\n     * @param to defines the to key (optional)\r\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n     * @returns the current animation group\r\n     */\r\n    public start(loop = false, speedRatio = 1, from?: number, to?: number, isAdditive?: boolean): AnimationGroup {\r\n        if (this._isStarted || this._targetedAnimations.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        this._loopAnimation = loop;\r\n\r\n        this._animationLoopCount = 0;\r\n        this._animationLoopFlags.length = 0;\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const animatable = this._scene.beginDirectAnimation(\r\n                targetedAnimation.target,\r\n                [targetedAnimation.animation],\r\n                from !== undefined ? from : this._from,\r\n                to !== undefined ? to : this._to,\r\n                loop,\r\n                speedRatio,\r\n                undefined,\r\n                undefined,\r\n                isAdditive !== undefined ? isAdditive : this._isAdditive\r\n            );\r\n            animatable.weight = this._weight;\r\n            animatable.playOrder = this._playOrder;\r\n            animatable.onAnimationEnd = () => {\r\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\r\n                this._checkAnimationGroupEnded(animatable);\r\n            };\r\n\r\n            this._processLoop(animatable, targetedAnimation, index);\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        this.syncWithMask();\r\n\r\n        this._scene.sortActiveAnimatables();\r\n\r\n        this._speedRatio = speedRatio;\r\n\r\n        this._isStarted = true;\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause all animations\r\n     * @returns the animation group\r\n     */\r\n    public pause(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        this._isPaused = true;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.pause();\r\n        }\r\n\r\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play all animations to initial state\r\n     * This function will start() the animations if they were not started or will restart() them if they were paused\r\n     * @param loop defines if animations must loop\r\n     * @returns the animation group\r\n     */\r\n    public play(loop?: boolean): AnimationGroup {\r\n        // only if all animatables are ready and exist\r\n        if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\r\n            if (loop !== undefined) {\r\n                this.loopAnimation = loop;\r\n            }\r\n            this.restart();\r\n        } else {\r\n            this.stop();\r\n            this.start(loop, this._speedRatio);\r\n        }\r\n\r\n        this._isPaused = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all animations to initial state\r\n     * @returns the animation group\r\n     */\r\n    public reset(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            this.play();\r\n            this.goToFrame(0);\r\n            this.stop();\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restart animations from key 0\r\n     * @returns the animation group\r\n     */\r\n    public restart(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.restart();\r\n        }\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop all animations\r\n     * @returns the animation group\r\n     */\r\n    public stop(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        const list = this._animatables.slice();\r\n        for (let index = 0; index < list.length; index++) {\r\n            list[index].stop(undefined, undefined, true);\r\n        }\r\n\r\n        // We will take care of removing all stopped animatables\r\n        let curIndex = 0;\r\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\r\n            const animatable = this._scene._activeAnimatables[index];\r\n            if (animatable._runtimeAnimations.length > 0) {\r\n                this._scene._activeAnimatables[curIndex++] = animatable;\r\n            }\r\n        }\r\n        this._scene._activeAnimatables.length = curIndex;\r\n\r\n        this._isStarted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set animation weight for all animatables\r\n     *\r\n     * @since 6.12.4\r\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\r\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\r\n     * @param weight defines the weight to use\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public setWeightForAllAnimatables(weight: number): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.weight = weight;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synchronize and normalize all animatables with a source animatable\r\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public syncAllAnimationsWith(root: Nullable<Animatable>): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.syncWith(root);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Goes to a specific frame in this animation group\r\n     * @param frame the frame number to go to\r\n     * @returns the animationGroup\r\n     */\r\n    public goToFrame(frame: number): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.goToFrame(frame);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Dispose all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._targetedAnimations.length = 0;\r\n        this._animatables.length = 0;\r\n\r\n        // Remove from scene\r\n        const index = this._scene.animationGroups.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._scene.animationGroups.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.animationGroups.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.animationGroups.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAnimationEndObservable.clear();\r\n        this.onAnimationGroupEndObservable.clear();\r\n        this.onAnimationGroupPauseObservable.clear();\r\n        this.onAnimationGroupPlayObservable.clear();\r\n        this.onAnimationLoopObservable.clear();\r\n        this.onAnimationGroupLoopObservable.clear();\r\n    }\r\n\r\n    private _checkAnimationGroupEnded(animatable: Animatable) {\r\n        // animatable should be taken out of the array\r\n        const idx = this._animatables.indexOf(animatable);\r\n        if (idx > -1) {\r\n            this._animatables.splice(idx, 1);\r\n        }\r\n\r\n        // all animatables were removed? animation group ended!\r\n        if (this._animatables.length === 0) {\r\n            this._isStarted = false;\r\n            this.onAnimationGroupEndObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current animation group and returns a copy\r\n     * @param newName defines the name of the new group\r\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n     * @param cloneAnimations defines if the animations should be cloned or referenced\r\n     * @returns the new animation group\r\n     */\r\n    public clone(newName: string, targetConverter?: (oldTarget: any) => any, cloneAnimations = false): AnimationGroup {\r\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\r\n\r\n        newGroup._from = this.from;\r\n        newGroup._to = this.to;\r\n        newGroup._speedRatio = this.speedRatio;\r\n        newGroup._loopAnimation = this.loopAnimation;\r\n        newGroup._isAdditive = this.isAdditive;\r\n        newGroup._enableBlending = this.enableBlending;\r\n        newGroup._blendingSpeed = this.blendingSpeed;\r\n        newGroup.metadata = this.metadata;\r\n        newGroup.mask = this.mask;\r\n\r\n        for (const targetAnimation of this._targetedAnimations) {\r\n            newGroup.addTargetedAnimation(\r\n                cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation,\r\n                targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target\r\n            );\r\n        }\r\n\r\n        return newGroup;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animationGroup to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.from = this.from;\r\n        serializationObject.to = this.to;\r\n        serializationObject.speedRatio = this.speedRatio;\r\n        serializationObject.loopAnimation = this.loopAnimation;\r\n        serializationObject.isAdditive = this.isAdditive;\r\n        serializationObject.weight = this.weight;\r\n        serializationObject.playOrder = this.playOrder;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        serializationObject.targetedAnimations = [];\r\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\r\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\r\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\r\n        }\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new AnimationGroup object parsed from the source provided.\r\n     * @param parsedAnimationGroup defines the source\r\n     * @param scene defines the scene that will receive the animationGroup\r\n     * @returns a new AnimationGroup\r\n     */\r\n    public static Parse(parsedAnimationGroup: any, scene: Scene): AnimationGroup {\r\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\r\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\r\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\r\n            const animation = Animation.Parse(targetedAnimation.animation);\r\n            const id = targetedAnimation.targetId;\r\n            if (targetedAnimation.animation.property === \"influence\") {\r\n                // morph target animation\r\n                const morphTarget = scene.getMorphTargetById(id);\r\n                if (morphTarget) {\r\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\r\n                }\r\n            } else {\r\n                const targetNode = scene.getNodeById(id);\r\n\r\n                if (targetNode != null) {\r\n                    animationGroup.addTargetedAnimation(animation, targetNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\r\n        }\r\n\r\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\r\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\r\n        }\r\n\r\n        if (parsedAnimationGroup.speedRatio !== undefined) {\r\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\r\n        }\r\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\r\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\r\n        }\r\n\r\n        if (parsedAnimationGroup.isAdditive !== undefined) {\r\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\r\n        }\r\n\r\n        if (parsedAnimationGroup.weight !== undefined) {\r\n            animationGroup._weight = parsedAnimationGroup.weight;\r\n        }\r\n\r\n        if (parsedAnimationGroup.playOrder !== undefined) {\r\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\r\n        }\r\n\r\n        if (parsedAnimationGroup.enableBlending !== undefined) {\r\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\r\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\r\n        }\r\n\r\n        if (parsedAnimationGroup.metadata !== undefined) {\r\n            animationGroup.metadata = parsedAnimationGroup.metadata;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n     * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n     * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n     * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame: number, range?: string, cloneOriginal?: boolean, clonedName?: string): AnimationGroup;\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param options defines the options to use when converting keyframes\r\n     * @returns a new AnimationGroup if options.cloneOriginalAnimationGroup is true or the original AnimationGroup if options.cloneOriginalAnimationGroup is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, options?: IMakeAnimationGroupAdditiveOptions): AnimationGroup;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimationGroup: AnimationGroup,\r\n        referenceFrameOrOptions?: number | IMakeAnimationGroupAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): AnimationGroup {\r\n        let options: IMakeAnimationGroupAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions,\r\n                range: range,\r\n                cloneOriginalAnimationGroup: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animationGroup = sourceAnimationGroup;\r\n        if (options.cloneOriginalAnimationGroup) {\r\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\r\n        }\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\r\n        }\r\n\r\n        animationGroup.isAdditive = true;\r\n\r\n        if (options.clipKeys) {\r\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\r\n            let from = Number.MAX_VALUE;\r\n            let to = -Number.MAX_VALUE;\r\n\r\n            const targetedAnimations = animationGroup.targetedAnimations;\r\n            for (let index = 0; index < targetedAnimations.length; index++) {\r\n                const targetedAnimation = targetedAnimations[index];\r\n                const animation = targetedAnimation.animation;\r\n                const keys = animation.getKeys();\r\n\r\n                if (from > keys[0].frame) {\r\n                    from = keys[0].frame;\r\n                }\r\n\r\n                if (to < keys[keys.length - 1].frame) {\r\n                    to = keys[keys.length - 1].frame;\r\n                }\r\n            }\r\n\r\n            animationGroup._from = from;\r\n            animationGroup._to = to;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the keys that are inside a given key range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeys(sourceAnimationGroup: AnimationGroup, fromKey: number, toKey: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeysInPlace(animationGroup: AnimationGroup, fromKey: number, toKey: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the frames that are inside a given frame range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFrames(sourceAnimationGroup: AnimationGroup, fromFrame: number, toFrame: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFramesInPlace(animationGroup: AnimationGroup, fromFrame: number, toFrame: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param start defines the lower bound of the range\r\n     * @param end defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipInPlace(animationGroup: AnimationGroup, start: number, end: number, dontCloneAnimations?: boolean, useFrame = false): AnimationGroup {\r\n        let from = Number.MAX_VALUE;\r\n        let to = -Number.MAX_VALUE;\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\r\n\r\n            if (useFrame) {\r\n                // Make sure we have keys corresponding to the bounds of the frame range\r\n                animation.createKeyForFrame(start);\r\n                animation.createKeyForFrame(end);\r\n            }\r\n\r\n            const keys = animation.getKeys();\r\n            const newKeys: IAnimationKey[] = [];\r\n\r\n            let startFrame = Number.MAX_VALUE;\r\n            for (let k = 0; k < keys.length; k++) {\r\n                const key = keys[k];\r\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\r\n                    const newKey: IAnimationKey = {\r\n                        frame: key.frame,\r\n                        value: key.value.clone ? key.value.clone() : key.value,\r\n                        inTangent: key.inTangent,\r\n                        outTangent: key.outTangent,\r\n                        interpolation: key.interpolation,\r\n                        lockedTangent: key.lockedTangent,\r\n                    };\r\n                    if (startFrame === Number.MAX_VALUE) {\r\n                        startFrame = newKey.frame;\r\n                    }\r\n                    newKey.frame -= startFrame;\r\n                    newKeys.push(newKey);\r\n                }\r\n            }\r\n\r\n            if (newKeys.length === 0) {\r\n                targetedAnimations.splice(index, 1);\r\n                index--;\r\n                continue;\r\n            }\r\n\r\n            if (from > newKeys[0].frame) {\r\n                from = newKeys[0].frame;\r\n            }\r\n\r\n            if (to < newKeys[newKeys.length - 1].frame) {\r\n                to = newKeys[newKeys.length - 1].frame;\r\n            }\r\n\r\n            animation.setKeys(newKeys, true);\r\n            targetedAnimation.animation = animation; // in case the animation has been cloned\r\n        }\r\n\r\n        animationGroup._from = from;\r\n        animationGroup._to = to;\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AnimationGroup\"\r\n     * @returns \"AnimationGroup\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnimationGroup\";\r\n    }\r\n\r\n    /**\r\n     * Creates a detailed string about the object\r\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n     * @returns a string representing the object\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (fullDetails) {\r\n            ret += \", from: \" + this._from;\r\n            ret += \", to: \" + this._to;\r\n            ret += \", isStarted: \" + this._isStarted;\r\n            ret += \", speedRatio: \" + this._speedRatio;\r\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\r\n            ret += \", animatables length: \" + this._animatables;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}