{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the mouse inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraMouseInput {\n  /**\n   * Manage the mouse inputs to control the movement of a free camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   * @param touchEnabled Defines if touch is enabled or not\n   */\n  constructor(\n  /**\n   * Define if touch is enabled in the mouse input\n   */\n  touchEnabled = true) {\n    this.touchEnabled = touchEnabled;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\n     */\n    this.angularSensibility = 2000.0;\n    this._previousPosition = null;\n    /**\n     * Observable for when a pointer move event occurs containing the move offset\n     */\n    this.onPointerMovedObservable = new Observable();\n    /**\n     * @internal\n     * If the camera should be rotated automatically based on pointer movement\n     */\n    this._allowCameraRotation = true;\n    this._currentActiveButton = -1;\n    this._activePointerId = -1;\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    const engine = this.camera.getEngine();\n    const element = engine.getInputElement();\n    if (!this._pointerInput) {\n      this._pointerInput = p => {\n        const evt = p.event;\n        const isTouch = evt.pointerType === \"touch\";\n        if (!this.touchEnabled && isTouch) {\n          return;\n        }\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n          return;\n        }\n        const srcElement = evt.target;\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\n          if (isTouch && this._activePointerId !== -1 || !isTouch && this._currentActiveButton !== -1) {\n            return;\n          }\n          this._activePointerId = evt.pointerId;\n          try {\n            srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);\n          } catch (e) {\n            //Nothing to do with the error. Execution will continue.\n          }\n          if (this._currentActiveButton === -1) {\n            this._currentActiveButton = evt.button;\n          }\n          this._previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n          if (!noPreventDefault) {\n            evt.preventDefault();\n            element && element.focus();\n          }\n          // This is required to move while pointer button is down\n          if (engine.isPointerLock && this._onMouseMove) {\n            this._onMouseMove(p.event);\n          }\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          // If input is touch with a different touch id OR if input is mouse with a different button, return\n          if (isTouch && this._activePointerId !== evt.pointerId || !isTouch && this._currentActiveButton !== evt.button) {\n            return;\n          }\n          try {\n            srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);\n          } catch (e) {\n            //Nothing to do with the error.\n          }\n          this._currentActiveButton = -1;\n          this._previousPosition = null;\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          this._activePointerId = -1;\n        } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\n          if (engine.isPointerLock && this._onMouseMove) {\n            this._onMouseMove(p.event);\n          } else if (this._previousPosition) {\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\n            const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\n            const offsetY = evt.clientY - this._previousPosition.y;\n            if (this._allowCameraRotation) {\n              this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n              this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n            }\n            this.onPointerMovedObservable.notifyObservers({\n              offsetX: offsetX,\n              offsetY: offsetY\n            });\n            this._previousPosition = {\n              x: evt.clientX,\n              y: evt.clientY\n            };\n            if (!noPreventDefault) {\n              evt.preventDefault();\n            }\n          }\n        }\n      };\n    }\n    this._onMouseMove = evt => {\n      if (!engine.isPointerLock) {\n        return;\n      }\n      const handednessMultiplier = this.camera._calculateHandednessMultiplier();\n      const offsetX = evt.movementX * handednessMultiplier;\n      this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n      const offsetY = evt.movementY;\n      this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n      this._previousPosition = null;\n      if (!noPreventDefault) {\n        evt.preventDefault();\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    if (element) {\n      this._contextMenuBind = evt => this.onContextMenu(evt);\n      element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\n    }\n  }\n  /**\n   * Called on JS contextmenu event.\n   * Override this method to provide functionality.\n   * @param evt\n   */\n  onContextMenu(evt) {\n    evt.preventDefault();\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      if (this._contextMenuBind) {\n        const engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\n      }\n      if (this.onPointerMovedObservable) {\n        this.onPointerMovedObservable.clear();\n      }\n      this._observer = null;\n      this._onMouseMove = null;\n      this._previousPosition = null;\n    }\n    this._activePointerId = -1;\n    this._currentActiveButton = -1;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCameraMouseInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"mouse\";\n  }\n}\n__decorate([serialize()], FreeCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], FreeCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;","map":{"version":3,"names":["Observable","serialize","CameraInputTypes","PointerEventTypes","Tools","FreeCameraMouseInput","constructor","touchEnabled","buttons","angularSensibility","_previousPosition","onPointerMovedObservable","_allowCameraRotation","_currentActiveButton","_activePointerId","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","engine","camera","getEngine","element","getInputElement","_pointerInput","p","evt","event","isTouch","pointerType","type","POINTERMOVE","indexOf","button","srcElement","target","POINTERDOWN","pointerId","setPointerCapture","e","x","clientX","y","clientY","preventDefault","focus","isPointerLock","_onMouseMove","POINTERUP","releasePointerCapture","handednessMultiplier","_calculateHandednessMultiplier","offsetX","offsetY","cameraRotation","notifyObservers","movementX","movementY","_observer","getScene","_inputManager","_addCameraPointerObserver","_contextMenuBind","onContextMenu","addEventListener","detachControl","_removeCameraPointerObserver","removeEventListener","clear","getClassName","getSimpleName","__decorate"],"sources":["../../../../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts"],"sourcesContent":["import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            const offsetX = evt.movementX * handednessMultiplier;\r\n\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}