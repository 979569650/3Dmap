{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Matrix, Vector2, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\nconst xpAxis = new Vector3(1, 0, 0);\nconst xnAxis = new Vector3(-1, 0, 0);\nconst ypAxis = new Vector3(0, 1, 0);\nconst ynAxis = new Vector3(0, -1, 0);\nconst zpAxis = new Vector3(0, 0, 1);\nconst znAxis = new Vector3(0, 0, -1);\n/** @internal */\nclass DecalVertex {\n  constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero(), vertexIdx = 0, vertexIdxForBones = 0, localPositionOverride = null, localNormalOverride = null, matrixIndicesOverride = null, matrixWeightsOverride = null) {\n    this.position = position;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertexIdx = vertexIdx;\n    this.vertexIdxForBones = vertexIdxForBones;\n    this.localPositionOverride = localPositionOverride;\n    this.localNormalOverride = localNormalOverride;\n    this.matrixIndicesOverride = matrixIndicesOverride;\n    this.matrixWeightsOverride = matrixWeightsOverride;\n  }\n  clone() {\n    var _a, _b, _c, _d;\n    return new DecalVertex(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, (_a = this.localPositionOverride) === null || _a === void 0 ? void 0 : _a.slice(), (_b = this.localNormalOverride) === null || _b === void 0 ? void 0 : _b.slice(), (_c = this.matrixIndicesOverride) === null || _c === void 0 ? void 0 : _c.slice(), (_d = this.matrixWeightsOverride) === null || _d === void 0 ? void 0 : _d.slice());\n  }\n}\n/**\n * Creates a decal mesh.\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\n * Note: Meshes with morph targets are not supported!\n * @param name defines the name of the mesh\n * @param sourceMesh defines the mesh where the decal must be applied\n * @param options defines the options used to create the mesh\n * @param options.position\n * @param options.normal\n * @param options.size\n * @param options.angle\n * @param options.captureUVS\n * @param options.cullBackFaces\n * @param options.localMode\n * @returns the decal mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\n */\nexport function CreateDecal(name, sourceMesh, options) {\n  var _a, _b, _c, _d;\n  const hasSkeleton = !!sourceMesh.skeleton;\n  const useLocalComputation = options.localMode || hasSkeleton;\n  const meshHasOverridenMaterial = sourceMesh.overrideMaterialSideOrientation !== null && sourceMesh.overrideMaterialSideOrientation !== undefined;\n  const indices = sourceMesh.getIndices();\n  const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n  const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n  const localPositions = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions : null;\n  const localNormals = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals : null;\n  const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\n  const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\n  const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\n  const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n  const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n  const position = options.position || Vector3.Zero();\n  let normal = options.normal || Vector3.Up();\n  const size = options.size || Vector3.One();\n  const angle = options.angle || 0;\n  // Getting correct rotation\n  if (!normal) {\n    const target = new Vector3(0, 0, 1);\n    const camera = sourceMesh.getScene().activeCamera;\n    const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n    normal = camera.globalPosition.subtract(cameraWorldTarget);\n  }\n  const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n  const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n  const pitch = Math.atan2(normal.y, len);\n  const vertexData = new VertexData();\n  vertexData.indices = [];\n  vertexData.positions = [];\n  vertexData.normals = [];\n  vertexData.uvs = [];\n  vertexData.matricesIndices = hasSkeleton ? [] : null;\n  vertexData.matricesWeights = hasSkeleton ? [] : null;\n  vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\n  vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\n  let currentVertexDataIndex = 0;\n  const extractDecalVector3 = (indexId, transformMatrix) => {\n    const result = new DecalVertex();\n    if (!indices || !positions || !normals) {\n      return result;\n    }\n    const vertexId = indices[indexId];\n    result.vertexIdx = vertexId * 3;\n    result.vertexIdxForBones = vertexId * 4;\n    // Send vector to decal local world\n    result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\n    Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\n    // Get normal\n    result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n    Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\n    if (options.captureUVS && uvs) {\n      const v = uvs[vertexId * 2 + 1];\n      result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n    }\n    return result;\n  };\n  const emptyArray = [0, 0, 0, 0];\n  // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n  const clip = (vertices, axis) => {\n    if (vertices.length === 0) {\n      return vertices;\n    }\n    const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n    const indexOf = (arr, val, start, num) => {\n      for (let i = 0; i < num; ++i) {\n        if (arr[start + i] === val) {\n          return start + i;\n        }\n      }\n      return -1;\n    };\n    const clipVertices = (v0, v1) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n      const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n      let indices = emptyArray;\n      let weights = emptyArray;\n      if (matIndices && matWeights) {\n        const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\n        const v0Indices = (_a = v0.matrixIndicesOverride) !== null && _a !== void 0 ? _a : matIndices;\n        const v0Weights = (_b = v0.matrixWeightsOverride) !== null && _b !== void 0 ? _b : matWeights;\n        const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\n        const v1Indices = (_c = v1.matrixIndicesOverride) !== null && _c !== void 0 ? _c : matIndices;\n        const v1Weights = (_d = v1.matrixWeightsOverride) !== null && _d !== void 0 ? _d : matWeights;\n        indices = [0, 0, 0, 0];\n        weights = [0, 0, 0, 0];\n        let index = 0;\n        for (let i = 0; i < 4; ++i) {\n          if (v0Weights[mat0Index + i] > 0) {\n            const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\n            indices[index] = v0Indices[mat0Index + i];\n            weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\n            index++;\n          }\n        }\n        for (let i = 0; i < 4 && index < 4; ++i) {\n          const ind = v1Indices[mat1Index + i];\n          if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\n          indices[index] = ind;\n          weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\n          index++;\n        }\n        const sumw = weights[0] + weights[1] + weights[2] + weights[3];\n        weights[0] /= sumw;\n        weights[1] /= sumw;\n        weights[2] /= sumw;\n        weights[3] /= sumw;\n      }\n      const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : (_e = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx]) !== null && _e !== void 0 ? _e : 0;\n      const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : (_f = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 1]) !== null && _f !== void 0 ? _f : 0;\n      const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : (_g = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 2]) !== null && _g !== void 0 ? _g : 0;\n      const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : (_h = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx]) !== null && _h !== void 0 ? _h : 0;\n      const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : (_j = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 1]) !== null && _j !== void 0 ? _j : 0;\n      const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : (_k = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 2]) !== null && _k !== void 0 ? _k : 0;\n      const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : (_l = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx]) !== null && _l !== void 0 ? _l : 0;\n      const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : (_m = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 1]) !== null && _m !== void 0 ? _m : 0;\n      const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : (_o = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 2]) !== null && _o !== void 0 ? _o : 0;\n      const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : (_p = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx]) !== null && _p !== void 0 ? _p : 0;\n      const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : (_q = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 1]) !== null && _q !== void 0 ? _q : 0;\n      const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : (_r = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 2]) !== null && _r !== void 0 ? _r : 0;\n      const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\n      const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\n      const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\n      const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\n      return new DecalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(), Vector2.Lerp(v0.uv, v1.uv, clipFactor), -1, -1, localPositions ? [v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor, v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor, v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor] : null, localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null, indices, weights);\n    };\n    let clipResult = null;\n    if (vertices.length > 3) {\n      clipResult = new Array();\n    }\n    for (let index = 0; index < vertices.length; index += 3) {\n      let total = 0;\n      let nV1 = null;\n      let nV2 = null;\n      let nV3 = null;\n      let nV4 = null;\n      const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n      const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n      const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n      const v1Out = d1 > 0;\n      const v2Out = d2 > 0;\n      const v3Out = d3 > 0;\n      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n      switch (total) {\n        case 0:\n          if (vertices.length > 3) {\n            clipResult.push(vertices[index]);\n            clipResult.push(vertices[index + 1]);\n            clipResult.push(vertices[index + 2]);\n          } else {\n            clipResult = vertices;\n          }\n          break;\n        case 1:\n          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();\n          if (v1Out) {\n            nV1 = vertices[index + 1];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index], nV1);\n            nV4 = clipVertices(vertices[index], nV2);\n          }\n          if (v2Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index + 1], nV1);\n            nV4 = clipVertices(vertices[index + 1], nV2);\n            clipResult.push(nV3);\n            clipResult.push(nV2.clone());\n            clipResult.push(nV1.clone());\n            clipResult.push(nV2.clone());\n            clipResult.push(nV3.clone());\n            clipResult.push(nV4);\n            break;\n          }\n          if (v3Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 1];\n            nV3 = clipVertices(vertices[index + 2], nV1);\n            nV4 = clipVertices(vertices[index + 2], nV2);\n          }\n          if (nV1 && nV2 && nV3 && nV4) {\n            clipResult.push(nV1.clone());\n            clipResult.push(nV2.clone());\n            clipResult.push(nV3);\n            clipResult.push(nV4);\n            clipResult.push(nV3.clone());\n            clipResult.push(nV2.clone());\n          }\n          break;\n        case 2:\n          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();\n          if (!v1Out) {\n            nV1 = vertices[index].clone();\n            nV2 = clipVertices(nV1, vertices[index + 1]);\n            nV3 = clipVertices(nV1, vertices[index + 2]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          if (!v2Out) {\n            nV1 = vertices[index + 1].clone();\n            nV2 = clipVertices(nV1, vertices[index + 2]);\n            nV3 = clipVertices(nV1, vertices[index]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          if (!v3Out) {\n            nV1 = vertices[index + 2].clone();\n            nV2 = clipVertices(nV1, vertices[index]);\n            nV3 = clipVertices(nV1, vertices[index + 1]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          break;\n        case 3:\n          break;\n      }\n    }\n    return clipResult;\n  };\n  const sourceMeshAsMesh = sourceMesh instanceof Mesh ? sourceMesh : null;\n  const matrixData = sourceMeshAsMesh === null || sourceMeshAsMesh === void 0 ? void 0 : sourceMeshAsMesh._thinInstanceDataStorage.matrixData;\n  const numMatrices = (sourceMeshAsMesh === null || sourceMeshAsMesh === void 0 ? void 0 : sourceMeshAsMesh.thinInstanceCount) || 1;\n  const thinInstanceMatrix = TmpVectors.Matrix[0];\n  thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);\n  for (let m = 0; m < numMatrices; ++m) {\n    if ((sourceMeshAsMesh === null || sourceMeshAsMesh === void 0 ? void 0 : sourceMeshAsMesh.hasThinInstances) && matrixData) {\n      const ofst = m * 16;\n      thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);\n      thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);\n      thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);\n      thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);\n    }\n    // Matrix\n    const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n    const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n    const meshWorldMatrix = sourceMesh.getWorldMatrix();\n    const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);\n    const oneFaceVertices = new Array(3);\n    for (let index = 0; index < indices.length; index += 3) {\n      let faceVertices = oneFaceVertices;\n      faceVertices[0] = extractDecalVector3(index, transformMatrix);\n      if (meshHasOverridenMaterial && useLocalComputation) {\n        faceVertices[1] = extractDecalVector3(index + 2, transformMatrix);\n        faceVertices[2] = extractDecalVector3(index + 1, transformMatrix);\n      } else {\n        faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);\n        faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);\n      }\n      if (options.cullBackFaces) {\n        // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\n        // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\n        if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\n          continue;\n        }\n      }\n      // Clip\n      faceVertices = clip(faceVertices, xpAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, xnAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, ypAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, ynAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, zpAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, znAxis);\n      if (!faceVertices) continue;\n      // Add UVs and get back to world\n      for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n        const vertex = faceVertices[vIndex];\n        //TODO check for Int32Array | Uint32Array | Uint16Array\n        vertexData.indices.push(currentVertexDataIndex);\n        if (useLocalComputation) {\n          if (vertex.localPositionOverride) {\n            vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\n            vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\n            vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\n          } else if (localPositions) {\n            vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\n            vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\n            vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\n          }\n          if (vertex.localNormalOverride) {\n            vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\n            vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\n            vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\n          } else if (localNormals) {\n            vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\n            vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\n            vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\n          }\n        } else {\n          vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n          vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n        }\n        if (vertexData.matricesIndices && vertexData.matricesWeights) {\n          if (vertex.matrixIndicesOverride) {\n            vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\n          } else {\n            if (matIndices) {\n              vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\n              vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\n              vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\n              vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\n            }\n            if (matIndicesExtra && vertexData.matricesIndicesExtra) {\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\n            }\n          }\n          if (vertex.matrixWeightsOverride) {\n            vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\n          } else {\n            if (matWeights) {\n              vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\n              vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\n              vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\n              vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\n            }\n            if (matWeightsExtra && vertexData.matricesWeightsExtra) {\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\n            }\n          }\n        }\n        if (!options.captureUVS) {\n          vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n          const v = 0.5 + vertex.position.y / size.y;\n          vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        } else {\n          vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\n        }\n        currentVertexDataIndex++;\n      }\n    }\n  }\n  // Avoid the \"Setting vertex data kind 'XXX' with an empty array\" warning when calling vertexData.applyToMesh\n  if (vertexData.indices.length === 0) vertexData.indices = null;\n  if (vertexData.positions.length === 0) vertexData.positions = null;\n  if (vertexData.normals.length === 0) vertexData.normals = null;\n  if (vertexData.uvs.length === 0) vertexData.uvs = null;\n  if (((_a = vertexData.matricesIndices) === null || _a === void 0 ? void 0 : _a.length) === 0) vertexData.matricesIndices = null;\n  if (((_b = vertexData.matricesWeights) === null || _b === void 0 ? void 0 : _b.length) === 0) vertexData.matricesWeights = null;\n  if (((_c = vertexData.matricesIndicesExtra) === null || _c === void 0 ? void 0 : _c.length) === 0) vertexData.matricesIndicesExtra = null;\n  if (((_d = vertexData.matricesWeightsExtra) === null || _d === void 0 ? void 0 : _d.length) === 0) vertexData.matricesWeightsExtra = null;\n  // Return mesh\n  const decal = new Mesh(name, sourceMesh.getScene());\n  vertexData.applyToMesh(decal);\n  if (useLocalComputation) {\n    decal.skeleton = sourceMesh.skeleton;\n    decal.parent = sourceMesh;\n  } else {\n    decal.position = position.clone();\n    decal.rotation = new Vector3(pitch, yaw, angle);\n  }\n  decal.computeWorldMatrix(true);\n  decal.refreshBoundingInfo(true, true);\n  return decal;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const DecalBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateDecal\n};\nMesh.CreateDecal = (name, sourceMesh, position, normal, size, angle) => {\n  const options = {\n    position,\n    normal,\n    size,\n    angle\n  };\n  return CreateDecal(name, sourceMesh, options);\n};","map":{"version":3,"names":["Vector3","Matrix","Vector2","TmpVectors","Scalar","Mesh","VertexBuffer","VertexData","CompatibilityOptions","xpAxis","xnAxis","ypAxis","ynAxis","zpAxis","znAxis","DecalVertex","constructor","position","Zero","normal","Up","uv","vertexIdx","vertexIdxForBones","localPositionOverride","localNormalOverride","matrixIndicesOverride","matrixWeightsOverride","clone","_a","slice","_b","_c","_d","CreateDecal","name","sourceMesh","options","hasSkeleton","skeleton","useLocalComputation","localMode","meshHasOverridenMaterial","overrideMaterialSideOrientation","undefined","indices","getIndices","positions","getPositionData","getVerticesData","PositionKind","normals","getNormalsData","NormalKind","localPositions","localNormals","uvs","UVKind","matIndices","MatricesIndicesKind","matWeights","MatricesWeightsKind","matIndicesExtra","MatricesIndicesExtraKind","matWeightsExtra","MatricesWeightsExtraKind","size","One","angle","target","camera","getScene","activeCamera","cameraWorldTarget","TransformCoordinates","getWorldMatrix","globalPosition","subtract","yaw","Math","atan2","z","x","PI","len","sqrt","pitch","y","vertexData","matricesIndices","matricesWeights","matricesIndicesExtra","matricesWeightsExtra","currentVertexDataIndex","extractDecalVector3","indexId","transformMatrix","result","vertexId","TransformCoordinatesToRef","TransformNormalToRef","captureUVS","v","UseOpenGLOrientationForUV","emptyArray","clip","vertices","axis","length","clipSize","abs","Dot","indexOf","arr","val","start","num","i","clipVertices","v0","v1","clipFactor","GetClipFactor","weights","mat0Index","v0Indices","v0Weights","mat1Index","v1Indices","v1Weights","index","idx","Lerp","ind","sumw","v0LocalPositionX","_e","v0LocalPositionY","_f","v0LocalPositionZ","_g","v1LocalPositionX","_h","v1LocalPositionY","_j","v1LocalPositionZ","_k","v0LocalNormalX","_l","v0LocalNormalY","_m","v0LocalNormalZ","_o","v1LocalNormalX","_p","v1LocalNormalY","_q","v1LocalNormalZ","_r","interpNormalX","interpNormalY","interpNormalZ","norm","normalize","clipResult","Array","total","nV1","nV2","nV3","nV4","d1","d2","d3","v1Out","v2Out","v3Out","push","sourceMeshAsMesh","matrixData","_thinInstanceDataStorage","numMatrices","thinInstanceCount","thinInstanceMatrix","copyFrom","IdentityReadOnly","m","hasThinInstances","ofst","setRowFromFloats","decalWorldMatrix","RotationYawPitchRoll","multiply","Translation","inverseDecalWorldMatrix","Invert","meshWorldMatrix","oneFaceVertices","faceVertices","cullBackFaces","vIndex","vertex","toArray","decal","applyToMesh","parent","rotation","computeWorldMatrix","refreshBoundingInfo","DecalBuilder"],"sources":["../../../../../dev/core/src/Meshes/Builders/decalBuilder.ts"],"sourcesContent":["import type { Nullable, IndicesArray, FloatArray } from \"../../types\";\r\nimport { Vector3, Matrix, Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\nconst xpAxis = new Vector3(1, 0, 0);\r\nconst xnAxis = new Vector3(-1, 0, 0);\r\nconst ypAxis = new Vector3(0, 1, 0);\r\nconst ynAxis = new Vector3(0, -1, 0);\r\nconst zpAxis = new Vector3(0, 0, 1);\r\nconst znAxis = new Vector3(0, 0, -1);\r\n\r\n/** @internal */\r\nclass DecalVertex {\r\n    constructor(\r\n        public position: Vector3 = Vector3.Zero(),\r\n        public normal: Vector3 = Vector3.Up(),\r\n        public uv: Vector2 = Vector2.Zero(),\r\n        public vertexIdx: number = 0,\r\n        public vertexIdxForBones: number = 0,\r\n        public localPositionOverride: Nullable<number[]> = null,\r\n        public localNormalOverride: Nullable<number[]> = null,\r\n        public matrixIndicesOverride: Nullable<number[]> = null,\r\n        public matrixWeightsOverride: Nullable<number[]> = null\r\n    ) {}\r\n    public clone(): DecalVertex {\r\n        return new DecalVertex(\r\n            this.position.clone(),\r\n            this.normal.clone(),\r\n            this.uv.clone(),\r\n            this.vertexIdx,\r\n            this.vertexIdxForBones,\r\n            this.localPositionOverride?.slice(),\r\n            this.localNormalOverride?.slice(),\r\n            this.matrixIndicesOverride?.slice(),\r\n            this.matrixWeightsOverride?.slice()\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a decal mesh.\r\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\r\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\r\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\r\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\r\n * Note: Meshes with morph targets are not supported!\r\n * @param name defines the name of the mesh\r\n * @param sourceMesh defines the mesh where the decal must be applied\r\n * @param options defines the options used to create the mesh\r\n * @param options.position\r\n * @param options.normal\r\n * @param options.size\r\n * @param options.angle\r\n * @param options.captureUVS\r\n * @param options.cullBackFaces\r\n * @param options.localMode\r\n * @returns the decal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\r\n */\r\nexport function CreateDecal(\r\n    name: string,\r\n    sourceMesh: AbstractMesh,\r\n    options: { position?: Vector3; normal?: Vector3; size?: Vector3; angle?: number; captureUVS?: boolean; cullBackFaces?: boolean; localMode?: boolean }\r\n): Mesh {\r\n    const hasSkeleton = !!sourceMesh.skeleton;\r\n    const useLocalComputation = options.localMode || hasSkeleton;\r\n    const meshHasOverridenMaterial = (sourceMesh as Mesh).overrideMaterialSideOrientation !== null && (sourceMesh as Mesh).overrideMaterialSideOrientation !== undefined;\r\n\r\n    const indices = <IndicesArray>sourceMesh.getIndices();\r\n    const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\r\n    const localPositions = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions) : null;\r\n    const localNormals = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals) : null;\r\n    const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\r\n    const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\r\n    const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\r\n    const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n    const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n    const position = options.position || Vector3.Zero();\r\n    let normal = options.normal || Vector3.Up();\r\n    const size = options.size || Vector3.One();\r\n    const angle = options.angle || 0;\r\n\r\n    // Getting correct rotation\r\n    if (!normal) {\r\n        const target = new Vector3(0, 0, 1);\r\n        const camera = <Camera>sourceMesh.getScene().activeCamera;\r\n        const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\r\n\r\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n    }\r\n\r\n    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n    const pitch = Math.atan2(normal.y, len);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = [];\r\n    vertexData.positions = [];\r\n    vertexData.normals = [];\r\n    vertexData.uvs = [];\r\n    vertexData.matricesIndices = hasSkeleton ? [] : null;\r\n    vertexData.matricesWeights = hasSkeleton ? [] : null;\r\n    vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\r\n    vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\r\n\r\n    let currentVertexDataIndex = 0;\r\n\r\n    const extractDecalVector3 = (indexId: number, transformMatrix: Matrix): DecalVertex => {\r\n        const result = new DecalVertex();\r\n        if (!indices || !positions || !normals) {\r\n            return result;\r\n        }\r\n\r\n        const vertexId = indices[indexId];\r\n\r\n        result.vertexIdx = vertexId * 3;\r\n        result.vertexIdxForBones = vertexId * 4;\r\n\r\n        // Send vector to decal local world\r\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n        Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\r\n\r\n        // Get normal\r\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n        Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\r\n\r\n        if (options.captureUVS && uvs) {\r\n            const v = uvs[vertexId * 2 + 1];\r\n            result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    const emptyArray = [0, 0, 0, 0];\r\n\r\n    // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n    const clip = (vertices: DecalVertex[], axis: Vector3): Nullable<DecalVertex[]> => {\r\n        if (vertices.length === 0) {\r\n            return vertices;\r\n        }\r\n\r\n        const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\r\n\r\n        const indexOf = (arr: FloatArray | number[], val: number, start: number, num: number) => {\r\n            for (let i = 0; i < num; ++i) {\r\n                if (arr[start + i] === val) {\r\n                    return start + i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n\r\n        const clipVertices = (v0: DecalVertex, v1: DecalVertex): DecalVertex => {\r\n            const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n\r\n            let indices = emptyArray;\r\n            let weights = emptyArray;\r\n\r\n            if (matIndices && matWeights) {\r\n                const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\r\n                const v0Indices = v0.matrixIndicesOverride ?? matIndices;\r\n                const v0Weights = v0.matrixWeightsOverride ?? matWeights;\r\n\r\n                const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\r\n                const v1Indices = v1.matrixIndicesOverride ?? matIndices;\r\n                const v1Weights = v1.matrixWeightsOverride ?? matWeights;\r\n\r\n                indices = [0, 0, 0, 0];\r\n                weights = [0, 0, 0, 0];\r\n\r\n                let index = 0;\r\n                for (let i = 0; i < 4; ++i) {\r\n                    if (v0Weights[mat0Index + i] > 0) {\r\n                        const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\r\n                        indices[index] = v0Indices[mat0Index + i];\r\n                        weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\r\n                        index++;\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < 4 && index < 4; ++i) {\r\n                    const ind = v1Indices[mat1Index + i];\r\n                    if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\r\n\r\n                    indices[index] = ind;\r\n                    weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\r\n                    index++;\r\n                }\r\n\r\n                const sumw = weights[0] + weights[1] + weights[2] + weights[3];\r\n\r\n                weights[0] /= sumw;\r\n                weights[1] /= sumw;\r\n                weights[2] /= sumw;\r\n                weights[3] /= sumw;\r\n            }\r\n\r\n            const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : localPositions?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : localPositions?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : localPositions?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : localPositions?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : localPositions?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : localPositions?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : localNormals?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : localNormals?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : localNormals?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : localNormals?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : localNormals?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : localNormals?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\r\n            const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\r\n            const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\r\n\r\n            const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\r\n\r\n            return new DecalVertex(\r\n                Vector3.Lerp(v0.position, v1.position, clipFactor),\r\n                Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(),\r\n                Vector2.Lerp(v0.uv, v1.uv, clipFactor),\r\n                -1,\r\n                -1,\r\n                localPositions\r\n                    ? [\r\n                          v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,\r\n                          v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,\r\n                          v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor,\r\n                      ]\r\n                    : null,\r\n                localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null,\r\n                indices,\r\n                weights\r\n            );\r\n        };\r\n\r\n        let clipResult: Nullable<DecalVertex[]> = null;\r\n\r\n        if (vertices.length > 3) {\r\n            clipResult = new Array<DecalVertex>();\r\n        }\r\n\r\n        for (let index = 0; index < vertices.length; index += 3) {\r\n            let total = 0;\r\n            let nV1: Nullable<DecalVertex> = null;\r\n            let nV2: Nullable<DecalVertex> = null;\r\n            let nV3: Nullable<DecalVertex> = null;\r\n            let nV4: Nullable<DecalVertex> = null;\r\n\r\n            const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\r\n            const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\r\n            const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\r\n\r\n            const v1Out = d1 > 0;\r\n            const v2Out = d2 > 0;\r\n            const v3Out = d3 > 0;\r\n\r\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n\r\n            switch (total) {\r\n                case 0:\r\n                    if (vertices.length > 3) {\r\n                        clipResult!.push(vertices[index]);\r\n                        clipResult!.push(vertices[index + 1]);\r\n                        clipResult!.push(vertices[index + 2]);\r\n                    } else {\r\n                        clipResult = vertices;\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (v1Out) {\r\n                        nV1 = vertices[index + 1];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index], nV1);\r\n                        nV4 = clipVertices(vertices[index], nV2);\r\n                    }\r\n\r\n                    if (v2Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index + 1], nV1);\r\n                        nV4 = clipVertices(vertices[index + 1], nV2);\r\n\r\n                        clipResult.push(nV3);\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV1.clone());\r\n\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV4);\r\n                        break;\r\n                    }\r\n                    if (v3Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 1];\r\n                        nV3 = clipVertices(vertices[index + 2], nV1);\r\n                        nV4 = clipVertices(vertices[index + 2], nV2);\r\n                    }\r\n\r\n                    if (nV1 && nV2 && nV3 && nV4) {\r\n                        clipResult.push(nV1.clone());\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3);\r\n\r\n                        clipResult.push(nV4);\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV2.clone());\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (!v1Out) {\r\n                        nV1 = vertices[index].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v2Out) {\r\n                        nV1 = vertices[index + 1].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                        nV3 = clipVertices(nV1, vertices[index]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v3Out) {\r\n                        nV1 = vertices[index + 2].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return clipResult;\r\n    };\r\n\r\n    const sourceMeshAsMesh = sourceMesh instanceof Mesh ? sourceMesh : null;\r\n    const matrixData = sourceMeshAsMesh?._thinInstanceDataStorage.matrixData;\r\n\r\n    const numMatrices = sourceMeshAsMesh?.thinInstanceCount || 1;\r\n    const thinInstanceMatrix = TmpVectors.Matrix[0];\r\n\r\n    thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);\r\n\r\n    for (let m = 0; m < numMatrices; ++m) {\r\n        if (sourceMeshAsMesh?.hasThinInstances && matrixData) {\r\n            const ofst = m * 16;\r\n\r\n            thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);\r\n            thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);\r\n            thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);\r\n            thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);\r\n        }\r\n\r\n        // Matrix\r\n        const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\r\n        const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\r\n        const meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n        const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);\r\n\r\n        const oneFaceVertices = new Array<DecalVertex>(3);\r\n\r\n        for (let index = 0; index < indices.length; index += 3) {\r\n            let faceVertices: Nullable<DecalVertex[]> = oneFaceVertices;\r\n\r\n            faceVertices[0] = extractDecalVector3(index, transformMatrix);\r\n            if (meshHasOverridenMaterial && useLocalComputation) {\r\n                faceVertices[1] = extractDecalVector3(index + 2, transformMatrix);\r\n                faceVertices[2] = extractDecalVector3(index + 1, transformMatrix);\r\n            } else {\r\n                faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);\r\n                faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);\r\n            }\r\n\r\n            if (options.cullBackFaces) {\r\n                // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\r\n                // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\r\n                if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Clip\r\n            faceVertices = clip(faceVertices, xpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, xnAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ypAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ynAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, zpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, znAxis);\r\n            if (!faceVertices) continue;\r\n\r\n            // Add UVs and get back to world\r\n            for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n                const vertex = faceVertices[vIndex];\r\n\r\n                //TODO check for Int32Array | Uint32Array | Uint16Array\r\n                (<number[]>vertexData.indices).push(currentVertexDataIndex);\r\n                if (useLocalComputation) {\r\n                    if (vertex.localPositionOverride) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\r\n                    } else if (localPositions) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\r\n                    }\r\n                    if (vertex.localNormalOverride) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\r\n                    } else if (localNormals) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\r\n                    }\r\n                } else {\r\n                    vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n                    vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n                }\r\n                if (vertexData.matricesIndices && vertexData.matricesWeights) {\r\n                    if (vertex.matrixIndicesOverride) {\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\r\n                    } else {\r\n                        if (matIndices) {\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matIndicesExtra && vertexData.matricesIndicesExtra) {\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                    if (vertex.matrixWeightsOverride) {\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\r\n                    } else {\r\n                        if (matWeights) {\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matWeightsExtra && vertexData.matricesWeightsExtra) {\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!options.captureUVS) {\r\n                    (<number[]>vertexData.uvs).push(0.5 + vertex.position.x / size.x);\r\n                    const v = 0.5 + vertex.position.y / size.y;\r\n                    (<number[]>vertexData.uvs).push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                } else {\r\n                    vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\r\n                }\r\n                currentVertexDataIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Avoid the \"Setting vertex data kind 'XXX' with an empty array\" warning when calling vertexData.applyToMesh\r\n    if (vertexData.indices.length === 0) vertexData.indices = null;\r\n    if (vertexData.positions.length === 0) vertexData.positions = null;\r\n    if (vertexData.normals.length === 0) vertexData.normals = null;\r\n    if (vertexData.uvs.length === 0) vertexData.uvs = null;\r\n    if (vertexData.matricesIndices?.length === 0) vertexData.matricesIndices = null;\r\n    if (vertexData.matricesWeights?.length === 0) vertexData.matricesWeights = null;\r\n    if (vertexData.matricesIndicesExtra?.length === 0) vertexData.matricesIndicesExtra = null;\r\n    if (vertexData.matricesWeightsExtra?.length === 0) vertexData.matricesWeightsExtra = null;\r\n\r\n    // Return mesh\r\n    const decal = new Mesh(name, sourceMesh.getScene());\r\n    vertexData.applyToMesh(decal);\r\n\r\n    if (useLocalComputation) {\r\n        decal.skeleton = sourceMesh.skeleton;\r\n        decal.parent = sourceMesh;\r\n    } else {\r\n        decal.position = position.clone();\r\n        decal.rotation = new Vector3(pitch, yaw, angle);\r\n    }\r\n\r\n    decal.computeWorldMatrix(true);\r\n    decal.refreshBoundingInfo(true, true);\r\n\r\n    return decal;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const DecalBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDecal,\r\n};\r\n\r\nMesh.CreateDecal = (name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh => {\r\n    const options = {\r\n        position,\r\n        normal,\r\n        size,\r\n        angle,\r\n    };\r\n\r\n    return CreateDecal(name, sourceMesh, options);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}