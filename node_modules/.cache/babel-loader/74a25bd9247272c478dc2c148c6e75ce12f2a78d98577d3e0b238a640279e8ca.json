{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\nimport { Material } from \"../../../Materials/material.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture.js\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent.js\";\nimport \"../../../Engines/Extensions/engine.renderTarget.js\";\nimport \"../../../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../../../Shaders/procedural.vertex.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { DrawWrapper } from \"../../drawWrapper.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\n * This is the base class of any Procedural texture and contains most of the shareable code.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n */\nexport class ProceduralTexture extends Texture {\n  /**\n   * Instantiates a new procedural texture.\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n   * This is the base class of any Procedural texture and contains most of the shareable code.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n   * @param name  Define the name of the texture\n   * @param size Define the size of the texture to create\n   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\n   *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\n   *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\n   *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\n   * @param scene Define the scene the texture belongs to\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n   * @param generateMipMaps Define if the texture should creates mip maps or not\n   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\n   * @param textureType The FBO internal texture type\n   */\n  constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {\n    super(null, scene, !generateMipMaps);\n    /**\n     * Define if the texture is enabled or not (disabled texture will not render)\n     */\n    this.isEnabled = true;\n    /**\n     * Define if the texture must be cleared before rendering (default is true)\n     */\n    this.autoClear = true;\n    /**\n     * Event raised when the texture is generated\n     */\n    this.onGeneratedObservable = new Observable();\n    /**\n     * Event raised before the texture is generated\n     */\n    this.onBeforeGenerationObservable = new Observable();\n    /**\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\n     */\n    this.nodeMaterialSource = null;\n    /** @internal */\n    this._textures = {};\n    this._currentRefreshId = -1;\n    this._frameId = -1;\n    this._refreshRate = 1;\n    this._vertexBuffers = {};\n    this._uniforms = new Array();\n    this._samplers = new Array();\n    this._floats = {};\n    this._ints = {};\n    this._floatsArrays = {};\n    this._colors3 = {};\n    this._colors4 = {};\n    this._vectors2 = {};\n    this._vectors3 = {};\n    this._matrices = {};\n    this._fallbackTextureUsed = false;\n    this._cachedDefines = null;\n    this._contentUpdateId = -1;\n    this._rtWrapper = null;\n    scene = this.getScene() || EngineStore.LastCreatedScene;\n    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n    if (!component) {\n      component = new ProceduralTextureSceneComponent(scene);\n      scene._addComponent(component);\n    }\n    scene.proceduralTextures.push(this);\n    this._fullEngine = scene.getEngine();\n    this.name = name;\n    this.isRenderTarget = true;\n    this._size = size;\n    this._textureType = textureType;\n    this._generateMipMaps = generateMipMaps;\n    this._drawWrapper = new DrawWrapper(this._fullEngine);\n    this.setFragment(fragment);\n    this._fallbackTexture = fallbackTexture;\n    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\n    this._texture = rtWrapper.texture;\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._createIndexBuffer();\n  }\n  _createRtWrapper(isCube, size, generateMipMaps, textureType) {\n    if (isCube) {\n      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n      this.setFloat(\"face\", 0);\n    } else {\n      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n    }\n    return this._rtWrapper;\n  }\n  /**\n   * The effect that is created when initializing the post process.\n   * @returns The created effect corresponding the the postprocess.\n   */\n  getEffect() {\n    return this._drawWrapper.effect;\n  }\n  /**\n   * @internal*\n   */\n  _setEffect(effect) {\n    this._drawWrapper.effect = effect;\n  }\n  /**\n   * Gets texture content (Use this function wisely as reading from a texture can be slow)\n   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\n   */\n  getContent() {\n    if (this._contentData && this._frameId === this._contentUpdateId) {\n      return this._contentData;\n    }\n    if (this._contentData) {\n      this._contentData.then(buffer => {\n        this._contentData = this.readPixels(0, 0, buffer);\n        this._contentUpdateId = this._frameId;\n      });\n    } else {\n      this._contentData = this.readPixels(0, 0);\n      this._contentUpdateId = this._frameId;\n    }\n    return this._contentData;\n  }\n  _createIndexBuffer() {\n    const engine = this._fullEngine;\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  }\n  /** @internal */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n  }\n  /**\n   * Resets the texture in order to recreate its associated resources.\n   * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\n   */\n  reset() {\n    var _a;\n    (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._drawWrapper.effect = null;\n    this._cachedDefines = null;\n  }\n  _getDefines() {\n    return \"\";\n  }\n  /**\n   * Is the texture ready to be used ? (rendered at least once)\n   * @returns true if ready, otherwise, false.\n   */\n  isReady() {\n    const engine = this._fullEngine;\n    if (this.nodeMaterialSource) {\n      return this._drawWrapper.effect.isReady();\n    }\n    if (!this._fragment) {\n      return false;\n    }\n    if (this._fallbackTextureUsed) {\n      return true;\n    }\n    if (!this._texture) {\n      return false;\n    }\n    const defines = this._getDefines();\n    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\n      return true;\n    }\n    const shaders = {\n      vertex: \"procedural\",\n      fragmentElement: this._fragment.fragmentElement,\n      fragmentSource: this._fragment.fragmentSource,\n      fragment: typeof this._fragment === \"string\" ? this._fragment : undefined\n    };\n    if (this._cachedDefines !== defines) {\n      this._cachedDefines = defines;\n      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\n        var _a;\n        (_a = this._rtWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._rtWrapper = this._texture = null;\n        if (this._fallbackTexture) {\n          this._texture = this._fallbackTexture._texture;\n          if (this._texture) {\n            this._texture.incrementReferences();\n          }\n        }\n        this._fallbackTextureUsed = true;\n      });\n    }\n    return this._drawWrapper.effect.isReady();\n  }\n  /**\n   * Resets the refresh counter of the texture and start bak from scratch.\n   * Could be useful to regenerate the texture if it is setup to render only once.\n   */\n  resetRefreshCounter() {\n    this._currentRefreshId = -1;\n  }\n  /**\n   * Set the fragment shader to use in order to render the texture.\n   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\n   */\n  setFragment(fragment) {\n    this._fragment = fragment;\n  }\n  /**\n   * Define the refresh rate of the texture or the rendering frequency.\n   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n   */\n  get refreshRate() {\n    return this._refreshRate;\n  }\n  set refreshRate(value) {\n    this._refreshRate = value;\n    this.resetRefreshCounter();\n  }\n  /** @internal */\n  _shouldRender() {\n    if (!this.isEnabled || !this.isReady() || !this._texture) {\n      if (this._texture) {\n        this._texture.isReady = false;\n      }\n      return false;\n    }\n    if (this._fallbackTextureUsed) {\n      return false;\n    }\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n    this._currentRefreshId++;\n    return false;\n  }\n  /**\n   * Get the size the texture is rendering at.\n   * @returns the size (on cube texture it is always squared)\n   */\n  getRenderSize() {\n    return this._size;\n  }\n  /**\n   * Resize the texture to new value.\n   * @param size Define the new size the texture should have\n   * @param generateMipMaps Define whether the new texture should create mip maps\n   */\n  resize(size, generateMipMaps) {\n    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\n      return;\n    }\n    const isCube = this._texture.isCube;\n    this._rtWrapper.dispose();\n    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\n    this._texture = rtWrapper.texture;\n    // Update properties\n    this._size = size;\n    this._generateMipMaps = generateMipMaps;\n  }\n  _checkUniform(uniformName) {\n    if (this._uniforms.indexOf(uniformName) === -1) {\n      this._uniforms.push(uniformName);\n    }\n  }\n  /**\n   * Set a texture in the shader program used to render.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setTexture(name, texture) {\n    if (this._samplers.indexOf(name) === -1) {\n      this._samplers.push(name);\n    }\n    this._textures[name] = texture;\n    return this;\n  }\n  /**\n   * Set a float in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setFloat(name, value) {\n    this._checkUniform(name);\n    this._floats[name] = value;\n    return this;\n  }\n  /**\n   * Set a int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setInt(name, value) {\n    this._checkUniform(name);\n    this._ints[name] = value;\n    return this;\n  }\n  /**\n   * Set an array of floats in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setFloats(name, value) {\n    this._checkUniform(name);\n    this._floatsArrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Color3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setColor3(name, value) {\n    this._checkUniform(name);\n    this._colors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Color4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setColor4(name, value) {\n    this._checkUniform(name);\n    this._colors4[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec2 in the shader from a Vector2.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setVector2(name, value) {\n    this._checkUniform(name);\n    this._vectors2[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Vector3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setVector3(name, value) {\n    this._checkUniform(name);\n    this._vectors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a mat4 in the shader from a MAtrix.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix(name, value) {\n    this._checkUniform(name);\n    this._matrices[name] = value;\n    return this;\n  }\n  /**\n   * Render the texture to its associated render target.\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(useCameraPostProcess) {\n    var _a, _b;\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const engine = this._fullEngine;\n    // Render\n    engine.enableEffect(this._drawWrapper);\n    this.onBeforeGenerationObservable.notifyObservers(this);\n    engine.setState(false);\n    if (!this.nodeMaterialSource) {\n      // Texture\n      for (const name in this._textures) {\n        this._drawWrapper.effect.setTexture(name, this._textures[name]);\n      }\n      // Float\n      for (const name in this._ints) {\n        this._drawWrapper.effect.setInt(name, this._ints[name]);\n      }\n      // Float\n      for (const name in this._floats) {\n        this._drawWrapper.effect.setFloat(name, this._floats[name]);\n      }\n      // Floats\n      for (const name in this._floatsArrays) {\n        this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);\n      }\n      // Color3\n      for (const name in this._colors3) {\n        this._drawWrapper.effect.setColor3(name, this._colors3[name]);\n      }\n      // Color4\n      for (const name in this._colors4) {\n        const color = this._colors4[name];\n        this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      }\n      // Vector2\n      for (const name in this._vectors2) {\n        this._drawWrapper.effect.setVector2(name, this._vectors2[name]);\n      }\n      // Vector3\n      for (const name in this._vectors3) {\n        this._drawWrapper.effect.setVector3(name, this._vectors3[name]);\n      }\n      // Matrix\n      for (const name in this._matrices) {\n        this._drawWrapper.effect.setMatrix(name, this._matrices[name]);\n      }\n    }\n    if (!this._texture || !this._rtWrapper) {\n      return;\n    }\n    (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `procedural texture generation for ${this.name}`, 1);\n    const viewPort = engine.currentViewport;\n    if (this.isCube) {\n      for (let face = 0; face < 6; face++) {\n        engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\n        // VBOs\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n        this._drawWrapper.effect.setFloat(\"face\", face);\n        // Clear\n        if (this.autoClear) {\n          engine.clear(scene.clearColor, true, false, false);\n        }\n        // Draw order\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      }\n    } else {\n      engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n      // Clear\n      if (this.autoClear) {\n        engine.clear(scene.clearColor, true, false, false);\n      }\n      // Draw order\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    // Unbind and restore viewport\n    engine.unBindFramebuffer(this._rtWrapper, this.isCube);\n    if (viewPort) {\n      engine.setViewport(viewPort);\n    }\n    // Mipmaps\n    if (this.isCube) {\n      engine.generateMipMapsForCubemap(this._texture);\n    }\n    (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n    if (this.onGenerated) {\n      this.onGenerated();\n    }\n    this.onGeneratedObservable.notifyObservers(this);\n  }\n  /**\n   * Clone the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    const textureSize = this.getSize();\n    const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);\n    // Base texture\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level;\n    // RenderTarget Texture\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const index = scene.proceduralTextures.indexOf(this);\n    if (index >= 0) {\n      scene.proceduralTextures.splice(index, 1);\n    }\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n      this._indexBuffer = null;\n    }\n    this.onGeneratedObservable.clear();\n    this.onBeforeGenerationObservable.clear();\n    super.dispose();\n  }\n}\n__decorate([serialize()], ProceduralTexture.prototype, \"isEnabled\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"autoClear\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"_size\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"refreshRate\", null);\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);","map":{"version":3,"names":["serialize","Observable","VertexBuffer","SceneComponentConstants","Material","Texture","RenderTargetTexture","ProceduralTextureSceneComponent","RegisterClass","EngineStore","DrawWrapper","ProceduralTexture","constructor","name","size","fragment","scene","fallbackTexture","generateMipMaps","isCube","textureType","isEnabled","autoClear","onGeneratedObservable","onBeforeGenerationObservable","nodeMaterialSource","_textures","_currentRefreshId","_frameId","_refreshRate","_vertexBuffers","_uniforms","Array","_samplers","_floats","_ints","_floatsArrays","_colors3","_colors4","_vectors2","_vectors3","_matrices","_fallbackTextureUsed","_cachedDefines","_contentUpdateId","_rtWrapper","getScene","LastCreatedScene","component","_getComponent","NAME_PROCEDURALTEXTURE","_addComponent","proceduralTextures","push","_fullEngine","getEngine","isRenderTarget","_size","_textureType","_generateMipMaps","_drawWrapper","setFragment","_fallbackTexture","rtWrapper","_createRtWrapper","_texture","texture","vertices","PositionKind","_createIndexBuffer","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","type","setFloat","createRenderTargetTexture","getEffect","effect","_setEffect","getContent","_contentData","then","buffer","readPixels","engine","indices","_indexBuffer","createIndexBuffer","_rebuild","vb","refreshRate","REFRESHRATE_RENDER_ONCE","reset","_a","dispose","_getDefines","isReady","_fragment","defines","shaders","vertex","fragmentElement","fragmentSource","undefined","createEffect","incrementReferences","resetRefreshCounter","value","_shouldRender","getRenderSize","resize","_checkUniform","uniformName","indexOf","setTexture","setInt","setFloats","setColor3","setColor4","setVector2","setVector3","setMatrix","render","useCameraPostProcess","enableEffect","notifyObservers","setState","setArray","color","setFloat4","r","g","b","a","_debugPushGroup","call","viewPort","currentViewport","face","bindFramebuffer","bindBuffers","clear","clearColor","drawElementsType","TriangleFillMode","unBindFramebuffer","setViewport","generateMipMapsForCubemap","_b","_debugPopGroup","onGenerated","clone","textureSize","getSize","newTexture","width","hasAlpha","level","coordinatesMode","index","splice","vertexBuffer","_releaseBuffer","__decorate"],"sources":["../../../../../../dev/core/src/Materials/Textures/Procedurals/proceduralTexture.ts"],"sourcesContent":["import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport \"../../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../../../Shaders/procedural.vertex\";\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: Texture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: Engine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\r\n     *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\r\n     *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        this._fallbackTexture = fallbackTexture;\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal*\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n        this._drawWrapper.effect = null;\r\n        this._cachedDefines = null;\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        const shaders = {\r\n            vertex: \"procedural\",\r\n            fragmentElement: this._fragment.fragmentElement,\r\n            fragmentSource: this._fragment.fragmentSource,\r\n            fragment: typeof this._fragment === \"string\" ? this._fragment : undefined,\r\n        };\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\r\n                this._rtWrapper?.dispose();\r\n                this._rtWrapper = this._texture = null;\r\n\r\n                if (this._fallbackTexture) {\r\n                    this._texture = this._fallbackTexture._texture;\r\n\r\n                    if (this._texture) {\r\n                        this._texture.incrementReferences();\r\n                    }\r\n                }\r\n\r\n                this._fallbackTextureUsed = true;\r\n            });\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: Texture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            }\r\n        } else {\r\n            engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n            // Clear\r\n            if (this.autoClear) {\r\n                engine.clear(scene.clearColor, true, false, false);\r\n            }\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Unbind and restore viewport\r\n        engine.unBindFramebuffer(this._rtWrapper, this.isCube);\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}