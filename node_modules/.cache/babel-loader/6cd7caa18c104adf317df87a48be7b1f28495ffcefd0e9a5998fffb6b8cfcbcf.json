{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { GeometryOutputBlock } from \"./Blocks/geometryOutputBlock.js\";\nimport { NodeGeometryBuildState } from \"./nodeGeometryBuildState.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { SerializationHelper, serialize } from \"../../Misc/decorators.js\";\nimport { WebRequest } from \"../../Misc/webRequest.js\";\nimport { BoxBlock } from \"./Blocks/Sources/boxBlock.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Engine } from \"../../Engines/engine.js\";\n/**\n * Defines a node based geometry\n * @see demo at https://playground.babylonjs.com#PYY6XE#69\n */\nexport class NodeGeometry {\n  /** Get the inspector from bundle or global */\n  _getGlobalNodeGeometryEditor() {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEGEOMETRYEDITOR !== \"undefined\") {\n      return NODEGEOMETRYEDITOR;\n    }\n    // In case of module let's check the global emitted from the editor entry point.\n    if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeGeometryEditor !== \"undefined\") {\n      return BABYLON;\n    }\n    return undefined;\n  }\n  /**\n   * Gets the time spent to build this block (in ms)\n   */\n  get buildExecutionTime() {\n    return this._buildExecutionTime;\n  }\n  /**\n   * Creates a new geometry\n   * @param name defines the name of the geometry\n   */\n  constructor(name) {\n    this._buildId = NodeGeometry._BuildIdGenerator++;\n    this._buildWasSuccessful = false;\n    this._vertexData = null;\n    this._buildExecutionTime = 0;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.BJSNODEGEOMETRYEDITOR = this._getGlobalNodeGeometryEditor();\n    /**\n     * Gets or sets data used by visual editor\n     * @see https://nge.babylonjs.com\n     */\n    this.editorData = null;\n    /**\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\n     */\n    this.attachedBlocks = new Array();\n    /**\n     * Observable raised when the geometry is built\n     */\n    this.onBuildObservable = new Observable();\n    /** Gets or sets the GeometryOutputBlock used to gather the final geometry data */\n    this.outputBlock = null;\n    this.name = name;\n  }\n  /**\n   * Gets the current class name of the geometry e.g. \"NodeGeometry\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeGeometry\";\n  }\n  /**\n   * Get a block by its name\n   * @param name defines the name of the block to retrieve\n   * @returns the required block or null if not found\n   */\n  getBlockByName(name) {\n    let result = null;\n    for (const block of this.attachedBlocks) {\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Get a block using a predicate\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required block or null if not found\n   */\n  getBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the list of input blocks attached to this material\n   * @returns an array of InputBlocks\n   */\n  getInputBlocks() {\n    const blocks = [];\n    for (const block of this.attachedBlocks) {\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n    return blocks;\n  }\n  /**\n   * Launch the node geometry editor\n   * @param config Define the configuration of the editor\n   * @returns a promise fulfilled when the node editor is visible\n   */\n  edit(config) {\n    return new Promise(resolve => {\n      this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\n      if (typeof this.BJSNODEGEOMETRYEDITOR == \"undefined\") {\n        const editorUrl = config && config.editorURL ? config.editorURL : NodeGeometry.EditorURL;\n        // Load editor and add it to the DOM\n        Tools.LoadBabylonScript(editorUrl, () => {\n          this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\n          this._createNodeEditor(config === null || config === void 0 ? void 0 : config.nodeGeometryEditorConfig);\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        this._createNodeEditor(config === null || config === void 0 ? void 0 : config.nodeGeometryEditorConfig);\n        resolve();\n      }\n    });\n  }\n  /** Creates the node editor window. */\n  _createNodeEditor(additionalConfig) {\n    const nodeEditorConfig = Object.assign({\n      nodeGeometry: this\n    }, additionalConfig);\n    this.BJSNODEGEOMETRYEDITOR.NodeGeometryEditor.Show(nodeEditorConfig);\n  }\n  /**\n   * Build the final geometry\n   * @param verbose defines if the build should log activity\n   * @param updateBuildId defines if the internal build Id should be updated (default is true)\n   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\n   */\n  build(verbose = false, updateBuildId = true, autoConfigure = false) {\n    this._buildWasSuccessful = false;\n    if (!this.outputBlock) {\n      throw \"You must define the outputBlock property before building the geometry\";\n    }\n    const now = PrecisionDate.Now;\n    // Initialize blocks\n    this._initializeBlock(this.outputBlock, autoConfigure);\n    // Build\n    const state = new NodeGeometryBuildState();\n    state.buildId = this._buildId;\n    state.verbose = verbose;\n    this.outputBlock.build(state);\n    if (updateBuildId) {\n      this._buildId = NodeGeometry._BuildIdGenerator++;\n    }\n    this._buildExecutionTime = PrecisionDate.Now - now;\n    // Errors\n    state.emitErrors();\n    this._buildWasSuccessful = true;\n    this._vertexData = state.vertexData;\n    this.onBuildObservable.notifyObservers(this);\n  }\n  /**\n   * Creates a mesh from the geometry blocks\n   * @param name defines the name of the mesh\n   * @param scene The scene the mesh is scoped to\n   * @returns The new mesh\n   */\n  createMesh(name, scene = null) {\n    if (!this._buildWasSuccessful) {\n      this.build();\n    }\n    if (!this._vertexData) {\n      return null;\n    }\n    const mesh = new Mesh(name, scene);\n    this._vertexData.applyToMesh(mesh);\n    mesh._internalMetadata = mesh._internalMetadata || {};\n    mesh._internalMetadata.nodeGeometry = this;\n    return mesh;\n  }\n  /**\n   * Creates a mesh from the geometry blocks\n   * @param mesh the mesh to update\n   * @returns True if successfully updated\n   */\n  updateMesh(mesh) {\n    if (!this._buildWasSuccessful) {\n      this.build();\n    }\n    if (!this._vertexData) {\n      return false;\n    }\n    this._vertexData.applyToMesh(mesh);\n    mesh._internalMetadata = mesh._internalMetadata || {};\n    mesh._internalMetadata.nodeGeometry = this;\n    return mesh;\n  }\n  _initializeBlock(node, autoConfigure = true) {\n    node.initialize();\n    if (autoConfigure) {\n      node.autoConfigure();\n    }\n    node._preparationId = this._buildId;\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      this.attachedBlocks.push(node);\n    }\n    for (const input of node.inputs) {\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          this._initializeBlock(block, autoConfigure);\n        }\n      }\n    }\n  }\n  /**\n   * Clear the current geometry\n   */\n  clear() {\n    this.outputBlock = null;\n    this.attachedBlocks.length = 0;\n  }\n  /**\n   * Remove a block from the current geometry\n   * @param block defines the block to remove\n   */\n  removeBlock(block) {\n    const attachedBlockIndex = this.attachedBlocks.indexOf(block);\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n    if (block === this.outputBlock) {\n      this.outputBlock = null;\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the geometry\n   * @param merge defines whether or not the source must be merged or replace the current content\n   */\n  parseSerializedObject(source, merge = false) {\n    if (!merge) {\n      this.clear();\n    }\n    const map = {};\n    // Create blocks\n    for (const parsedBlock of source.blocks) {\n      const blockType = GetClass(parsedBlock.customType);\n      if (blockType) {\n        const block = new blockType();\n        block._deserialize(parsedBlock);\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    }\n    // Reconnect teleportation\n    for (const block of this.attachedBlocks) {\n      if (block.isTeleportOut) {\n        const teleportOut = block;\n        const id = teleportOut._tempEntryPointUniqueId;\n        if (id) {\n          const source = map[id];\n          source.attachToEndpoint(teleportOut);\n        }\n      }\n    }\n    // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      const parsedBlock = source.blocks[blockIndex];\n      const block = map[parsedBlock.id];\n      if (!block) {\n        continue;\n      }\n      if (block.inputs.length && parsedBlock.inputs.some(i => i.targetConnectionName) && !merge) {\n        continue;\n      }\n      this._restoreConnections(block, source, map);\n    }\n    // Outputs\n    if (source.outputNodeId) {\n      this.outputBlock = map[source.outputNodeId];\n    }\n    // UI related info\n    if (source.locations || source.editorData && source.editorData.locations) {\n      const locations = source.locations || source.editorData.locations;\n      for (const location of locations) {\n        if (map[location.blockId]) {\n          location.blockId = map[location.blockId].uniqueId;\n        }\n      }\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n      const blockMap = [];\n      for (const key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n      this.editorData.map = blockMap;\n    }\n    this.comment = source.comment;\n  }\n  _restoreConnections(block, source, map) {\n    for (const outputPoint of block.outputs) {\n      for (const candidate of source.blocks) {\n        const target = map[candidate.id];\n        if (!target) {\n          continue;\n        }\n        for (const input of candidate.inputs) {\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            const inputPoint = target.getInputByName(input.inputName);\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n            outputPoint.connectTo(inputPoint, true);\n            this._restoreConnections(target, source, map);\n            continue;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Generate a string containing the code declaration required to create an equivalent of this geometry\n   * @returns a string\n   */\n  generateCode() {\n    let alreadyDumped = [];\n    const blocks = [];\n    const uniqueNames = [\"const\", \"var\", \"let\"];\n    // Gets active blocks\n    if (this.outputBlock) {\n      this._gatherBlocks(this.outputBlock, blocks);\n    }\n    // Generate\n    let codeString = `let nodeGeometry = new BABYLON.NodeGeometry(\"${this.name || \"node geometry\"}\");\\n`;\n    for (const node of blocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    if (this.outputBlock) {\n      // Connections\n      alreadyDumped = [];\n      codeString += \"// Connections\\n\";\n      codeString += this.outputBlock._dumpCodeForOutputConnections(alreadyDumped);\n      // Output nodes\n      codeString += \"// Output nodes\\n\";\n      codeString += `nodeGeometry.outputBlock = ${this.outputBlock._codeVariableName};\\n`;\n      codeString += `nodeGeometry.build();\\n`;\n    }\n    return codeString;\n  }\n  _gatherBlocks(rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n    list.push(rootNode);\n    for (const input of rootNode.inputs) {\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n    // Teleportation\n    if (rootNode.isTeleportOut) {\n      const block = rootNode;\n      if (block.entryPoint) {\n        this._gatherBlocks(block.entryPoint, list);\n      }\n    }\n  }\n  /**\n   * Clear the current geometry and set it to a default state\n   */\n  setToDefault() {\n    this.clear();\n    this.editorData = null;\n    // Source\n    const dataBlock = new BoxBlock(\"Box\");\n    dataBlock.autoConfigure();\n    // Final output\n    const output = new GeometryOutputBlock(\"Geometry Output\");\n    dataBlock.geometry.connectTo(output.geometry);\n    this.outputBlock = output;\n  }\n  /**\n   * Makes a duplicate of the current geometry.\n   * @param name defines the name to use for the new geometry\n   */\n  clone(name) {\n    const serializationObject = this.serialize();\n    const clone = SerializationHelper.Clone(() => new NodeGeometry(name), this);\n    clone.name = name;\n    clone.parseSerializedObject(serializationObject);\n    clone._buildId = this._buildId;\n    clone.build(false);\n    return clone;\n  }\n  /**\n   * Serializes this geometry in a JSON representation\n   * @param selectedBlocks defines the list of blocks to save (if null the whole geometry will be saved)\n   * @returns the serialized geometry object\n   */\n  serialize(selectedBlocks) {\n    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n    let blocks = [];\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeGeometry\";\n      if (this.outputBlock) {\n        serializationObject.outputNodeId = this.outputBlock.uniqueId;\n      }\n    }\n    // Blocks\n    serializationObject.blocks = [];\n    for (const block of blocks) {\n      serializationObject.blocks.push(block.serialize());\n    }\n    if (!selectedBlocks) {\n      for (const block of this.attachedBlocks) {\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Disposes the ressources\n   */\n  dispose() {\n    for (const block of this.attachedBlocks) {\n      block.dispose();\n    }\n    this.attachedBlocks.length = 0;\n    this.onBuildObservable.clear();\n  }\n  /**\n   * Creates a new node geometry set to default basic configuration\n   * @param name defines the name of the geometry\n   * @returns a new NodeGeometry\n   */\n  static CreateDefault(name) {\n    const nodeGeometry = new NodeGeometry(name);\n    nodeGeometry.setToDefault();\n    nodeGeometry.build();\n    return nodeGeometry;\n  }\n  /**\n   * Creates a node geometry from parsed geometry data\n   * @param source defines the JSON representation of the geometry\n   * @returns a new node geometry\n   */\n  static Parse(source) {\n    const nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(source.name), source, null);\n    nodeGeometry.parseSerializedObject(source);\n    nodeGeometry.build();\n    return nodeGeometry;\n  }\n  /**\n   * Creates a node geometry from a snippet saved by the node geometry editor\n   * @param snippetId defines the snippet to load\n   * @param nodeGeometry defines a node geometry to update (instead of creating a new one)\n   * @param skipBuild defines whether to build the node geometry\n   * @returns a promise that will resolve to the new node geometry\n   */\n  static ParseFromSnippetAsync(snippetId, nodeGeometry, skipBuild = false) {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(NodeGeometry.CreateDefault(\"blank\"));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.nodeGeometry);\n            if (!nodeGeometry) {\n              nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(snippetId), serializationObject, null);\n            }\n            nodeGeometry.parseSerializedObject(serializationObject);\n            nodeGeometry.snippetId = snippetId;\n            try {\n              if (!skipBuild) {\n                nodeGeometry.build();\n              }\n              resolve(nodeGeometry);\n            } catch (err) {\n              reject(err);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\nNodeGeometry._BuildIdGenerator = 0;\n/** Define the Url to load node editor script */\nNodeGeometry.EditorURL = `v${Engine.Version}/nodeGeometryEditor/babylon.nodeGeometryEditor.js`;\n/** Define the Url to load snippets */\nNodeGeometry.SnippetUrl = `https://snippet.babylonjs.com`;\n__decorate([serialize()], NodeGeometry.prototype, \"name\", void 0);\n__decorate([serialize(\"comment\")], NodeGeometry.prototype, \"comment\", void 0);","map":{"version":3,"names":["Observable","Mesh","GeometryOutputBlock","NodeGeometryBuildState","GetClass","SerializationHelper","serialize","WebRequest","BoxBlock","PrecisionDate","Tools","Engine","NodeGeometry","_getGlobalNodeGeometryEditor","NODEGEOMETRYEDITOR","BABYLON","NodeGeometryEditor","undefined","buildExecutionTime","_buildExecutionTime","constructor","name","_buildId","_BuildIdGenerator","_buildWasSuccessful","_vertexData","BJSNODEGEOMETRYEDITOR","editorData","attachedBlocks","Array","onBuildObservable","outputBlock","getClassName","getBlockByName","result","block","Warn","getBlockByPredicate","predicate","getInputBlocks","blocks","isInput","push","edit","config","Promise","resolve","editorUrl","editorURL","EditorURL","LoadBabylonScript","_createNodeEditor","nodeGeometryEditorConfig","additionalConfig","nodeEditorConfig","Object","assign","nodeGeometry","Show","build","verbose","updateBuildId","autoConfigure","now","Now","_initializeBlock","state","buildId","emitErrors","vertexData","notifyObservers","createMesh","scene","mesh","applyToMesh","_internalMetadata","updateMesh","node","initialize","_preparationId","indexOf","input","inputs","connectedPoint","ownerBlock","clear","length","removeBlock","attachedBlockIndex","splice","parseSerializedObject","source","merge","map","parsedBlock","blockType","customType","_deserialize","id","isTeleportOut","teleportOut","_tempEntryPointUniqueId","attachToEndpoint","blockIndex","some","i","targetConnectionName","_restoreConnections","outputNodeId","locations","location","blockId","uniqueId","concat","blockMap","key","comment","outputPoint","outputs","candidate","target","targetBlockId","inputPoint","getInputByName","inputName","isConnected","connectTo","generateCode","alreadyDumped","uniqueNames","_gatherBlocks","codeString","_dumpCode","_dumpCodeForOutputConnections","_codeVariableName","rootNode","list","entryPoint","setToDefault","dataBlock","output","geometry","clone","serializationObject","Clone","selectedBlocks","Serialize","JSON","parse","stringify","dispose","CreateDefault","Parse","ParseFromSnippetAsync","snippetId","skipBuild","reject","request","addEventListener","readyState","status","snippet","responseText","jsonPayload","err","open","SnippetUrl","replace","send","Version","__decorate"],"sources":["../../../../../dev/core/src/Meshes/Node/nodeGeometry.ts"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GeometryOutputBlock } from \"./Blocks/geometryOutputBlock\";\r\nimport type { NodeGeometryBlock } from \"./nodeGeometryBlock\";\r\nimport { NodeGeometryBuildState } from \"./nodeGeometryBuildState\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport { SerializationHelper, serialize } from \"../../Misc/decorators\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\nimport { BoxBlock } from \"./Blocks/Sources/boxBlock\";\r\nimport type { GeometryInputBlock } from \"./Blocks/geometryInputBlock\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport type { TeleportOutBlock } from \"./Blocks/Teleport/teleportOutBlock\";\r\nimport type { TeleportInBlock } from \"./Blocks/Teleport/teleportInBlock\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Engine } from \"../../Engines/engine\";\r\n\r\n// declare NODEGEOMETRYEDITOR namespace for compilation issue\r\ndeclare let NODEGEOMETRYEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node geometry editor\r\n */\r\nexport interface INodeGeometryEditorOptions {\r\n    /** Define the URL to load node editor script from */\r\n    editorURL?: string;\r\n    /** Additional configuration for the NGE */\r\n    nodeGeometryEditorConfig?: {\r\n        backgroundColor?: Color4;\r\n        hostScene?: Scene;\r\n        hostMesh?: Mesh;\r\n    };\r\n}\r\n\r\n/**\r\n * Defines a node based geometry\r\n * @see demo at https://playground.babylonjs.com#PYY6XE#69\r\n */\r\nexport class NodeGeometry {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _buildId: number = NodeGeometry._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _vertexData: Nullable<VertexData> = null;\r\n    private _buildExecutionTime: number = 0;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `v${Engine.Version}/nodeGeometryEditor/babylon.nodeGeometryEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private BJSNODEGEOMETRYEDITOR = this._getGlobalNodeGeometryEditor();\r\n\r\n    /** Get the inspector from bundle or global */\r\n    private _getGlobalNodeGeometryEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEGEOMETRYEDITOR !== \"undefined\") {\r\n            return NODEGEOMETRYEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeGeometryEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the time spent to build this block (in ms)\r\n     */\r\n    public get buildExecutionTime() {\r\n        return this._buildExecutionTime;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nge.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks = new Array<NodeGeometryBlock>();\r\n\r\n    /**\r\n     * Observable raised when the geometry is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeGeometry>();\r\n\r\n    /** Gets or sets the GeometryOutputBlock used to gather the final geometry data */\r\n    public outputBlock: Nullable<GeometryOutputBlock> = null;\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * The name of the geometry\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * A free comment about the geometry\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param name defines the name of the geometry\r\n     */\r\n    public constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the geometry e.g. \"NodeGeometry\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeGeometry\";\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block using a predicate\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeGeometryBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: GeometryInputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as GeometryInputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Launch the node geometry editor\r\n     * @param config Define the configuration of the editor\r\n     * @returns a promise fulfilled when the node editor is visible\r\n     */\r\n    public edit(config?: INodeGeometryEditorOptions): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\r\n            if (typeof this.BJSNODEGEOMETRYEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeGeometry.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadBabylonScript(editorUrl, () => {\r\n                    this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\r\n                    this._createNodeEditor(config?.nodeGeometryEditorConfig);\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor(config?.nodeGeometryEditorConfig);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Creates the node editor window. */\r\n    private _createNodeEditor(additionalConfig?: any) {\r\n        const nodeEditorConfig: any = {\r\n            nodeGeometry: this,\r\n            ...additionalConfig,\r\n        };\r\n        this.BJSNODEGEOMETRYEDITOR.NodeGeometryEditor.Show(nodeEditorConfig);\r\n    }\r\n\r\n    /**\r\n     * Build the final geometry\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = false) {\r\n        this._buildWasSuccessful = false;\r\n\r\n        if (!this.outputBlock) {\r\n            throw \"You must define the outputBlock property before building the geometry\";\r\n        }\r\n        const now = PrecisionDate.Now;\r\n        // Initialize blocks\r\n        this._initializeBlock(this.outputBlock, autoConfigure);\r\n\r\n        // Build\r\n        const state = new NodeGeometryBuildState();\r\n\r\n        state.buildId = this._buildId;\r\n        state.verbose = verbose;\r\n\r\n        this.outputBlock.build(state);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeGeometry._BuildIdGenerator++;\r\n        }\r\n\r\n        this._buildExecutionTime = PrecisionDate.Now - now;\r\n\r\n        // Errors\r\n        state.emitErrors();\r\n\r\n        this._buildWasSuccessful = true;\r\n        this._vertexData = state.vertexData;\r\n        this.onBuildObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a mesh from the geometry blocks\r\n     * @param name defines the name of the mesh\r\n     * @param scene The scene the mesh is scoped to\r\n     * @returns The new mesh\r\n     */\r\n    public createMesh(name: string, scene: Nullable<Scene> = null): Nullable<Mesh> {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n\r\n        if (!this._vertexData) {\r\n            return null;\r\n        }\r\n\r\n        const mesh = new Mesh(name, scene);\r\n        this._vertexData.applyToMesh(mesh);\r\n\r\n        mesh._internalMetadata = mesh._internalMetadata || {};\r\n        mesh._internalMetadata.nodeGeometry = this;\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a mesh from the geometry blocks\r\n     * @param mesh the mesh to update\r\n     * @returns True if successfully updated\r\n     */\r\n    public updateMesh(mesh: Mesh) {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n\r\n        if (!this._vertexData) {\r\n            return false;\r\n        }\r\n\r\n        this._vertexData.applyToMesh(mesh);\r\n\r\n        mesh._internalMetadata = mesh._internalMetadata || {};\r\n        mesh._internalMetadata.nodeGeometry = this;\r\n\r\n        return mesh;\r\n    }\r\n\r\n    private _initializeBlock(node: NodeGeometryBlock, autoConfigure = true) {\r\n        node.initialize();\r\n        if (autoConfigure) {\r\n            node.autoConfigure();\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            this.attachedBlocks.push(node);\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._initializeBlock(block, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current geometry\r\n     */\r\n    public clear() {\r\n        this.outputBlock = null;\r\n        this.attachedBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current geometry\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeGeometryBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block === this.outputBlock) {\r\n            this.outputBlock = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the geometry\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     */\r\n    public parseSerializedObject(source: any, merge = false) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeGeometryBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeGeometryBlock = new blockType();\r\n                block._deserialize(parsedBlock);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Reconnect teleportation\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isTeleportOut) {\r\n                const teleportOut = block as TeleportOutBlock;\r\n                const id = teleportOut._tempEntryPointUniqueId;\r\n                if (id) {\r\n                    const source = map[id] as TeleportInBlock;\r\n                    source.attachToEndpoint(teleportOut);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && parsedBlock.inputs.some((i: any) => i.targetConnectionName) && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodeId) {\r\n            this.outputBlock = map[source.outputNodeId] as GeometryOutputBlock;\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: number[] = [];\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeGeometryBlock, source: any, map: { [key: number]: NodeGeometryBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this geometry\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeGeometryBlock[] = [];\r\n        const blocks: NodeGeometryBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        if (this.outputBlock) {\r\n            this._gatherBlocks(this.outputBlock, blocks);\r\n        }\r\n\r\n        // Generate\r\n        let codeString = `let nodeGeometry = new BABYLON.NodeGeometry(\"${this.name || \"node geometry\"}\");\\n`;\r\n        for (const node of blocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        if (this.outputBlock) {\r\n            // Connections\r\n            alreadyDumped = [];\r\n            codeString += \"// Connections\\n\";\r\n            codeString += this.outputBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n\r\n            // Output nodes\r\n            codeString += \"// Output nodes\\n\";\r\n            codeString += `nodeGeometry.outputBlock = ${this.outputBlock._codeVariableName};\\n`;\r\n            codeString += `nodeGeometry.build();\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeGeometryBlock, list: NodeGeometryBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Teleportation\r\n        if (rootNode.isTeleportOut) {\r\n            const block = rootNode as TeleportOutBlock;\r\n            if (block.entryPoint) {\r\n                this._gatherBlocks(block.entryPoint, list);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current geometry and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Source\r\n        const dataBlock = new BoxBlock(\"Box\");\r\n        dataBlock.autoConfigure();\r\n\r\n        // Final output\r\n        const output = new GeometryOutputBlock(\"Geometry Output\");\r\n        dataBlock.geometry.connectTo(output.geometry);\r\n\r\n        this.outputBlock = output;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current geometry.\r\n     * @param name defines the name to use for the new geometry\r\n     */\r\n    public clone(name: string): NodeGeometry {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeGeometry(name), this);\r\n        clone.name = name;\r\n\r\n        clone.parseSerializedObject(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serializes this geometry in a JSON representation\r\n     * @param selectedBlocks defines the list of blocks to save (if null the whole geometry will be saved)\r\n     * @returns the serialized geometry object\r\n     */\r\n    public serialize(selectedBlocks?: NodeGeometryBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeGeometryBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeGeometry\";\r\n            if (this.outputBlock) {\r\n                serializationObject.outputNodeId = this.outputBlock.uniqueId;\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Disposes the ressources\r\n     */\r\n    public dispose(): void {\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks.length = 0;\r\n        this.onBuildObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Creates a new node geometry set to default basic configuration\r\n     * @param name defines the name of the geometry\r\n     * @returns a new NodeGeometry\r\n     */\r\n    public static CreateDefault(name: string) {\r\n        const nodeGeometry = new NodeGeometry(name);\r\n\r\n        nodeGeometry.setToDefault();\r\n        nodeGeometry.build();\r\n\r\n        return nodeGeometry;\r\n    }\r\n\r\n    /**\r\n     * Creates a node geometry from parsed geometry data\r\n     * @param source defines the JSON representation of the geometry\r\n     * @returns a new node geometry\r\n     */\r\n    public static Parse(source: any): NodeGeometry {\r\n        const nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(source.name), source, null);\r\n\r\n        nodeGeometry.parseSerializedObject(source);\r\n        nodeGeometry.build();\r\n\r\n        return nodeGeometry;\r\n    }\r\n\r\n    /**\r\n     * Creates a node geometry from a snippet saved by the node geometry editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param nodeGeometry defines a node geometry to update (instead of creating a new one)\r\n     * @param skipBuild defines whether to build the node geometry\r\n     * @returns a promise that will resolve to the new node geometry\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, nodeGeometry?: NodeGeometry, skipBuild: boolean = false): Promise<NodeGeometry> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(NodeGeometry.CreateDefault(\"blank\"));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeGeometry);\r\n\r\n                        if (!nodeGeometry) {\r\n                            nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(snippetId), serializationObject, null);\r\n                        }\r\n\r\n                        nodeGeometry.parseSerializedObject(serializationObject);\r\n                        nodeGeometry.snippetId = snippetId;\r\n\r\n                        try {\r\n                            if (!skipBuild) {\r\n                                nodeGeometry.build();\r\n                            }\r\n                            resolve(nodeGeometry);\r\n                        } catch (err) {\r\n                            reject(err);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}