{"ast":null,"code":"/**\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\n */\nexport class FadeInOutBehavior {\n  /**\n   * Time in milliseconds to delay before fading in (Default: 0)\n   * Will set both fade in and out delay to the same value\n   */\n  get delay() {\n    return this.fadeInDelay;\n  }\n  set delay(value) {\n    this.fadeInDelay = value;\n    this.fadeOutDelay = value;\n  }\n  /**\n   * Instantiates the FadeInOutBehavior\n   */\n  constructor() {\n    /**\n     * Time in milliseconds to delay before fading in (Default: 0)\n     */\n    this.fadeInDelay = 0;\n    /**\n     * Time in milliseconds to delay before fading out (Default: 0)\n     */\n    this.fadeOutDelay = 0;\n    /**\n     * Time in milliseconds for the mesh to fade in (Default: 300)\n     */\n    this.fadeInTime = 300;\n    /**\n     * Time in milliseconds for the mesh to fade out (Default: 300)\n     */\n    this.fadeOutTime = 300;\n    this._millisecondsPerFrame = 1000 / 60;\n    this._hovered = false;\n    this._hoverValue = 0;\n    this._ownerNode = null;\n    this._delay = 0;\n    this._time = 300;\n    this._update = () => {\n      if (this._ownerNode) {\n        this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\n        this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);\n        if (this._ownerNode.visibility > 1) {\n          this._setAllVisibility(this._ownerNode, 1);\n          if (this._hoverValue > this._time) {\n            this._hoverValue = this._time;\n            this._detachObserver();\n            return;\n          }\n        } else if (this._ownerNode.visibility < 0) {\n          this._setAllVisibility(this._ownerNode, 0);\n          if (this._hoverValue < 0) {\n            this._hoverValue = 0;\n            this._detachObserver();\n            return;\n          }\n        }\n        this._attachObserver();\n      }\n    };\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"FadeInOut\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  /**\n   * Attaches the fade behavior on the passed in mesh\n   * @param ownerNode The mesh that will be faded in/out once attached\n   */\n  attach(ownerNode) {\n    this._ownerNode = ownerNode;\n    this._setAllVisibility(this._ownerNode, 0);\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._ownerNode = null;\n  }\n  /**\n   * Triggers the mesh to begin fading in (or out)\n   * @param fadeIn if the object should fade in or out (true to fade in)\n   */\n  fadeIn(fadeIn = true) {\n    this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;\n    this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;\n    // Cancel any pending updates\n    this._detachObserver();\n    // If fading in and already visible or fading out and already not visible do nothing\n    if (this._ownerNode && (fadeIn && this._ownerNode.visibility >= 1 || !fadeIn && this._ownerNode.visibility <= 0)) {\n      return;\n    }\n    this._hovered = fadeIn;\n    if (!this._hovered) {\n      // Make the delay the negative of fadeout delay so the hoverValue is kept above 1 until\n      // fadeOutDelay has elapsed\n      this._delay *= -1;\n    }\n    // Reset the hoverValue.  This is necessary because we may have been fading out, e.g. but not yet reached\n    // the delay, so the hover value is greater than 1\n    if (this._ownerNode.visibility >= 1) {\n      this._hoverValue = this._time;\n    } else if (this._ownerNode.visibility <= 0) {\n      this._hoverValue = 0;\n    }\n    this._update();\n  }\n  /**\n   * Triggers the mesh to begin fading out\n   */\n  fadeOut() {\n    this.fadeIn(false);\n  }\n  _setAllVisibility(mesh, value) {\n    mesh.visibility = value;\n    mesh.getChildMeshes().forEach(c => {\n      this._setAllVisibility(c, value);\n    });\n  }\n  _attachObserver() {\n    var _a;\n    if (!this._onBeforeRenderObserver) {\n      this._onBeforeRenderObserver = (_a = this._ownerNode) === null || _a === void 0 ? void 0 : _a.getScene().onBeforeRenderObservable.add(this._update);\n    }\n  }\n  _detachObserver() {\n    var _a;\n    if (this._onBeforeRenderObserver) {\n      (_a = this._ownerNode) === null || _a === void 0 ? void 0 : _a.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      this._onBeforeRenderObserver = null;\n    }\n  }\n}","map":{"version":3,"names":["FadeInOutBehavior","delay","fadeInDelay","value","fadeOutDelay","constructor","fadeInTime","fadeOutTime","_millisecondsPerFrame","_hovered","_hoverValue","_ownerNode","_delay","_time","_update","_setAllVisibility","visibility","_detachObserver","_attachObserver","name","init","attach","ownerNode","detach","fadeIn","fadeOut","mesh","getChildMeshes","forEach","c","_onBeforeRenderObserver","_a","getScene","onBeforeRenderObservable","add","remove"],"sources":["../../../../../dev/core/src/Behaviors/Meshes/fadeInOutBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../behavior\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\r\n */\r\nexport class FadeInOutBehavior implements Behavior<Mesh> {\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     */\r\n    public fadeInDelay = 0;\r\n\r\n    /**\r\n     * Time in milliseconds to delay before fading out (Default: 0)\r\n     */\r\n    public fadeOutDelay = 0;\r\n\r\n    /**\r\n     * Time in milliseconds for the mesh to fade in (Default: 300)\r\n     */\r\n    public fadeInTime = 300;\r\n\r\n    /**\r\n     * Time in milliseconds for the mesh to fade out (Default: 300)\r\n     */\r\n    public fadeOutTime = 300;\r\n\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     * Will set both fade in and out delay to the same value\r\n     */\r\n    public get delay(): number {\r\n        return this.fadeInDelay;\r\n    }\r\n\r\n    public set delay(value: number) {\r\n        this.fadeInDelay = value;\r\n        this.fadeOutDelay = value;\r\n    }\r\n\r\n    private _millisecondsPerFrame = 1000 / 60;\r\n    private _hovered = false;\r\n    private _hoverValue = 0;\r\n    private _ownerNode: Nullable<Mesh> = null;\r\n    private _onBeforeRenderObserver: Nullable<Observer<Scene>> | undefined;\r\n    private _delay: number = 0;\r\n    private _time: number = 300;\r\n\r\n    /**\r\n     * Instantiates the FadeInOutBehavior\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"FadeInOut\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the fade behavior on the passed in mesh\r\n     * @param ownerNode The mesh that will be faded in/out once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n        this._setAllVisibility(this._ownerNode, 0);\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode = null;\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading in (or out)\r\n     * @param fadeIn if the object should fade in or out (true to fade in)\r\n     */\r\n    public fadeIn(fadeIn: boolean = true) {\r\n        this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;\r\n        this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;\r\n\r\n        // Cancel any pending updates\r\n        this._detachObserver();\r\n\r\n        // If fading in and already visible or fading out and already not visible do nothing\r\n        if (this._ownerNode && ((fadeIn && this._ownerNode.visibility >= 1) || (!fadeIn && this._ownerNode.visibility <= 0))) {\r\n            return;\r\n        }\r\n\r\n        this._hovered = fadeIn;\r\n        if (!this._hovered) {\r\n            // Make the delay the negative of fadeout delay so the hoverValue is kept above 1 until\r\n            // fadeOutDelay has elapsed\r\n            this._delay *= -1;\r\n        }\r\n\r\n        // Reset the hoverValue.  This is necessary because we may have been fading out, e.g. but not yet reached\r\n        // the delay, so the hover value is greater than 1\r\n        if (this._ownerNode!.visibility >= 1) {\r\n            this._hoverValue = this._time;\r\n        } else if (this._ownerNode!.visibility <= 0) {\r\n            this._hoverValue = 0;\r\n        }\r\n        this._update();\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading out\r\n     */\r\n    public fadeOut() {\r\n        this.fadeIn(false);\r\n    }\r\n\r\n    private _update = () => {\r\n        if (this._ownerNode) {\r\n            this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\r\n\r\n            this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);\r\n\r\n            if (this._ownerNode.visibility > 1) {\r\n                this._setAllVisibility(this._ownerNode, 1);\r\n                if (this._hoverValue > this._time) {\r\n                    this._hoverValue = this._time;\r\n                    this._detachObserver();\r\n                    return;\r\n                }\r\n            } else if (this._ownerNode.visibility < 0) {\r\n                this._setAllVisibility(this._ownerNode, 0);\r\n                if (this._hoverValue < 0) {\r\n                    this._hoverValue = 0;\r\n                    this._detachObserver();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._attachObserver();\r\n        }\r\n    };\r\n\r\n    private _setAllVisibility(mesh: AbstractMesh, value: number) {\r\n        mesh.visibility = value;\r\n        mesh.getChildMeshes().forEach((c) => {\r\n            this._setAllVisibility(c, value);\r\n        });\r\n    }\r\n\r\n    private _attachObserver() {\r\n        if (!this._onBeforeRenderObserver) {\r\n            this._onBeforeRenderObserver = this._ownerNode?.getScene().onBeforeRenderObservable.add(this._update);\r\n        }\r\n    }\r\n\r\n    private _detachObserver() {\r\n        if (this._onBeforeRenderObserver) {\r\n            this._ownerNode?.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n            this._onBeforeRenderObserver = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}