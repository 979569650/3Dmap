{"ast":null,"code":"import { RenderTargetWrapper } from \"../renderTargetWrapper.js\";\n/** @internal */\nexport class WebGLRenderTargetWrapper extends RenderTargetWrapper {\n  constructor(isMulti, isCube, size, engine, context) {\n    super(isMulti, isCube, size, engine);\n    /**\n     * @internal\n     */\n    this._framebuffer = null;\n    /**\n     * @internal\n     */\n    this._depthStencilBuffer = null;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    /**\n     * @internal\n     */\n    this._MSAAFramebuffer = null;\n    // Multiview\n    /**\n     * @internal\n     */\n    this._colorTextureArray = null;\n    /**\n     * @internal\n     */\n    this._depthStencilTextureArray = null;\n    /**\n     * @internal\n     */\n    this._disposeOnlyFramebuffers = false;\n    /**\n     * @internal\n     */\n    this._currentLOD = 0;\n    this._context = context;\n  }\n  _cloneRenderTargetWrapper() {\n    let rtw = null;\n    if (this._colorTextureArray && this._depthStencilTextureArray) {\n      rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);\n      rtw.texture.isReady = true;\n    } else {\n      rtw = super._cloneRenderTargetWrapper();\n    }\n    return rtw;\n  }\n  _swapRenderTargetWrapper(target) {\n    super._swapRenderTargetWrapper(target);\n    target._framebuffer = this._framebuffer;\n    target._depthStencilBuffer = this._depthStencilBuffer;\n    target._MSAAFramebuffer = this._MSAAFramebuffer;\n    target._colorTextureArray = this._colorTextureArray;\n    target._depthStencilTextureArray = this._depthStencilTextureArray;\n    this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;\n  }\n  /**\n   * Shares the depth buffer of this render target with another render target.\n   * @internal\n   * @param renderTarget Destination renderTarget\n   */\n  _shareDepth(renderTarget) {\n    super._shareDepth(renderTarget);\n    const gl = this._context;\n    const depthbuffer = this._depthStencilBuffer;\n    const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;\n    if (renderTarget._depthStencilBuffer && renderTarget._depthStencilBuffer !== depthbuffer) {\n      gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);\n    }\n    renderTarget._depthStencilBuffer = depthbuffer;\n    const attachment = renderTarget._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n    this._engine._bindUnboundFramebuffer(framebuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthbuffer);\n    this._engine._bindUnboundFramebuffer(null);\n  }\n  /**\n   * Binds a texture to this render target on a specific attachment\n   * @param texture The texture to bind to the framebuffer\n   * @param attachmentIndex Index of the attachment\n   * @param faceIndexOrLayer The face or layer of the texture to render to in case of cube texture or array texture\n   * @param lodLevel defines the lod level to bind to the frame buffer\n   */\n  _bindTextureRenderTarget(texture, attachmentIndex = 0, faceIndexOrLayer, lodLevel = 0) {\n    var _a, _b, _c, _d;\n    if (!texture._hardwareTexture) {\n      return;\n    }\n    const framebuffer = this._framebuffer;\n    const currentFB = this._engine._currentFramebuffer;\n    this._engine._bindUnboundFramebuffer(framebuffer);\n    if (this._engine.webGLVersion > 1) {\n      const gl = this._context;\n      const attachment = gl[\"COLOR_ATTACHMENT\" + attachmentIndex];\n      if (texture.is2DArray || texture.is3D) {\n        faceIndexOrLayer = (_b = faceIndexOrLayer !== null && faceIndexOrLayer !== void 0 ? faceIndexOrLayer : (_a = this.layerIndices) === null || _a === void 0 ? void 0 : _a[attachmentIndex]) !== null && _b !== void 0 ? _b : 0;\n        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, texture._hardwareTexture.underlyingResource, lodLevel, faceIndexOrLayer);\n      } else if (texture.isCube) {\n        // if face index is not specified, try to query it from faceIndices\n        // default is face 0\n        faceIndexOrLayer = (_d = faceIndexOrLayer !== null && faceIndexOrLayer !== void 0 ? faceIndexOrLayer : (_c = this.faceIndices) === null || _c === void 0 ? void 0 : _c[attachmentIndex]) !== null && _d !== void 0 ? _d : 0;\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer, texture._hardwareTexture.underlyingResource, lodLevel);\n      } else {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, lodLevel);\n      }\n    } else {\n      // Default behavior (WebGL)\n      const gl = this._context;\n      const attachment = gl[\"COLOR_ATTACHMENT\" + attachmentIndex + \"_WEBGL\"];\n      const target = faceIndexOrLayer !== undefined ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer : gl.TEXTURE_2D;\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);\n    }\n    this._engine._bindUnboundFramebuffer(currentFB);\n  }\n  /**\n   * Set a texture in the textures array\n   * @param texture the texture to set\n   * @param index the index in the textures array to set\n   * @param disposePrevious If this function should dispose the previous texture\n   */\n  setTexture(texture, index = 0, disposePrevious = true) {\n    super.setTexture(texture, index, disposePrevious);\n    this._bindTextureRenderTarget(texture, index);\n  }\n  /**\n   * Sets the layer and face indices of every render target texture\n   * @param layers The layer of the texture to be set (make negative to not modify)\n   * @param faces The face of the texture to be set (make negative to not modify)\n   */\n  setLayerAndFaceIndices(layers, faces) {\n    var _a, _b;\n    super.setLayerAndFaceIndices(layers, faces);\n    if (!this.textures || !this.layerIndices || !this.faceIndices) {\n      return;\n    }\n    // the length of this._attachments is the right one as it does not count the depth texture, in case we generated it\n    const textureCount = (_b = (_a = this._attachments) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : this.textures.length;\n    for (let index = 0; index < textureCount; index++) {\n      const texture = this.textures[index];\n      if (!texture) {\n        // The target type was probably -1 at creation time and setTexture has not been called yet for this index\n        continue;\n      }\n      if (texture.is2DArray || texture.is3D) {\n        this._bindTextureRenderTarget(texture, index, this.layerIndices[index]);\n      } else if (texture.isCube) {\n        this._bindTextureRenderTarget(texture, index, this.faceIndices[index]);\n      } else {\n        this._bindTextureRenderTarget(texture, index);\n      }\n    }\n  }\n  /**\n   * Set the face and layer indices of a texture in the textures array\n   * @param index The index of the texture in the textures array to modify\n   * @param layer The layer of the texture to be set\n   * @param face The face of the texture to be set\n   */\n  setLayerAndFaceIndex(index = 0, layer, face) {\n    super.setLayerAndFaceIndex(index, layer, face);\n    if (!this.textures || !this.layerIndices || !this.faceIndices) {\n      return;\n    }\n    const texture = this.textures[index];\n    if (texture.is2DArray || texture.is3D) {\n      this._bindTextureRenderTarget(this.textures[index], index, this.layerIndices[index]);\n    } else if (texture.isCube) {\n      this._bindTextureRenderTarget(this.textures[index], index, this.faceIndices[index]);\n    }\n  }\n  dispose(disposeOnlyFramebuffers = this._disposeOnlyFramebuffers) {\n    const gl = this._context;\n    if (!disposeOnlyFramebuffers) {\n      if (this._colorTextureArray) {\n        this._context.deleteTexture(this._colorTextureArray);\n        this._colorTextureArray = null;\n      }\n      if (this._depthStencilTextureArray) {\n        this._context.deleteTexture(this._depthStencilTextureArray);\n        this._depthStencilTextureArray = null;\n      }\n    }\n    if (this._framebuffer) {\n      gl.deleteFramebuffer(this._framebuffer);\n      this._framebuffer = null;\n    }\n    if (this._depthStencilBuffer) {\n      gl.deleteRenderbuffer(this._depthStencilBuffer);\n      this._depthStencilBuffer = null;\n    }\n    if (this._MSAAFramebuffer) {\n      gl.deleteFramebuffer(this._MSAAFramebuffer);\n      this._MSAAFramebuffer = null;\n    }\n    super.dispose(disposeOnlyFramebuffers);\n  }\n}","map":{"version":3,"names":["RenderTargetWrapper","WebGLRenderTargetWrapper","constructor","isMulti","isCube","size","engine","context","_framebuffer","_depthStencilBuffer","_MSAAFramebuffer","_colorTextureArray","_depthStencilTextureArray","_disposeOnlyFramebuffers","_currentLOD","_context","_cloneRenderTargetWrapper","rtw","_engine","createMultiviewRenderTargetTexture","width","height","texture","isReady","_swapRenderTargetWrapper","target","_shareDepth","renderTarget","gl","depthbuffer","framebuffer","deleteRenderbuffer","attachment","_generateStencilBuffer","DEPTH_STENCIL_ATTACHMENT","DEPTH_ATTACHMENT","_bindUnboundFramebuffer","framebufferRenderbuffer","FRAMEBUFFER","RENDERBUFFER","_bindTextureRenderTarget","attachmentIndex","faceIndexOrLayer","lodLevel","_hardwareTexture","currentFB","_currentFramebuffer","webGLVersion","is2DArray","is3D","_b","_a","layerIndices","framebufferTextureLayer","underlyingResource","_d","_c","faceIndices","framebufferTexture2D","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_2D","undefined","setTexture","index","disposePrevious","setLayerAndFaceIndices","layers","faces","textures","textureCount","_attachments","length","setLayerAndFaceIndex","layer","face","dispose","disposeOnlyFramebuffers","deleteTexture","deleteFramebuffer"],"sources":["../../../../../dev/core/src/Engines/WebGL/webGLRenderTargetWrapper.ts"],"sourcesContent":["import type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Engine } from \"../engine\";\r\nimport { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\n\r\n/** @internal */\r\nexport class WebGLRenderTargetWrapper extends RenderTargetWrapper {\r\n    private _context: WebGLRenderingContext;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _framebuffer: Nullable<WebGLFramebuffer> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _depthStencilBuffer: Nullable<WebGLRenderbuffer> = null;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    /**\r\n     * @internal\r\n     */\r\n    public _MSAAFramebuffer: Nullable<WebGLFramebuffer> = null;\r\n\r\n    // Multiview\r\n    /**\r\n     * @internal\r\n     */\r\n    public _colorTextureArray: Nullable<WebGLTexture> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _depthStencilTextureArray: Nullable<WebGLTexture> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _disposeOnlyFramebuffers = false;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _currentLOD = 0;\r\n\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: ThinEngine, context: WebGLRenderingContext) {\r\n        super(isMulti, isCube, size, engine);\r\n\r\n        this._context = context;\r\n    }\r\n\r\n    protected _cloneRenderTargetWrapper(): Nullable<RenderTargetWrapper> {\r\n        let rtw: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (this._colorTextureArray && this._depthStencilTextureArray) {\r\n            rtw = (this._engine as Engine).createMultiviewRenderTargetTexture(this.width, this.height);\r\n            rtw.texture!.isReady = true;\r\n        } else {\r\n            rtw = super._cloneRenderTargetWrapper();\r\n        }\r\n\r\n        return rtw;\r\n    }\r\n\r\n    protected _swapRenderTargetWrapper(target: WebGLRenderTargetWrapper): void {\r\n        super._swapRenderTargetWrapper(target);\r\n\r\n        target._framebuffer = this._framebuffer;\r\n        target._depthStencilBuffer = this._depthStencilBuffer;\r\n        target._MSAAFramebuffer = this._MSAAFramebuffer;\r\n        target._colorTextureArray = this._colorTextureArray;\r\n        target._depthStencilTextureArray = this._depthStencilTextureArray;\r\n\r\n        this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;\r\n    }\r\n\r\n    /**\r\n     * Shares the depth buffer of this render target with another render target.\r\n     * @internal\r\n     * @param renderTarget Destination renderTarget\r\n     */\r\n    public _shareDepth(renderTarget: WebGLRenderTargetWrapper): void {\r\n        super._shareDepth(renderTarget);\r\n\r\n        const gl = this._context;\r\n        const depthbuffer = this._depthStencilBuffer;\r\n        const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;\r\n\r\n        if (renderTarget._depthStencilBuffer && renderTarget._depthStencilBuffer !== depthbuffer) {\r\n            gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);\r\n        }\r\n        renderTarget._depthStencilBuffer = depthbuffer;\r\n        const attachment = renderTarget._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\r\n        this._engine._bindUnboundFramebuffer(framebuffer);\r\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthbuffer);\r\n        this._engine._bindUnboundFramebuffer(null);\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to this render target on a specific attachment\r\n     * @param texture The texture to bind to the framebuffer\r\n     * @param attachmentIndex Index of the attachment\r\n     * @param faceIndexOrLayer The face or layer of the texture to render to in case of cube texture or array texture\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     */\r\n    private _bindTextureRenderTarget(texture: InternalTexture, attachmentIndex: number = 0, faceIndexOrLayer?: number, lodLevel: number = 0) {\r\n        if (!texture._hardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        const framebuffer = this._framebuffer;\r\n\r\n        const currentFB = this._engine._currentFramebuffer;\r\n        this._engine._bindUnboundFramebuffer(framebuffer);\r\n\r\n        if (this._engine.webGLVersion > 1) {\r\n            const gl = this._context as WebGL2RenderingContext;\r\n\r\n            const attachment = (<any>gl)[\"COLOR_ATTACHMENT\" + attachmentIndex];\r\n            if (texture.is2DArray || texture.is3D) {\r\n                faceIndexOrLayer = faceIndexOrLayer ?? this.layerIndices?.[attachmentIndex] ?? 0;\r\n                gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, texture._hardwareTexture.underlyingResource, lodLevel, faceIndexOrLayer);\r\n            } else if (texture.isCube) {\r\n                // if face index is not specified, try to query it from faceIndices\r\n                // default is face 0\r\n                faceIndexOrLayer = faceIndexOrLayer ?? this.faceIndices?.[attachmentIndex] ?? 0;\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer, texture._hardwareTexture.underlyingResource, lodLevel);\r\n            } else {\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, lodLevel);\r\n            }\r\n        } else {\r\n            // Default behavior (WebGL)\r\n            const gl = this._context;\r\n\r\n            const attachment = (<any>gl)[\"COLOR_ATTACHMENT\" + attachmentIndex + \"_WEBGL\"];\r\n            const target = faceIndexOrLayer !== undefined ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer : gl.TEXTURE_2D;\r\n\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);\r\n        }\r\n\r\n        this._engine._bindUnboundFramebuffer(currentFB);\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the textures array\r\n     * @param texture the texture to set\r\n     * @param index the index in the textures array to set\r\n     * @param disposePrevious If this function should dispose the previous texture\r\n     */\r\n    public setTexture(texture: InternalTexture, index: number = 0, disposePrevious: boolean = true) {\r\n        super.setTexture(texture, index, disposePrevious);\r\n        this._bindTextureRenderTarget(texture, index);\r\n    }\r\n\r\n    /**\r\n     * Sets the layer and face indices of every render target texture\r\n     * @param layers The layer of the texture to be set (make negative to not modify)\r\n     * @param faces The face of the texture to be set (make negative to not modify)\r\n     */\r\n    public setLayerAndFaceIndices(layers: number[], faces: number[]) {\r\n        super.setLayerAndFaceIndices(layers, faces);\r\n\r\n        if (!this.textures || !this.layerIndices || !this.faceIndices) {\r\n            return;\r\n        }\r\n\r\n        // the length of this._attachments is the right one as it does not count the depth texture, in case we generated it\r\n        const textureCount = this._attachments?.length ?? this.textures.length;\r\n        for (let index = 0; index < textureCount; index++) {\r\n            const texture = this.textures[index];\r\n            if (!texture) {\r\n                // The target type was probably -1 at creation time and setTexture has not been called yet for this index\r\n                continue;\r\n            }\r\n            if (texture.is2DArray || texture.is3D) {\r\n                this._bindTextureRenderTarget(texture, index, this.layerIndices[index]);\r\n            } else if (texture.isCube) {\r\n                this._bindTextureRenderTarget(texture, index, this.faceIndices[index]);\r\n            } else {\r\n                this._bindTextureRenderTarget(texture, index);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the face and layer indices of a texture in the textures array\r\n     * @param index The index of the texture in the textures array to modify\r\n     * @param layer The layer of the texture to be set\r\n     * @param face The face of the texture to be set\r\n     */\r\n    public setLayerAndFaceIndex(index: number = 0, layer?: number, face?: number): void {\r\n        super.setLayerAndFaceIndex(index, layer, face);\r\n\r\n        if (!this.textures || !this.layerIndices || !this.faceIndices) {\r\n            return;\r\n        }\r\n\r\n        const texture = this.textures[index];\r\n        if (texture.is2DArray || texture.is3D) {\r\n            this._bindTextureRenderTarget(this.textures[index], index, this.layerIndices[index]);\r\n        } else if (texture.isCube) {\r\n            this._bindTextureRenderTarget(this.textures[index], index, this.faceIndices[index]);\r\n        }\r\n    }\r\n\r\n    public dispose(disposeOnlyFramebuffers = this._disposeOnlyFramebuffers): void {\r\n        const gl = this._context;\r\n\r\n        if (!disposeOnlyFramebuffers) {\r\n            if (this._colorTextureArray) {\r\n                this._context.deleteTexture(this._colorTextureArray);\r\n                this._colorTextureArray = null;\r\n            }\r\n            if (this._depthStencilTextureArray) {\r\n                this._context.deleteTexture(this._depthStencilTextureArray);\r\n                this._depthStencilTextureArray = null;\r\n            }\r\n        }\r\n\r\n        if (this._framebuffer) {\r\n            gl.deleteFramebuffer(this._framebuffer);\r\n            this._framebuffer = null;\r\n        }\r\n\r\n        if (this._depthStencilBuffer) {\r\n            gl.deleteRenderbuffer(this._depthStencilBuffer);\r\n            this._depthStencilBuffer = null;\r\n        }\r\n\r\n        if (this._MSAAFramebuffer) {\r\n            gl.deleteFramebuffer(this._MSAAFramebuffer);\r\n            this._MSAAFramebuffer = null;\r\n        }\r\n\r\n        super.dispose(disposeOnlyFramebuffers);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}