{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRSessionManager } from \"./webXRSessionManager.js\";\nimport { WebXRCamera } from \"./webXRCamera.js\";\nimport { WebXRState } from \"./webXRTypes.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { UniversalCamera } from \"../Cameras/universalCamera.js\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRExperienceHelpers\n */\nexport class WebXRExperienceHelper {\n  /**\n   * Creates a WebXRExperienceHelper\n   * @param _scene The scene the helper should be created in\n   */\n  constructor(_scene) {\n    this._scene = _scene;\n    this._nonVRCamera = null;\n    this._attachedToElement = false;\n    this._spectatorCamera = null;\n    this._originalSceneAutoClear = true;\n    this._supported = false;\n    this._spectatorMode = false;\n    this._lastTimestamp = 0;\n    /**\n     * Observers registered here will be triggered after the camera's initial transformation is set\n     * This can be used to set a different ground level or an extra rotation.\n     *\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\n     * to the position set after this observable is done executing.\n     */\n    this.onInitialXRPoseSetObservable = new Observable();\n    /**\n     * Fires when the state of the experience helper has changed\n     */\n    this.onStateChangedObservable = new Observable();\n    /**\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\n     */\n    this.state = WebXRState.NOT_IN_XR;\n    this.sessionManager = new WebXRSessionManager(_scene);\n    this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\n    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\n    _scene.onDisposeObservable.addOnce(() => {\n      this.dispose();\n    });\n  }\n  /**\n   * Creates the experience helper\n   * @param scene the scene to attach the experience helper to\n   * @returns a promise for the experience helper\n   */\n  static CreateAsync(scene) {\n    const helper = new WebXRExperienceHelper(scene);\n    return helper.sessionManager.initializeAsync().then(() => {\n      helper._supported = true;\n      return helper;\n    }).catch(e => {\n      helper._setState(WebXRState.NOT_IN_XR);\n      helper.dispose();\n      throw e;\n    });\n  }\n  /**\n   * Disposes of the experience helper\n   */\n  dispose() {\n    var _a;\n    this.exitXRAsync();\n    this.camera.dispose();\n    this.onStateChangedObservable.clear();\n    this.onInitialXRPoseSetObservable.clear();\n    this.sessionManager.dispose();\n    (_a = this._spectatorCamera) === null || _a === void 0 ? void 0 : _a.dispose();\n    if (this._nonVRCamera) {\n      this._scene.activeCamera = this._nonVRCamera;\n    }\n  }\n  /**\n   * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\n   * @param sessionMode options for the XR session\n   * @param referenceSpaceType frame of reference of the XR session\n   * @param renderTarget the output canvas that will be used to enter XR mode\n   * @param sessionCreationOptions optional XRSessionInit object to init the session with\n   * @returns promise that resolves after xr mode has entered\n   */\n  async enterXRAsync(sessionMode, referenceSpaceType, renderTarget = this.sessionManager.getWebXRRenderTarget(), sessionCreationOptions = {}) {\n    var _a, _b, _c;\n    if (!this._supported) {\n      throw \"WebXR not supported in this browser or environment\";\n    }\n    this._setState(WebXRState.ENTERING_XR);\n    if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\n      sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\n      sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\n    }\n    sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\n    // we currently recommend \"unbounded\" space in AR (#7959)\n    if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\n      Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\n    }\n    // make sure that the session mode is supported\n    try {\n      await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\n      await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\n      const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\n      const xrRenderState = {\n        // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\n        depthFar: this.camera.maxZ || 10000,\n        depthNear: this.camera.minZ\n      };\n      // The layers feature will have already initialized the xr session's layers on session init.\n      if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\n        xrRenderState.baseLayer = baseLayer;\n      }\n      this.sessionManager.updateRenderState(xrRenderState);\n      // run the render loop\n      this.sessionManager.runXRRenderLoop();\n      // Cache pre xr scene settings\n      this._originalSceneAutoClear = this._scene.autoClear;\n      this._nonVRCamera = this._scene.activeCamera;\n      this._attachedToElement = !!((_b = (_a = this._nonVRCamera) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.attachedToElement);\n      (_c = this._nonVRCamera) === null || _c === void 0 ? void 0 : _c.detachControl();\n      this._scene.activeCamera = this.camera;\n      // do not compensate when AR session is used\n      if (sessionMode !== \"immersive-ar\") {\n        this._nonXRToXRCamera();\n      } else {\n        // Kept here, TODO - check if needed\n        this._scene.autoClear = false;\n        this.camera.compensateOnFirstFrame = false;\n        // reset the camera's position to the origin\n        this.camera.position.set(0, 0, 0);\n        this.camera.rotationQuaternion.set(0, 0, 0, 1);\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\n      }\n      this.sessionManager.onXRSessionEnded.addOnce(() => {\n        // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\n        if (this.state !== WebXRState.EXITING_XR) {\n          this._setState(WebXRState.EXITING_XR);\n        }\n        // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\n        this.camera.rigCameras.forEach(c => {\n          c.outputRenderTarget = null;\n        });\n        // Restore scene settings\n        this._scene.autoClear = this._originalSceneAutoClear;\n        this._scene.activeCamera = this._nonVRCamera;\n        if (this._attachedToElement && this._nonVRCamera) {\n          this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\n        }\n        if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\n          if (this._nonVRCamera.setPosition) {\n            this._nonVRCamera.setPosition(this.camera.position);\n          } else {\n            this._nonVRCamera.position.copyFrom(this.camera.position);\n          }\n        }\n        this._setState(WebXRState.NOT_IN_XR);\n      });\n      // Wait until the first frame arrives before setting state to in xr\n      this.sessionManager.onXRFrameObservable.addOnce(() => {\n        this._setState(WebXRState.IN_XR);\n      });\n      return this.sessionManager;\n    } catch (e) {\n      console.log(e);\n      console.log(e.message);\n      this._setState(WebXRState.NOT_IN_XR);\n      throw e;\n    }\n  }\n  /**\n   * Exits XR mode and returns the scene to its original state\n   * @returns promise that resolves after xr mode has exited\n   */\n  exitXRAsync() {\n    // only exit if state is IN_XR\n    if (this.state !== WebXRState.IN_XR) {\n      return Promise.resolve();\n    }\n    this._setState(WebXRState.EXITING_XR);\n    return this.sessionManager.exitXRAsync();\n  }\n  /**\n   * Enable spectator mode for desktop VR experiences.\n   * When spectator mode is enabled a camera will be attached to the desktop canvas and will\n   * display the first rig camera's view on the desktop canvas.\n   * Please note that this will degrade performance, as it requires another camera render.\n   * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\n   * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.\n   */\n  enableSpectatorMode(options) {\n    if (!this._spectatorMode) {\n      this._spectatorMode = true;\n      this._switchSpectatorMode(options);\n    }\n  }\n  /**\n   * Disable spectator mode for desktop VR experiences.\n   */\n  disableSpecatatorMode() {\n    if (this._spectatorMode) {\n      this._spectatorMode = false;\n      this._switchSpectatorMode();\n    }\n  }\n  _switchSpectatorMode(options) {\n    const fps = (options === null || options === void 0 ? void 0 : options.fps) ? options.fps : 1000.0;\n    const refreshRate = 1.0 / fps * 1000.0;\n    const cameraIndex = (options === null || options === void 0 ? void 0 : options.preferredCameraIndex) ? options === null || options === void 0 ? void 0 : options.preferredCameraIndex : 0;\n    const updateSpectatorCamera = () => {\n      if (this._spectatorCamera) {\n        const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;\n        if (delta >= refreshRate) {\n          this._lastTimestamp = this.sessionManager.currentTimestamp;\n          this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);\n          this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);\n        }\n      }\n    };\n    if (this._spectatorMode) {\n      if (cameraIndex >= this.camera.rigCameras.length) {\n        throw new Error(\"the preferred camera index is beyond the length of rig camera array.\");\n      }\n      const onStateChanged = () => {\n        if (this.state === WebXRState.IN_XR) {\n          this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\n          this._spectatorCamera.rotationQuaternion = new Quaternion();\n          this._scene.activeCameras = [this.camera, this._spectatorCamera];\n          this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\n          this._scene.onAfterRenderCameraObservable.add(camera => {\n            if (camera === this.camera) {\n              // reset the dimensions object for correct resizing\n              this._scene.getEngine().framebufferDimensionsObject = null;\n            }\n          });\n        } else if (this.state === WebXRState.EXITING_XR) {\n          this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\n          this._scene.activeCameras = null;\n        }\n      };\n      this.onStateChangedObservable.add(onStateChanged);\n      onStateChanged();\n    } else {\n      this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\n      this._scene.activeCameras = [this.camera];\n    }\n  }\n  _nonXRToXRCamera() {\n    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);\n    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\n  }\n  _setState(val) {\n    if (this.state === val) {\n      return;\n    }\n    this.state = val;\n    this.onStateChangedObservable.notifyObservers(this.state);\n  }\n}","map":{"version":3,"names":["Observable","WebXRSessionManager","WebXRCamera","WebXRState","WebXRFeatureName","WebXRFeaturesManager","Logger","UniversalCamera","Quaternion","Vector3","WebXRExperienceHelper","constructor","_scene","_nonVRCamera","_attachedToElement","_spectatorCamera","_originalSceneAutoClear","_supported","_spectatorMode","_lastTimestamp","onInitialXRPoseSetObservable","onStateChangedObservable","state","NOT_IN_XR","sessionManager","camera","featuresManager","onDisposeObservable","addOnce","dispose","CreateAsync","scene","helper","initializeAsync","then","catch","e","_setState","exitXRAsync","clear","_a","activeCamera","enterXRAsync","sessionMode","referenceSpaceType","renderTarget","getWebXRRenderTarget","sessionCreationOptions","ENTERING_XR","optionalFeatures","push","_extendXRSessionInitObject","Warn","initializeSessionAsync","setReferenceSpaceTypeAsync","baseLayer","initializeXRLayerAsync","session","xrRenderState","depthFar","maxZ","depthNear","minZ","getEnabledFeature","LAYERS","updateRenderState","runXRRenderLoop","autoClear","_b","inputs","attachedToElement","_c","detachControl","_nonXRToXRCamera","compensateOnFirstFrame","position","set","rotationQuaternion","notifyObservers","onXRSessionEnded","EXITING_XR","rigCameras","forEach","c","outputRenderTarget","attachControl","noPreventDefault","setPosition","copyFrom","onXRFrameObservable","IN_XR","console","log","message","Promise","resolve","enableSpectatorMode","options","_switchSpectatorMode","disableSpecatatorMode","fps","refreshRate","cameraIndex","preferredCameraIndex","updateSpectatorCamera","delta","currentTimestamp","globalPosition","absoluteRotation","length","Error","onStateChanged","Zero","activeCameras","add","onAfterRenderCameraObservable","getEngine","framebufferDimensionsObject","removeCallback","setTransformationFromNonVRCamera","val"],"sources":["../../../../dev/core/src/XR/webXRExperienceHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { UniversalCamera } from \"../Cameras/universalCamera\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Options for setting up XR spectator camera.\r\n */\r\nexport interface WebXRSpectatorModeOption {\r\n    /**\r\n     * Expected refresh rate (frames per sec) for a spectator camera.\r\n     */\r\n    fps?: number;\r\n    /**\r\n     * The index of rigCameras array in a WebXR camera.\r\n     */\r\n    preferredCameraIndex?: number;\r\n}\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRExperienceHelpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _attachedToElement: boolean = false;\r\n    private _spectatorCamera: Nullable<UniversalCamera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n    private _spectatorMode = false;\r\n    private _lastTimestamp = 0;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param _scene The scene the helper should be created in\r\n     */\r\n    private constructor(private _scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(_scene);\r\n        this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        _scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        const helper = new WebXRExperienceHelper(scene);\r\n        return helper.sessionManager\r\n            .initializeAsync()\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.exitXRAsync();\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        this._spectatorCamera?.dispose();\r\n        if (this._nonVRCamera) {\r\n            this._scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public async enterXRAsync(\r\n        sessionMode: XRSessionMode,\r\n        referenceSpaceType: XRReferenceSpaceType,\r\n        renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(),\r\n        sessionCreationOptions: XRSessionInit = {}\r\n    ): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        try {\r\n            await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\r\n            await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n            const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n\r\n            const xrRenderState: XRRenderStateInit = {\r\n                // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n                depthFar: this.camera.maxZ || 10000,\r\n                depthNear: this.camera.minZ,\r\n            };\r\n\r\n            // The layers feature will have already initialized the xr session's layers on session init.\r\n            if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\r\n                xrRenderState.baseLayer = baseLayer;\r\n            }\r\n\r\n            this.sessionManager.updateRenderState(xrRenderState);\r\n            // run the render loop\r\n            this.sessionManager.runXRRenderLoop();\r\n            // Cache pre xr scene settings\r\n            this._originalSceneAutoClear = this._scene.autoClear;\r\n            this._nonVRCamera = this._scene.activeCamera;\r\n            this._attachedToElement = !!this._nonVRCamera?.inputs?.attachedToElement;\r\n            this._nonVRCamera?.detachControl();\r\n\r\n            this._scene.activeCamera = this.camera;\r\n            // do not compensate when AR session is used\r\n            if (sessionMode !== \"immersive-ar\") {\r\n                this._nonXRToXRCamera();\r\n            } else {\r\n                // Kept here, TODO - check if needed\r\n                this._scene.autoClear = false;\r\n                this.camera.compensateOnFirstFrame = false;\r\n                // reset the camera's position to the origin\r\n                this.camera.position.set(0, 0, 0);\r\n                this.camera.rotationQuaternion.set(0, 0, 0, 1);\r\n                this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n            }\r\n\r\n            this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\r\n                if (this.state !== WebXRState.EXITING_XR) {\r\n                    this._setState(WebXRState.EXITING_XR);\r\n                }\r\n                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                this.camera.rigCameras.forEach((c) => {\r\n                    c.outputRenderTarget = null;\r\n                });\r\n\r\n                // Restore scene settings\r\n                this._scene.autoClear = this._originalSceneAutoClear;\r\n                this._scene.activeCamera = this._nonVRCamera;\r\n                if (this._attachedToElement && this._nonVRCamera) {\r\n                    this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\r\n                }\r\n                if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                    if ((<any>this._nonVRCamera).setPosition) {\r\n                        (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                    } else {\r\n                        this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                    }\r\n                }\r\n\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n            });\r\n\r\n            // Wait until the first frame arrives before setting state to in xr\r\n            this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                this._setState(WebXRState.IN_XR);\r\n            });\r\n            return this.sessionManager;\r\n        } catch (e) {\r\n            console.log(e);\r\n            console.log(e.message);\r\n            this._setState(WebXRState.NOT_IN_XR);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return Promise.resolve();\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    /**\r\n     * Enable spectator mode for desktop VR experiences.\r\n     * When spectator mode is enabled a camera will be attached to the desktop canvas and will\r\n     * display the first rig camera's view on the desktop canvas.\r\n     * Please note that this will degrade performance, as it requires another camera render.\r\n     * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\r\n     * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.\r\n     */\r\n    public enableSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        if (!this._spectatorMode) {\r\n            this._spectatorMode = true;\r\n            this._switchSpectatorMode(options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable spectator mode for desktop VR experiences.\r\n     */\r\n    public disableSpecatatorMode(): void {\r\n        if (this._spectatorMode) {\r\n            this._spectatorMode = false;\r\n            this._switchSpectatorMode();\r\n        }\r\n    }\r\n\r\n    private _switchSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        const fps = options?.fps ? options.fps : 1000.0;\r\n        const refreshRate = (1.0 / fps) * 1000.0;\r\n        const cameraIndex = options?.preferredCameraIndex ? options?.preferredCameraIndex : 0;\r\n\r\n        const updateSpectatorCamera = () => {\r\n            if (this._spectatorCamera) {\r\n                const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;\r\n                if (delta >= refreshRate) {\r\n                    this._lastTimestamp = this.sessionManager.currentTimestamp;\r\n                    this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);\r\n                    this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);\r\n                }\r\n            }\r\n        };\r\n        if (this._spectatorMode) {\r\n            if (cameraIndex >= this.camera.rigCameras.length) {\r\n                throw new Error(\"the preferred camera index is beyond the length of rig camera array.\");\r\n            }\r\n            const onStateChanged = () => {\r\n                if (this.state === WebXRState.IN_XR) {\r\n                    this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\r\n                    this._spectatorCamera.rotationQuaternion = new Quaternion();\r\n                    this._scene.activeCameras = [this.camera, this._spectatorCamera];\r\n                    this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\r\n                    this._scene.onAfterRenderCameraObservable.add((camera) => {\r\n                        if (camera === this.camera) {\r\n                            // reset the dimensions object for correct resizing\r\n                            this._scene.getEngine().framebufferDimensionsObject = null;\r\n                        }\r\n                    });\r\n                } else if (this.state === WebXRState.EXITING_XR) {\r\n                    this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n                    this._scene.activeCameras = null;\r\n                }\r\n            };\r\n            this.onStateChangedObservable.add(onStateChanged);\r\n            onStateChanged();\r\n        } else {\r\n            this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n            this._scene.activeCameras = [this.camera];\r\n        }\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}