{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Shaders/glowMapGeneration.fragment.js\";\nimport \"../Shaders/glowMapGeneration.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { EffectFallbacks } from \"../Materials/effectFallbacks.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * The effect layer Helps adding post process effect blended with the main pass.\n *\n * This can be for instance use to generate glow or highlight effects on the scene.\n *\n * The effect layer class can not be used directly and is intented to inherited from to be\n * customized per effects.\n */\nexport class EffectLayer {\n  /**\n   * Gets the camera attached to the layer.\n   */\n  get camera() {\n    return this._effectLayerOptions.camera;\n  }\n  /**\n   * Gets the rendering group id the layer should render in.\n   */\n  get renderingGroupId() {\n    return this._effectLayerOptions.renderingGroupId;\n  }\n  set renderingGroupId(renderingGroupId) {\n    this._effectLayerOptions.renderingGroupId = renderingGroupId;\n  }\n  /**\n   * Gets the main texture where the effect is rendered\n   */\n  get mainTexture() {\n    return this._mainTexture;\n  }\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes in the layer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\n   */\n  setMaterialForRendering(mesh, material) {\n    this._mainTexture.setMaterialForRendering(mesh, material);\n    if (Array.isArray(mesh)) {\n      for (let i = 0; i < mesh.length; ++i) {\n        const currentMesh = mesh[i];\n        if (!material) {\n          delete this._materialForRendering[currentMesh.uniqueId];\n        } else {\n          this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\n        }\n      }\n    } else {\n      if (!material) {\n        delete this._materialForRendering[mesh.uniqueId];\n      } else {\n        this._materialForRendering[mesh.uniqueId] = [mesh, material];\n      }\n    }\n  }\n  /**\n   * Gets the intensity of the effect for a specific mesh.\n   * @param mesh The mesh to get the effect intensity for\n   * @returns The intensity of the effect for the mesh\n   */\n  getEffectIntensity(mesh) {\n    var _a;\n    return (_a = this._effectIntensity[mesh.uniqueId]) !== null && _a !== void 0 ? _a : 1;\n  }\n  /**\n   * Sets the intensity of the effect for a specific mesh.\n   * @param mesh The mesh to set the effect intensity for\n   * @param intensity The intensity of the effect for the mesh\n   */\n  setEffectIntensity(mesh, intensity) {\n    this._effectIntensity[mesh.uniqueId] = intensity;\n  }\n  /**\n   * Instantiates a new effect Layer and references it in the scene.\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   */\n  constructor( /** The Friendly of the effect in the scene */\n  name, scene) {\n    this._vertexBuffers = {};\n    this._maxSize = 0;\n    this._mainTextureDesiredSize = {\n      width: 0,\n      height: 0\n    };\n    this._shouldRender = true;\n    this._postProcesses = [];\n    this._textures = [];\n    this._emissiveTextureAndColor = {\n      texture: null,\n      color: new Color4()\n    };\n    this._effectIntensity = {};\n    /**\n     * The clear color of the texture used to generate the glow map.\n     */\n    this.neutralColor = new Color4();\n    /**\n     * Specifies whether the highlight layer is enabled or not.\n     */\n    this.isEnabled = true;\n    /**\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\n     */\n    this.disableBoundingBoxesFromEffectLayer = false;\n    /**\n     * An event triggered when the effect layer has been disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\n     */\n    this.onBeforeRenderMainTextureObservable = new Observable();\n    /**\n     * An event triggered when the generated texture is being merged in the scene.\n     */\n    this.onBeforeComposeObservable = new Observable();\n    /**\n     * An event triggered when the mesh is rendered into the effect render target.\n     */\n    this.onBeforeRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered after the mesh has been rendered into the effect render target.\n     */\n    this.onAfterRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered when the generated texture has been merged in the scene.\n     */\n    this.onAfterComposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer changes its size.\n     */\n    this.onSizeChangedObservable = new Observable();\n    this._materialForRendering = {};\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    EffectLayer._SceneComponentInitialization(this._scene);\n    this._engine = this._scene.getEngine();\n    this._maxSize = this._engine.getCaps().maxTextureSize;\n    this._scene.effectLayers.push(this);\n    this._mergeDrawWrapper = [];\n    // Generate Buffers\n    this._generateIndexBuffer();\n    this._generateVertexBuffer();\n  }\n  /**\n   * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\n   * @returns Number of times a mesh must be rendered in the layer\n   */\n  _numInternalDraws() {\n    return 1;\n  }\n  /**\n   * Initializes the effect layer with the required options.\n   * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\n   */\n  _init(options) {\n    // Adapt options\n    this._effectLayerOptions = Object.assign({\n      mainTextureRatio: 0.5,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1,\n      mainTextureType: 0,\n      generateStencilBuffer: false\n    }, options);\n    this._setMainTextureSize();\n    this._createMainTexture();\n    this._createTextureAndPostProcesses();\n  }\n  /**\n   * Generates the index buffer of the full screen quad blending to the main canvas.\n   */\n  _generateIndexBuffer() {\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  }\n  /**\n   * Generates the vertex buffer of the full screen quad blending to the main canvas.\n   */\n  _generateVertexBuffer() {\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n  }\n  /**\n   * Sets the main texture desired size which is the closest power of two\n   * of the engine canvas size.\n   */\n  _setMainTextureSize() {\n    if (this._effectLayerOptions.mainTextureFixedSize) {\n      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\n      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\n    } else {\n      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\n      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\n    }\n    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\n    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\n  }\n  /**\n   * Creates the main texture for the effect layer.\n   */\n  _createMainTexture() {\n    this._mainTexture = new RenderTargetTexture(\"EffectLayerMainRTT\", {\n      width: this._mainTextureDesiredSize.width,\n      height: this._mainTextureDesiredSize.height\n    }, this._scene, false, true, this._effectLayerOptions.mainTextureType, false, Texture.TRILINEAR_SAMPLINGMODE, true, this._effectLayerOptions.generateStencilBuffer);\n    this._mainTexture.activeCamera = this._effectLayerOptions.camera;\n    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.anisotropicFilteringLevel = 1;\n    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n    this._mainTexture.renderParticles = false;\n    this._mainTexture.renderList = null;\n    this._mainTexture.ignoreCameraViewport = true;\n    for (const id in this._materialForRendering) {\n      const [mesh, material] = this._materialForRendering[id];\n      this._mainTexture.setMaterialForRendering(mesh, material);\n    }\n    this._mainTexture.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const material = subMesh.getMaterial();\n          const renderingMesh = subMesh.getRenderingMesh();\n          if (!material) {\n            continue;\n          }\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n          this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n          if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    // Custom render function\n    this._mainTexture.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      this.onBeforeRenderMainTextureObservable.notifyObservers(this);\n      let index;\n      const engine = this._scene.getEngine();\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          this._renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n        engine.setColorWrite(true);\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        this._renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        this._renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      const previousAlphaMode = engine.getAlphaMode();\n      for (index = 0; index < transparentSubMeshes.length; index++) {\n        this._renderSubMesh(transparentSubMeshes.data[index], true);\n      }\n      engine.setAlphaMode(previousAlphaMode);\n    };\n    this._mainTexture.onClearObservable.add(engine => {\n      engine.clear(this.neutralColor, true, true, true);\n    });\n    // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\n    if (this._scene.getBoundingBoxRenderer) {\n      const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\n      this._mainTexture.onBeforeBindObservable.add(() => {\n        this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\n      });\n      this._mainTexture.onAfterUnbindObservable.add(() => {\n        this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\n      });\n    }\n  }\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _addCustomEffectDefines(defines) {\n    // Nothing to add by default.\n  }\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @param emissiveTexture the associated emissive texture used to generate the glow\n   * @returns true if ready otherwise, false\n   */\n  _isReady(subMesh, useInstances, emissiveTexture) {\n    var _a;\n    const engine = this._scene.getEngine();\n    const mesh = subMesh.getMesh();\n    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const material = subMesh.getMaterial();\n    if (!material) {\n      return false;\n    }\n    if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\n      return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    let uv1 = false;\n    let uv2 = false;\n    // Diffuse\n    if (material) {\n      const needAlphaTest = material.needAlphaTesting();\n      const diffuseTexture = material.getAlphaTestTexture();\n      const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        defines.push(\"#define DIFFUSE\");\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\n          defines.push(\"#define DIFFUSEUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define DIFFUSEUV1\");\n          uv1 = true;\n        }\n        if (needAlphaTest) {\n          defines.push(\"#define ALPHATEST\");\n          defines.push(\"#define ALPHATESTVALUE 0.4\");\n        }\n        if (!diffuseTexture.gammaSpace) {\n          defines.push(\"#define DIFFUSE_ISLINEAR\");\n        }\n      }\n      const opacityTexture = material.opacityTexture;\n      if (opacityTexture) {\n        defines.push(\"#define OPACITY\");\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\n          defines.push(\"#define OPACITYUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define OPACITYUV1\");\n          uv1 = true;\n        }\n      }\n    }\n    // Emissive\n    if (emissiveTexture) {\n      defines.push(\"#define EMISSIVE\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\n        defines.push(\"#define EMISSIVEUV2\");\n        uv2 = true;\n      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        defines.push(\"#define EMISSIVEUV1\");\n        uv1 = true;\n      }\n      if (!emissiveTexture.gammaSpace) {\n        defines.push(\"#define EMISSIVE_ISLINEAR\");\n      }\n    }\n    // Vertex\n    if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXALPHA\");\n    }\n    if (uv1) {\n      attribs.push(VertexBuffer.UVKind);\n      defines.push(\"#define UV1\");\n    }\n    if (uv2) {\n      attribs.push(VertexBuffer.UV2Kind);\n      defines.push(\"#define UV2\");\n    }\n    // Bones\n    const fallbacks = new EffectFallbacks();\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      const skeleton = mesh.skeleton;\n      if (skeleton && skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\n      }\n      if (mesh.numBoneInfluencers > 0) {\n        fallbacks.addCPUSkinningFallback(0, mesh);\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const manager = mesh.morphTargetManager;\n    let morphInfluencers = 0;\n    if (manager) {\n      if (manager.numInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        morphInfluencers = manager.numInfluencers;\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n        if (manager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // ClipPlanes\n    prepareStringDefinesForClipPlanes(material, this._scene, defines);\n    this._addCustomEffectDefines(defines);\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"viewProjection\", \"glowColor\", \"morphTargetInfluences\", \"boneTextureWidth\", \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\", \"glowIntensity\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(this._engine.createEffect(\"glowMapGeneration\", attribs, uniforms, [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"], join, fallbacks, undefined, undefined, {\n        maxSimultaneousMorphTargets: morphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\n   */\n  render() {\n    for (let i = 0; i < this._postProcesses.length; i++) {\n      if (!this._postProcesses[i].isReady()) {\n        return;\n      }\n    }\n    const engine = this._scene.getEngine();\n    const numDraws = this._numInternalDraws();\n    // Check\n    let isReady = true;\n    for (let i = 0; i < numDraws; ++i) {\n      let currentEffect = this._mergeDrawWrapper[i];\n      if (!currentEffect) {\n        currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\n        currentEffect.setEffect(this._createMergeEffect());\n      }\n      isReady = isReady && currentEffect.effect.isReady();\n    }\n    if (!isReady) {\n      return;\n    }\n    this.onBeforeComposeObservable.notifyObservers(this);\n    const previousAlphaMode = engine.getAlphaMode();\n    for (let i = 0; i < numDraws; ++i) {\n      const currentEffect = this._mergeDrawWrapper[i];\n      // Render\n      engine.enableEffect(currentEffect);\n      engine.setState(false);\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect);\n      // Go Blend.\n      engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\n      // Blends the map on the main canvas.\n      this._internalRender(currentEffect.effect, i);\n    }\n    // Restore Alpha\n    engine.setAlphaMode(previousAlphaMode);\n    this.onAfterComposeObservable.notifyObservers(this);\n    // Handle size changes.\n    const size = this._mainTexture.getSize();\n    this._setMainTextureSize();\n    if ((size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) && this._mainTextureDesiredSize.width !== 0 && this._mainTextureDesiredSize.height !== 0) {\n      // Recreate RTT and post processes on size change.\n      this.onSizeChangedObservable.notifyObservers(this);\n      this._disposeTextureAndPostProcesses();\n      this._createMainTexture();\n      this._createTextureAndPostProcesses();\n    }\n  }\n  /**\n   * Determine if a given mesh will be used in the current effect.\n   * @param mesh mesh to test\n   * @returns true if the mesh will be used\n   */\n  hasMesh(mesh) {\n    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Returns true if the layer contains information to display, otherwise false.\n   * @returns true if the glow layer should be rendered\n   */\n  shouldRender() {\n    return this.isEnabled && this._shouldRender;\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _shouldRenderMesh(mesh) {\n    return true;\n  }\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n  _canRenderMesh(mesh, material) {\n    return !material.needAlphaBlendingForMesh(mesh);\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @returns true if it should render otherwise false\n   */\n  _shouldRenderEmissiveTextureForMesh() {\n    return true;\n  }\n  /**\n   * Renders the submesh passed in parameter to the generation map.\n   * @param subMesh\n   * @param enableAlphaMode\n   */\n  _renderSubMesh(subMesh, enableAlphaMode = false) {\n    var _a, _b;\n    if (!this.shouldRender()) {\n      return;\n    }\n    const material = subMesh.getMaterial();\n    const ownerMesh = subMesh.getMesh();\n    const replacementMesh = subMesh.getReplacementMesh();\n    const renderingMesh = subMesh.getRenderingMesh();\n    const effectiveMesh = subMesh.getEffectiveMesh();\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n    if (!material) {\n      return;\n    }\n    // Do not block in blend mode.\n    if (!this._canRenderMesh(renderingMesh, material)) {\n      return;\n    }\n    // Culling\n    let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n    const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n    if (mainDeterminant < 0) {\n      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n    }\n    const reverse = sideOrientation === Material.ClockWiseSideOrientation;\n    engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\n    // Managing instances\n    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\n    if (batch.mustReturn) {\n      return;\n    }\n    // Early Exit per mesh\n    if (!this._shouldRenderMesh(renderingMesh)) {\n      return;\n    }\n    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\n    if (this._useMeshMaterial(renderingMesh)) {\n      renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\n    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n      const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n      let drawWrapper = subMesh._getDrawWrapper();\n      if (!drawWrapper && renderingMaterial) {\n        drawWrapper = renderingMaterial._getDrawWrapper();\n      }\n      if (!drawWrapper) {\n        return;\n      }\n      const effect = drawWrapper.effect;\n      engine.enableEffect(drawWrapper);\n      if (!hardwareInstancedRendering) {\n        renderingMesh._bind(subMesh, effect, material.fillMode);\n      }\n      if (!renderingMaterial) {\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        effect.setFloat4(\"glowColor\", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);\n      } else {\n        renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n      }\n      if (!renderingMaterial) {\n        const needAlphaTest = material.needAlphaTesting();\n        const diffuseTexture = material.getAlphaTestTexture();\n        const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n        if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n          effect.setTexture(\"diffuseSampler\", diffuseTexture);\n          const textureMatrix = diffuseTexture.getTextureMatrix();\n          if (textureMatrix) {\n            effect.setMatrix(\"diffuseMatrix\", textureMatrix);\n          }\n        }\n        const opacityTexture = material.opacityTexture;\n        if (opacityTexture) {\n          effect.setTexture(\"opacitySampler\", opacityTexture);\n          effect.setFloat(\"opacityIntensity\", opacityTexture.level);\n          const textureMatrix = opacityTexture.getTextureMatrix();\n          if (textureMatrix) {\n            effect.setMatrix(\"opacityMatrix\", textureMatrix);\n          }\n        }\n        // Glow emissive only\n        if (this._emissiveTextureAndColor.texture) {\n          effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\n          effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\n        }\n        // Bones\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          const skeleton = renderingMesh.skeleton;\n          if (skeleton.isUsingTextureForMatrices) {\n            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n            if (!boneTexture) {\n              return;\n            }\n            effect.setTexture(\"boneSampler\", boneTexture);\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n          } else {\n            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n          }\n        }\n        // Morph targets\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n          renderingMesh.morphTargetManager._bind(effect);\n        }\n        // Alpha mode\n        if (enableAlphaMode) {\n          engine.setAlphaMode(material.alphaMode);\n        }\n        // Intensity of effect\n        effect.setFloat(\"glowIntensity\", this.getEffectIntensity(renderingMesh));\n        // Clip planes\n        bindClipPlane(effect, material, scene);\n      }\n      // Draw\n      renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n    } else {\n      // Need to reset refresh rate of the main map\n      this._mainTexture.resetRefreshCounter();\n    }\n    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\n  }\n  /**\n   * Defines whether the current material of the mesh should be use to render the effect.\n   * @param mesh defines the current mesh to render\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _useMeshMaterial(mesh) {\n    return false;\n  }\n  /**\n   * Rebuild the required buffers.\n   * @internal Internal use only.\n   */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._generateIndexBuffer();\n  }\n  /**\n   * Dispose only the render target textures and post process.\n   */\n  _disposeTextureAndPostProcesses() {\n    this._mainTexture.dispose();\n    for (let i = 0; i < this._postProcesses.length; i++) {\n      if (this._postProcesses[i]) {\n        this._postProcesses[i].dispose();\n      }\n    }\n    this._postProcesses = [];\n    for (let i = 0; i < this._textures.length; i++) {\n      if (this._textures[i]) {\n        this._textures[i].dispose();\n      }\n    }\n    this._textures = [];\n  }\n  /**\n   * Dispose the highlight layer and free resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    for (const drawWrapper of this._mergeDrawWrapper) {\n      drawWrapper.dispose();\n    }\n    this._mergeDrawWrapper = [];\n    // Clean textures and post processes\n    this._disposeTextureAndPostProcesses();\n    // Remove from scene\n    const index = this._scene.effectLayers.indexOf(this, 0);\n    if (index > -1) {\n      this._scene.effectLayers.splice(index, 1);\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderMainTextureObservable.clear();\n    this.onBeforeComposeObservable.clear();\n    this.onBeforeRenderMeshToEffect.clear();\n    this.onAfterRenderMeshToEffect.clear();\n    this.onAfterComposeObservable.clear();\n    this.onSizeChangedObservable.clear();\n  }\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n  getClassName() {\n    return \"EffectLayer\";\n  }\n  /**\n   * Creates an effect layer from parsed effect layer data\n   * @param parsedEffectLayer defines effect layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the effect layer information\n   * @returns a parsed effect Layer\n   */\n  static Parse(parsedEffectLayer, scene, rootUrl) {\n    const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\n    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\n  }\n}\n/**\n * @internal\n */\nEffectLayer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"EffectLayerSceneComponent\");\n};\n__decorate([serialize()], EffectLayer.prototype, \"name\", void 0);\n__decorate([serializeAsColor4()], EffectLayer.prototype, \"neutralColor\", void 0);\n__decorate([serialize()], EffectLayer.prototype, \"isEnabled\", void 0);\n__decorate([serializeAsCameraReference()], EffectLayer.prototype, \"camera\", null);\n__decorate([serialize()], EffectLayer.prototype, \"renderingGroupId\", null);\n__decorate([serialize()], EffectLayer.prototype, \"disableBoundingBoxesFromEffectLayer\", void 0);","map":{"version":3,"names":["serialize","serializeAsColor4","serializeAsCameraReference","Tools","Observable","Color4","Engine","EngineStore","VertexBuffer","Texture","RenderTargetTexture","Material","MaterialHelper","_WarnImport","EffectFallbacks","DrawWrapper","addClipPlaneUniforms","bindClipPlane","prepareStringDefinesForClipPlanes","EffectLayer","camera","_effectLayerOptions","renderingGroupId","mainTexture","_mainTexture","setMaterialForRendering","mesh","material","Array","isArray","i","length","currentMesh","_materialForRendering","uniqueId","getEffectIntensity","_a","_effectIntensity","setEffectIntensity","intensity","constructor","name","scene","_vertexBuffers","_maxSize","_mainTextureDesiredSize","width","height","_shouldRender","_postProcesses","_textures","_emissiveTextureAndColor","texture","color","neutralColor","isEnabled","disableBoundingBoxesFromEffectLayer","onDisposeObservable","onBeforeRenderMainTextureObservable","onBeforeComposeObservable","onBeforeRenderMeshToEffect","onAfterRenderMeshToEffect","onAfterComposeObservable","onSizeChangedObservable","_scene","LastCreatedScene","_SceneComponentInitialization","_engine","getEngine","getCaps","maxTextureSize","effectLayers","push","_mergeDrawWrapper","_generateIndexBuffer","_generateVertexBuffer","_numInternalDraws","_init","options","Object","assign","mainTextureRatio","alphaBlendingMode","mainTextureType","generateStencilBuffer","_setMainTextureSize","_createMainTexture","_createTextureAndPostProcesses","indices","_indexBuffer","createIndexBuffer","vertices","vertexBuffer","PositionKind","mainTextureFixedSize","getRenderWidth","getRenderHeight","needPOTTextures","GetExponentOfTwo","Math","floor","TRILINEAR_SAMPLINGMODE","activeCamera","wrapU","CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","updateSamplingMode","BILINEAR_SAMPLINGMODE","renderParticles","renderList","ignoreCameraViewport","id","customIsReadyFunction","refreshRate","preWarm","subMeshes","subMesh","getMaterial","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","hasThinInstances","_setEmissiveTextureAndColor","_isReady","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","notifyObservers","index","engine","setColorWrite","_renderSubMesh","data","previousAlphaMode","getAlphaMode","setAlphaMode","onClearObservable","add","clear","getBoundingBoxRenderer","boundingBoxRendererEnabled","enabled","onBeforeBindObservable","onAfterUnbindObservable","_addCustomEffectDefines","defines","useInstances","emissiveTexture","getMesh","renderingMaterial","_internalAbstractMeshDataInfo","_materialForRenderPass","currentRenderPassId","isReadyForSubMesh","_useMeshMaterial","attribs","uv1","uv2","needAlphaTest","needAlphaTesting","diffuseTexture","getAlphaTestTexture","needAlphaBlendFromDiffuse","hasAlpha","useAlphaFromDiffuseTexture","_useAlphaFromAlbedoTexture","isVerticesDataPresent","UV2Kind","coordinatesIndex","UVKind","gammaSpace","opacityTexture","useVertexColors","ColorKind","hasVertexAlpha","transparencyMode","MATERIAL_OPAQUE","fallbacks","useBones","computeBonesUsingShaders","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","skeleton","isUsingTextureForMatrices","bones","addCPUSkinningFallback","manager","morphTargetManager","morphInfluencers","numInfluencers","isUsingTextureForTargets","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","drawWrapper","_getDrawWrapper","undefined","cachedDefines","join","uniforms","setEffect","createEffect","maxSimultaneousMorphTargets","effect","isReady","render","numDraws","currentEffect","_createMergeEffect","enableEffect","setState","bindBuffers","_internalRender","size","getSize","_disposeTextureAndPostProcesses","hasMesh","shouldRender","_shouldRenderMesh","_canRenderMesh","needAlphaBlendingForMesh","_shouldRenderEmissiveTextureForMesh","enableAlphaMode","ownerMesh","replacementMesh","effectiveMesh","getEffectiveMesh","_isActiveIntermediate","sideOrientation","overrideMaterialSideOrientation","mainDeterminant","_getWorldMatrixDeterminant","ClockWiseSideOrientation","CounterClockWiseSideOrientation","reverse","backFaceCulling","zOffset","cullBackFaces","zOffsetUnits","mustReturn","_b","_bind","fillMode","setMatrix","getTransformMatrix","getWorldMatrix","setFloat4","r","g","b","a","bindForSubMesh","setTexture","textureMatrix","getTextureMatrix","setFloat","level","boneTexture","getTransformMatrixTexture","setMatrices","getTransformMatrices","BindMorphTargetParameters","alphaMode","_processRendering","isInstance","world","resetRefreshCounter","_rebuild","vb","dispose","_releaseBuffer","indexOf","splice","getClassName","Parse","parsedEffectLayer","rootUrl","effectLayerType","Instantiate","customType","_","__decorate"],"sources":["../../../../dev/core/src/Layers/effectLayer.ts"],"sourcesContent":["import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/glowMapGeneration.fragment\";\r\nimport \"../Shaders/glowMapGeneration.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_INT\r\n     */\r\n    mainTextureType: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer: boolean;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or highlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    private _mergeDrawWrapper: DrawWrapper[];\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected _shouldRender = true;\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected _emissiveTextureAndColor: { texture: Nullable<BaseTexture>; color: Color4 } = { texture: null, color: new Color4() };\r\n    protected _effectIntensity: { [meshUniqueId: number]: number } = {};\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._effectLayerOptions.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._effectLayerOptions.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._effectLayerOptions.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * Gets the main texture where the effect is rendered\r\n     */\r\n    public get mainTexture() {\r\n        return this._mainTexture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"EffectLayerSceneComponent\");\r\n    };\r\n\r\n    private _materialForRendering: { [id: string]: [AbstractMesh, Material] } = {};\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._mainTexture.setMaterialForRendering(mesh, material);\r\n        if (Array.isArray(mesh)) {\r\n            for (let i = 0; i < mesh.length; ++i) {\r\n                const currentMesh = mesh[i];\r\n                if (!material) {\r\n                    delete this._materialForRendering[currentMesh.uniqueId];\r\n                } else {\r\n                    this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\r\n                }\r\n            }\r\n        } else {\r\n            if (!material) {\r\n                delete this._materialForRendering[mesh.uniqueId];\r\n            } else {\r\n                this._materialForRendering[mesh.uniqueId] = [mesh, material];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to get the effect intensity for\r\n     * @returns The intensity of the effect for the mesh\r\n     */\r\n    public getEffectIntensity(mesh: AbstractMesh) {\r\n        return this._effectIntensity[mesh.uniqueId] ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to set the effect intensity for\r\n     * @param intensity The intensity of the effect for the mesh\r\n     */\r\n    public setEffectIntensity(mesh: AbstractMesh, intensity: number): void {\r\n        this._effectIntensity[mesh.uniqueId] = intensity;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene?: Scene\r\n    ) {\r\n        this.name = name;\r\n\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderNum Index of the _internalRender call (0 for the first time _internalRender is called, 1 for the second time, etc. _internalRender is called the number of times returned by _numInternalDraws())\r\n     */\r\n    protected abstract _internalRender(effect: Effect, renderIndex: number): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\r\n     * @returns Number of times a mesh must be rendered in the layer\r\n     */\r\n    protected _numInternalDraws(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            generateStencilBuffer: false,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n    }\r\n\r\n    /**\r\n     * Generates the index buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        } else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize)\r\n                : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize)\r\n                : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\r\n            \"EffectLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            this._effectLayerOptions.mainTextureType,\r\n            false,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            true,\r\n            this._effectLayerOptions.generateStencilBuffer\r\n        );\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        for (const id in this._materialForRendering) {\r\n            const [mesh, material] = this._materialForRendering[id];\r\n            this._mainTexture.setMaterialForRendering(mesh, material);\r\n        }\r\n\r\n        this._mainTexture.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n                    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        this._mainTexture.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n\r\n            let index: number;\r\n\r\n            const engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMesh(transparentSubMeshes.data[index], true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n\r\n        this._mainTexture.onClearObservable.add((engine: Engine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n\r\n        // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\r\n        if (this._scene.getBoundingBoxRenderer) {\r\n            const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n\r\n            this._mainTexture.onBeforeBindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n            });\r\n\r\n            this._mainTexture.onAfterUnbindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\r\n            return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse =\r\n                diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n                if (!diffuseTexture.gammaSpace) {\r\n                    defines.push(\"#define DIFFUSE_ISLINEAR\");\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n            if (!emissiveTexture.gammaSpace) {\r\n                defines.push(\"#define EMISSIVE_ISLINEAR\");\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        let morphInfluencers = 0;\r\n        if (manager) {\r\n            if (manager.numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                morphInfluencers = manager.numInfluencers;\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\r\n                if (manager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // ClipPlanes\r\n        prepareStringDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines as string;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"viewProjection\",\r\n                \"glowColor\",\r\n                \"morphTargetInfluences\",\r\n                \"boneTextureWidth\",\r\n                \"diffuseMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"opacityMatrix\",\r\n                \"opacityIntensity\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"glowIntensity\",\r\n            ];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                this._engine.createEffect(\r\n                    \"glowMapGeneration\",\r\n                    attribs,\r\n                    uniforms,\r\n                    [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"],\r\n                    join,\r\n                    fallbacks,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: morphInfluencers }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (!this._postProcesses[i].isReady()) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        // Check\r\n        let isReady = true;\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            let currentEffect = this._mergeDrawWrapper[i];\r\n            if (!currentEffect) {\r\n                currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\r\n                currentEffect.setEffect(this._createMergeEffect());\r\n            }\r\n            isReady = isReady && currentEffect.effect!.isReady();\r\n        }\r\n\r\n        if (!isReady) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        const previousAlphaMode = engine.getAlphaMode();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            const currentEffect = this._mergeDrawWrapper[i];\r\n\r\n            // Render\r\n            engine.enableEffect(currentEffect);\r\n            engine.setState(false);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect!);\r\n\r\n            // Go Blend.\r\n            engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\r\n\r\n            // Blends the map on the main canvas.\r\n            this._internalRender(currentEffect.effect!, i);\r\n        }\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        // Handle size changes.\r\n        const size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (\r\n            (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) &&\r\n            this._mainTextureDesiredSize.width !== 0 &&\r\n            this._mainTextureDesiredSize.height !== 0\r\n        ) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh passed in parameter to the generation map.\r\n     * @param subMesh\r\n     * @param enableAlphaMode\r\n     */\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this.shouldRender()) {\r\n            return;\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = subMesh.getReplacementMesh();\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\r\n        } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n            let drawWrapper = subMesh._getDrawWrapper();\r\n            if (!drawWrapper && renderingMaterial) {\r\n                drawWrapper = renderingMaterial._getDrawWrapper();\r\n            }\r\n\r\n            if (!drawWrapper) {\r\n                return;\r\n            }\r\n\r\n            const effect = drawWrapper.effect!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n            if (!hardwareInstancedRendering) {\r\n                renderingMesh._bind(subMesh, effect, material.fillMode);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                effect.setFloat4(\r\n                    \"glowColor\",\r\n                    this._emissiveTextureAndColor.color.r,\r\n                    this._emissiveTextureAndColor.color.g,\r\n                    this._emissiveTextureAndColor.color.b,\r\n                    this._emissiveTextureAndColor.color.a\r\n                );\r\n            } else {\r\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                const needAlphaTest = material.needAlphaTesting();\r\n\r\n                const diffuseTexture = material.getAlphaTestTexture();\r\n                const needAlphaBlendFromDiffuse =\r\n                    diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n                if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                    effect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                    const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                const opacityTexture = (material as any).opacityTexture;\r\n                if (opacityTexture) {\r\n                    effect.setTexture(\"opacitySampler\", opacityTexture);\r\n                    effect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                    const textureMatrix = opacityTexture.getTextureMatrix();\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                // Glow emissive only\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                    effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Alpha mode\r\n                if (enableAlphaMode) {\r\n                    engine.setAlphaMode(material.alphaMode);\r\n                }\r\n\r\n                // Intensity of effect\r\n                effect.setFloat(\"glowIntensity\", this.getEffectIntensity(renderingMesh));\r\n\r\n                // Clip planes\r\n                bindClipPlane(effect, material, scene);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                effect.setMatrix(\"world\", world)\r\n            );\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._mainTexture.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @internal Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (let i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        for (const drawWrapper of this._mergeDrawWrapper) {\r\n            drawWrapper.dispose();\r\n        }\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        const index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}