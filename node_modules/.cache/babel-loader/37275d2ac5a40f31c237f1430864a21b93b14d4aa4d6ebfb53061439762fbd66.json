{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { Control } from \"./control.js\";\nimport { Measure } from \"../measure.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\nimport { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Matrix2D } from \"../math2D.js\";\n/**\n * Root class for 2D containers\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#containers\n */\nexport class Container extends Control {\n  /** Gets or sets boolean indicating if children should be rendered to an intermediate texture rather than directly to host, useful for alpha blending */\n  get renderToIntermediateTexture() {\n    return this._renderToIntermediateTexture;\n  }\n  set renderToIntermediateTexture(value) {\n    if (this._renderToIntermediateTexture === value) {\n      return;\n    }\n    this._renderToIntermediateTexture = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets a boolean indicating if the container should try to adapt to its children height */\n  get adaptHeightToChildren() {\n    return this._adaptHeightToChildren;\n  }\n  set adaptHeightToChildren(value) {\n    if (this._adaptHeightToChildren === value) {\n      return;\n    }\n    this._adaptHeightToChildren = value;\n    if (value) {\n      this.height = \"100%\";\n    }\n    this._markAsDirty();\n  }\n  /** Gets or sets a boolean indicating if the container should try to adapt to its children width */\n  get adaptWidthToChildren() {\n    return this._adaptWidthToChildren;\n  }\n  set adaptWidthToChildren(value) {\n    if (this._adaptWidthToChildren === value) {\n      return;\n    }\n    this._adaptWidthToChildren = value;\n    if (value) {\n      this.width = \"100%\";\n    }\n    this._markAsDirty();\n  }\n  /** Gets or sets background color */\n  get background() {\n    return this._background;\n  }\n  set background(value) {\n    if (this._background === value) {\n      return;\n    }\n    this._background = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets background gradient color. Takes precedence over background */\n  get backgroundGradient() {\n    return this._backgroundGradient;\n  }\n  set backgroundGradient(value) {\n    if (this._backgroundGradient === value) {\n      return;\n    }\n    this._backgroundGradient = value;\n    this._markAsDirty();\n  }\n  /** Gets the list of children */\n  get children() {\n    return this._children;\n  }\n  get isReadOnly() {\n    return this._isReadOnly;\n  }\n  set isReadOnly(value) {\n    this._isReadOnly = value;\n    for (const child of this._children) {\n      child.isReadOnly = value;\n    }\n  }\n  /**\n   * Creates a new Container\n   * @param name defines the name of the container\n   */\n  constructor(name) {\n    super(name);\n    this.name = name;\n    /** @internal */\n    this._children = new Array();\n    /** @internal */\n    this._measureForChildren = Measure.Empty();\n    /** @internal */\n    this._background = \"\";\n    /** @internal */\n    this._backgroundGradient = null;\n    /** @internal */\n    this._adaptWidthToChildren = false;\n    /** @internal */\n    this._adaptHeightToChildren = false;\n    /** @internal */\n    this._renderToIntermediateTexture = false;\n    /** @internal */\n    this._intermediateTexture = null;\n    /**\n     * Gets or sets a boolean indicating that layout cycle errors should be displayed on the console\n     */\n    this.logLayoutCycleErrors = false;\n    /**\n     * Gets or sets the number of layout cycles (a change involved by a control while evaluating the layout) allowed\n     */\n    this.maxLayoutCycle = 3;\n    /**\n     * An event triggered when any control is added to this container.\n     */\n    this.onControlAddedObservable = new Observable();\n    /**\n     * An event triggered when any control is removed from this container.\n     */\n    this.onControlRemovedObservable = new Observable();\n    this._inverseTransformMatrix = Matrix2D.Identity();\n    this._inverseMeasure = new Measure(0, 0, 0, 0);\n  }\n  _getTypeName() {\n    return \"Container\";\n  }\n  _flagDescendantsAsMatrixDirty() {\n    for (const child of this.children) {\n      child._isClipped = false;\n      child._markMatrixAsDirty();\n    }\n  }\n  /**\n   * Gets a child using its name\n   * @param name defines the child name to look for\n   * @returns the child control if found\n   */\n  getChildByName(name) {\n    for (const child of this.children) {\n      if (child.name === name) {\n        return child;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a child using its type and its name\n   * @param name defines the child name to look for\n   * @param type defines the child type to look for\n   * @returns the child control if found\n   */\n  getChildByType(name, type) {\n    for (const child of this.children) {\n      if (child.typeName === type) {\n        return child;\n      }\n    }\n    return null;\n  }\n  /**\n   * Search for a specific control in children\n   * @param control defines the control to look for\n   * @returns true if the control is in child list\n   */\n  containsControl(control) {\n    return this.children.indexOf(control) !== -1;\n  }\n  /**\n   * Adds a new control to the current container\n   * @param control defines the control to add\n   * @returns the current container\n   */\n  addControl(control) {\n    if (!control) {\n      return this;\n    }\n    const index = this._children.indexOf(control);\n    if (index !== -1) {\n      return this;\n    }\n    control._link(this._host);\n    control._markAllAsDirty();\n    this._reOrderControl(control);\n    this._markAsDirty();\n    this.onControlAddedObservable.notifyObservers(control);\n    return this;\n  }\n  /**\n   * Removes all controls from the current container\n   * @returns the current container\n   */\n  clearControls() {\n    const children = this.children.slice();\n    for (const child of children) {\n      this.removeControl(child);\n    }\n    return this;\n  }\n  /**\n   * Removes a control from the current container\n   * @param control defines the control to remove\n   * @returns the current container\n   */\n  removeControl(control) {\n    const index = this._children.indexOf(control);\n    if (index !== -1) {\n      this._children.splice(index, 1);\n      control.parent = null;\n    }\n    control.linkWithMesh(null);\n    if (this._host) {\n      this._host._cleanControlAfterRemoval(control);\n    }\n    this._markAsDirty();\n    this.onControlRemovedObservable.notifyObservers(control);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _reOrderControl(control) {\n    const linkedMesh = control.linkedMesh;\n    this.removeControl(control);\n    let wasAdded = false;\n    for (let index = 0; index < this._children.length; index++) {\n      if (this._children[index].zIndex > control.zIndex) {\n        this._children.splice(index, 0, control);\n        wasAdded = true;\n        break;\n      }\n    }\n    if (!wasAdded) {\n      this._children.push(control);\n    }\n    control.parent = this;\n    if (linkedMesh) {\n      control.linkWithMesh(linkedMesh);\n    }\n    this._markAsDirty();\n  }\n  /**\n   * @internal\n   */\n  _offsetLeft(offset) {\n    super._offsetLeft(offset);\n    for (const child of this._children) {\n      child._offsetLeft(offset);\n    }\n  }\n  /**\n   * @internal\n   */\n  _offsetTop(offset) {\n    super._offsetTop(offset);\n    for (const child of this._children) {\n      child._offsetTop(offset);\n    }\n  }\n  /** @internal */\n  _markAllAsDirty() {\n    super._markAllAsDirty();\n    for (let index = 0; index < this._children.length; index++) {\n      this._children[index]._markAllAsDirty();\n    }\n  }\n  _getBackgroundColor(context) {\n    return this._backgroundGradient ? this._backgroundGradient.getCanvasGradient(context) : this._background;\n  }\n  /**\n   * @internal\n   */\n  _localDraw(context) {\n    if (this._background || this._backgroundGradient) {\n      context.save();\n      if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n        context.shadowColor = this.shadowColor;\n        context.shadowBlur = this.shadowBlur;\n        context.shadowOffsetX = this.shadowOffsetX;\n        context.shadowOffsetY = this.shadowOffsetY;\n      }\n      context.fillStyle = this._getBackgroundColor(context);\n      context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n      context.restore();\n    }\n  }\n  /**\n   * @internal\n   */\n  _link(host) {\n    super._link(host);\n    for (const child of this._children) {\n      child._link(host);\n    }\n  }\n  /** @internal */\n  _beforeLayout() {\n    // Do nothing\n  }\n  /**\n   * @internal\n   */\n  _processMeasures(parentMeasure, context) {\n    if (this._isDirty || !this._cachedParentMeasure.isEqualsTo(parentMeasure)) {\n      super._processMeasures(parentMeasure, context);\n      this._evaluateClippingState(parentMeasure);\n      if (this._renderToIntermediateTexture) {\n        if (this._intermediateTexture && this._host.getScene() != this._intermediateTexture.getScene()) {\n          this._intermediateTexture.dispose();\n          this._intermediateTexture = null;\n        }\n        if (!this._intermediateTexture) {\n          this._intermediateTexture = new DynamicTexture(\"\", {\n            width: this._currentMeasure.width,\n            height: this._currentMeasure.height\n          }, this._host.getScene(), false, Texture.NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA, false);\n          this._intermediateTexture.hasAlpha = true;\n        } else {\n          this._intermediateTexture.scaleTo(this._currentMeasure.width, this._currentMeasure.height);\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _layout(parentMeasure, context) {\n    var _a, _b;\n    if (!this.isDirty && (!this.isVisible || this.notRenderable)) {\n      return false;\n    }\n    this.host._numLayoutCalls++;\n    if (this._isDirty) {\n      this._currentMeasure.transformToRef(this._transformMatrix, this._prevCurrentMeasureTransformedIntoGlobalSpace);\n    }\n    let rebuildCount = 0;\n    context.save();\n    this._applyStates(context);\n    this._beforeLayout();\n    do {\n      let computedWidth = -1;\n      let computedHeight = -1;\n      this._rebuildLayout = false;\n      this._processMeasures(parentMeasure, context);\n      if (!this._isClipped) {\n        for (const child of this._children) {\n          child._tempParentMeasure.copyFrom(this._measureForChildren);\n          if (child._layout(this._measureForChildren, context)) {\n            if (child.isVisible && !child.notRenderable) {\n              if (this.adaptWidthToChildren && child._width.isPixel) {\n                computedWidth = Math.max(computedWidth, child._currentMeasure.width + child._paddingLeftInPixels + child._paddingRightInPixels);\n              }\n              if (this.adaptHeightToChildren && child._height.isPixel) {\n                computedHeight = Math.max(computedHeight, child._currentMeasure.height + child._paddingTopInPixels + child._paddingBottomInPixels);\n              }\n            }\n          }\n        }\n        if (this.adaptWidthToChildren && computedWidth >= 0) {\n          computedWidth += this.paddingLeftInPixels + this.paddingRightInPixels;\n          if (this.width !== computedWidth + \"px\") {\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a._markAsDirty();\n            this.width = computedWidth + \"px\";\n            this._width.ignoreAdaptiveScaling = true;\n            this._rebuildLayout = true;\n          }\n        }\n        if (this.adaptHeightToChildren && computedHeight >= 0) {\n          computedHeight += this.paddingTopInPixels + this.paddingBottomInPixels;\n          if (this.height !== computedHeight + \"px\") {\n            (_b = this.parent) === null || _b === void 0 ? void 0 : _b._markAsDirty();\n            this.height = computedHeight + \"px\";\n            this._height.ignoreAdaptiveScaling = true;\n            this._rebuildLayout = true;\n          }\n        }\n        this._postMeasure();\n      }\n      rebuildCount++;\n    } while (this._rebuildLayout && rebuildCount < this.maxLayoutCycle);\n    if (rebuildCount >= 3 && this.logLayoutCycleErrors) {\n      Logger.Error(`Layout cycle detected in GUI (Container name=${this.name}, uniqueId=${this.uniqueId})`);\n    }\n    context.restore();\n    if (this._isDirty) {\n      this.invalidateRect();\n      this._isDirty = false;\n    }\n    return true;\n  }\n  _postMeasure() {\n    // Do nothing by default\n  }\n  /**\n   * @internal\n   */\n  _draw(context, invalidatedRectangle) {\n    const renderToIntermediateTextureThisDraw = this._renderToIntermediateTexture && this._intermediateTexture;\n    const contextToDrawTo = renderToIntermediateTextureThisDraw ? this._intermediateTexture.getContext() : context;\n    if (renderToIntermediateTextureThisDraw) {\n      contextToDrawTo.save();\n      contextToDrawTo.translate(-this._currentMeasure.left, -this._currentMeasure.top);\n      if (invalidatedRectangle) {\n        this._transformMatrix.invertToRef(this._inverseTransformMatrix);\n        invalidatedRectangle.transformToRef(this._inverseTransformMatrix, this._inverseMeasure);\n        contextToDrawTo.clearRect(this._inverseMeasure.left, this._inverseMeasure.top, this._inverseMeasure.width, this._inverseMeasure.height);\n      } else {\n        contextToDrawTo.clearRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n      }\n    }\n    this._localDraw(contextToDrawTo);\n    context.save();\n    if (this.clipChildren) {\n      this._clipForChildren(contextToDrawTo);\n    }\n    for (const child of this._children) {\n      // Only redraw parts of the screen that are invalidated\n      if (invalidatedRectangle) {\n        if (!child._intersectsRect(invalidatedRectangle)) {\n          continue;\n        }\n      }\n      child._render(contextToDrawTo, invalidatedRectangle);\n    }\n    if (renderToIntermediateTextureThisDraw) {\n      contextToDrawTo.restore();\n      context.save();\n      context.globalAlpha = this.alpha;\n      context.drawImage(contextToDrawTo.canvas, this._currentMeasure.left, this._currentMeasure.top);\n      context.restore();\n    }\n    context.restore();\n  }\n  getDescendantsToRef(results, directDescendantsOnly = false, predicate) {\n    if (!this.children) {\n      return;\n    }\n    for (let index = 0; index < this.children.length; index++) {\n      const item = this.children[index];\n      if (!predicate || predicate(item)) {\n        results.push(item);\n      }\n      if (!directDescendantsOnly) {\n        item.getDescendantsToRef(results, false, predicate);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY) {\n    if (!this._isEnabled || !this.isVisible || this.notRenderable) {\n      return false;\n    }\n    // checks if the picking position is within the container\n    const contains = super.contains(x, y);\n    // if clipChildren is off, we should still pass picking events to children even if we don't contain the pointer\n    if (!contains && this.clipChildren) {\n      return false;\n    }\n    // Checking backwards to pick closest first\n    for (let index = this._children.length - 1; index >= 0; index--) {\n      const child = this._children[index];\n      if (child._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\n        if (child.hoverCursor) {\n          this._host._changeCursor(child.hoverCursor);\n        }\n        return true;\n      }\n    }\n    if (!contains) {\n      return false;\n    }\n    if (!this.isHitTestVisible) {\n      return false;\n    }\n    return this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);\n  }\n  /**\n   * @internal\n   */\n  _additionalProcessing(parentMeasure, context) {\n    super._additionalProcessing(parentMeasure, context);\n    this._measureForChildren.copyFrom(this._currentMeasure);\n  }\n  /**\n   * Serializes the current control\n   * @param serializationObject defined the JSON serialized object\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    if (this.backgroundGradient) {\n      serializationObject.backgroundGradient = {};\n      this.backgroundGradient.serialize(serializationObject.backgroundGradient);\n    }\n    if (!this.children.length) {\n      return;\n    }\n    serializationObject.children = [];\n    for (const child of this.children) {\n      const childSerializationObject = {};\n      child.serialize(childSerializationObject);\n      serializationObject.children.push(childSerializationObject);\n    }\n  }\n  /** Releases associated resources */\n  dispose() {\n    var _a;\n    super.dispose();\n    for (let index = this.children.length - 1; index >= 0; index--) {\n      this.children[index].dispose();\n    }\n    (_a = this._intermediateTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n  /**\n   * @internal\n   */\n  _parseFromContent(serializedObject, host) {\n    var _a;\n    super._parseFromContent(serializedObject, host);\n    this._link(host);\n    // Gradient\n    if (serializedObject.backgroundGradient) {\n      const className = Tools.Instantiate(\"BABYLON.GUI.\" + serializedObject.backgroundGradient.className);\n      this._backgroundGradient = new className();\n      (_a = this._backgroundGradient) === null || _a === void 0 ? void 0 : _a.parse(serializedObject.backgroundGradient);\n    }\n    if (!serializedObject.children) {\n      return;\n    }\n    for (const childData of serializedObject.children) {\n      this.addControl(Control.Parse(childData, host));\n    }\n  }\n  isReady() {\n    for (const child of this.children) {\n      if (!child.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n__decorate([serialize()], Container.prototype, \"renderToIntermediateTexture\", null);\n__decorate([serialize()], Container.prototype, \"maxLayoutCycle\", void 0);\n__decorate([serialize()], Container.prototype, \"adaptHeightToChildren\", null);\n__decorate([serialize()], Container.prototype, \"adaptWidthToChildren\", null);\n__decorate([serialize()], Container.prototype, \"background\", null);\n__decorate([serialize()], Container.prototype, \"backgroundGradient\", null);\nRegisterClass(\"BABYLON.GUI.Container\", Container);","map":{"version":3,"names":["Logger","Control","Measure","RegisterClass","serialize","DynamicTexture","Texture","Constants","Observable","Tools","Matrix2D","Container","renderToIntermediateTexture","_renderToIntermediateTexture","value","_markAsDirty","adaptHeightToChildren","_adaptHeightToChildren","height","adaptWidthToChildren","_adaptWidthToChildren","width","background","_background","backgroundGradient","_backgroundGradient","children","_children","isReadOnly","_isReadOnly","child","constructor","name","Array","_measureForChildren","Empty","_intermediateTexture","logLayoutCycleErrors","maxLayoutCycle","onControlAddedObservable","onControlRemovedObservable","_inverseTransformMatrix","Identity","_inverseMeasure","_getTypeName","_flagDescendantsAsMatrixDirty","_isClipped","_markMatrixAsDirty","getChildByName","getChildByType","type","typeName","containsControl","control","indexOf","addControl","index","_link","_host","_markAllAsDirty","_reOrderControl","notifyObservers","clearControls","slice","removeControl","splice","parent","linkWithMesh","_cleanControlAfterRemoval","linkedMesh","wasAdded","length","zIndex","push","_offsetLeft","offset","_offsetTop","_getBackgroundColor","context","getCanvasGradient","_localDraw","save","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","fillStyle","fillRect","_currentMeasure","left","top","restore","host","_beforeLayout","_processMeasures","parentMeasure","_isDirty","_cachedParentMeasure","isEqualsTo","_evaluateClippingState","getScene","dispose","NEAREST_SAMPLINGMODE","TEXTUREFORMAT_RGBA","hasAlpha","scaleTo","_layout","isDirty","isVisible","notRenderable","_numLayoutCalls","transformToRef","_transformMatrix","_prevCurrentMeasureTransformedIntoGlobalSpace","rebuildCount","_applyStates","computedWidth","computedHeight","_rebuildLayout","_tempParentMeasure","copyFrom","_width","isPixel","Math","max","_paddingLeftInPixels","_paddingRightInPixels","_height","_paddingTopInPixels","_paddingBottomInPixels","paddingLeftInPixels","paddingRightInPixels","_a","ignoreAdaptiveScaling","paddingTopInPixels","paddingBottomInPixels","_b","_postMeasure","Error","uniqueId","invalidateRect","_draw","invalidatedRectangle","renderToIntermediateTextureThisDraw","contextToDrawTo","getContext","translate","invertToRef","clearRect","clipChildren","_clipForChildren","_intersectsRect","_render","globalAlpha","alpha","drawImage","canvas","getDescendantsToRef","results","directDescendantsOnly","predicate","item","_processPicking","x","y","pi","pointerId","buttonIndex","deltaX","deltaY","_isEnabled","contains","hoverCursor","_changeCursor","isHitTestVisible","_processObservables","_additionalProcessing","serializationObject","childSerializationObject","_parseFromContent","serializedObject","className","Instantiate","parse","childData","Parse","isReady","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/container.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { Measure } from \"../measure\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { BaseGradient } from \"./gradient/BaseGradient\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Matrix2D } from \"../math2D\";\r\n\r\n/**\r\n * Root class for 2D containers\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#containers\r\n */\r\nexport class Container extends Control {\r\n    /** @internal */\r\n    public _children = new Array<Control>();\r\n    /** @internal */\r\n    protected _measureForChildren = Measure.Empty();\r\n    /** @internal */\r\n    protected _background = \"\";\r\n    /** @internal */\r\n    protected _backgroundGradient: Nullable<BaseGradient> = null;\r\n    /** @internal */\r\n    protected _adaptWidthToChildren = false;\r\n    /** @internal */\r\n    protected _adaptHeightToChildren = false;\r\n    /** @internal */\r\n    protected _renderToIntermediateTexture: boolean = false;\r\n    /** @internal */\r\n    protected _intermediateTexture: Nullable<DynamicTexture> = null;\r\n\r\n    /** Gets or sets boolean indicating if children should be rendered to an intermediate texture rather than directly to host, useful for alpha blending */\r\n    @serialize()\r\n    public get renderToIntermediateTexture(): boolean {\r\n        return this._renderToIntermediateTexture;\r\n    }\r\n    public set renderToIntermediateTexture(value: boolean) {\r\n        if (this._renderToIntermediateTexture === value) {\r\n            return;\r\n        }\r\n        this._renderToIntermediateTexture = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that layout cycle errors should be displayed on the console\r\n     */\r\n    public logLayoutCycleErrors = false;\r\n\r\n    /**\r\n     * Gets or sets the number of layout cycles (a change involved by a control while evaluating the layout) allowed\r\n     */\r\n    @serialize()\r\n    public maxLayoutCycle = 3;\r\n\r\n    /** Gets or sets a boolean indicating if the container should try to adapt to its children height */\r\n    @serialize()\r\n    public get adaptHeightToChildren(): boolean {\r\n        return this._adaptHeightToChildren;\r\n    }\r\n\r\n    public set adaptHeightToChildren(value: boolean) {\r\n        if (this._adaptHeightToChildren === value) {\r\n            return;\r\n        }\r\n\r\n        this._adaptHeightToChildren = value;\r\n\r\n        if (value) {\r\n            this.height = \"100%\";\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the container should try to adapt to its children width */\r\n    @serialize()\r\n    public get adaptWidthToChildren(): boolean {\r\n        return this._adaptWidthToChildren;\r\n    }\r\n\r\n    public set adaptWidthToChildren(value: boolean) {\r\n        if (this._adaptWidthToChildren === value) {\r\n            return;\r\n        }\r\n\r\n        this._adaptWidthToChildren = value;\r\n\r\n        if (value) {\r\n            this.width = \"100%\";\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background gradient color. Takes precedence over background */\r\n    @serialize()\r\n    public get backgroundGradient() {\r\n        return this._backgroundGradient;\r\n    }\r\n\r\n    public set backgroundGradient(value: Nullable<BaseGradient>) {\r\n        if (this._backgroundGradient === value) {\r\n            return;\r\n        }\r\n        this._backgroundGradient = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets the list of children */\r\n    public get children(): Control[] {\r\n        return this._children;\r\n    }\r\n\r\n    public get isReadOnly() {\r\n        return this._isReadOnly;\r\n    }\r\n\r\n    public set isReadOnly(value: boolean) {\r\n        this._isReadOnly = value;\r\n\r\n        for (const child of this._children) {\r\n            child.isReadOnly = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new Container\r\n     * @param name defines the name of the container\r\n     */\r\n    constructor(public name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Container\";\r\n    }\r\n\r\n    public _flagDescendantsAsMatrixDirty(): void {\r\n        for (const child of this.children) {\r\n            child._isClipped = false;\r\n            child._markMatrixAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a child using its name\r\n     * @param name defines the child name to look for\r\n     * @returns the child control if found\r\n     */\r\n    public getChildByName(name: string): Nullable<Control> {\r\n        for (const child of this.children) {\r\n            if (child.name === name) {\r\n                return child;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a child using its type and its name\r\n     * @param name defines the child name to look for\r\n     * @param type defines the child type to look for\r\n     * @returns the child control if found\r\n     */\r\n    public getChildByType(name: string, type: string): Nullable<Control> {\r\n        for (const child of this.children) {\r\n            if (child.typeName === type) {\r\n                return child;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search for a specific control in children\r\n     * @param control defines the control to look for\r\n     * @returns true if the control is in child list\r\n     */\r\n    public containsControl(control: Control): boolean {\r\n        return this.children.indexOf(control) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Adds a new control to the current container\r\n     * @param control defines the control to add\r\n     * @returns the current container\r\n     */\r\n    public addControl(control: Nullable<Control>): Container {\r\n        if (!control) {\r\n            return this;\r\n        }\r\n\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            return this;\r\n        }\r\n        control._link(this._host);\r\n\r\n        control._markAllAsDirty();\r\n\r\n        this._reOrderControl(control);\r\n\r\n        this._markAsDirty();\r\n\r\n        this.onControlAddedObservable.notifyObservers(control);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes all controls from the current container\r\n     * @returns the current container\r\n     */\r\n    public clearControls(): Container {\r\n        const children = this.children.slice();\r\n\r\n        for (const child of children) {\r\n            this.removeControl(child);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the current container\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public removeControl(control: Control): Container {\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            this._children.splice(index, 1);\r\n\r\n            control.parent = null;\r\n        }\r\n\r\n        control.linkWithMesh(null);\r\n\r\n        if (this._host) {\r\n            this._host._cleanControlAfterRemoval(control);\r\n        }\r\n\r\n        this._markAsDirty();\r\n\r\n        this.onControlRemovedObservable.notifyObservers(control);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when any control is added to this container.\r\n     */\r\n    public onControlAddedObservable = new Observable<Nullable<Control>>();\r\n\r\n    /**\r\n     * An event triggered when any control is removed from this container.\r\n     */\r\n    public onControlRemovedObservable = new Observable<Nullable<Control>>();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _reOrderControl(control: Control): void {\r\n        const linkedMesh = control.linkedMesh;\r\n\r\n        this.removeControl(control);\r\n\r\n        let wasAdded = false;\r\n        for (let index = 0; index < this._children.length; index++) {\r\n            if (this._children[index].zIndex > control.zIndex) {\r\n                this._children.splice(index, 0, control);\r\n                wasAdded = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!wasAdded) {\r\n            this._children.push(control);\r\n        }\r\n\r\n        control.parent = this;\r\n\r\n        if (linkedMesh) {\r\n            control.linkWithMesh(linkedMesh);\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _offsetLeft(offset: number) {\r\n        super._offsetLeft(offset);\r\n\r\n        for (const child of this._children) {\r\n            child._offsetLeft(offset);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _offsetTop(offset: number) {\r\n        super._offsetTop(offset);\r\n\r\n        for (const child of this._children) {\r\n            child._offsetTop(offset);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAllAsDirty(): void {\r\n        super._markAllAsDirty();\r\n\r\n        for (let index = 0; index < this._children.length; index++) {\r\n            this._children[index]._markAllAsDirty();\r\n        }\r\n    }\r\n\r\n    protected _getBackgroundColor(context: ICanvasRenderingContext) {\r\n        return this._backgroundGradient ? this._backgroundGradient.getCanvasGradient(context) : this._background;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _localDraw(context: ICanvasRenderingContext): void {\r\n        if (this._background || this._backgroundGradient) {\r\n            context.save();\r\n            if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n                context.shadowColor = this.shadowColor;\r\n                context.shadowBlur = this.shadowBlur;\r\n                context.shadowOffsetX = this.shadowOffsetX;\r\n                context.shadowOffsetY = this.shadowOffsetY;\r\n            }\r\n\r\n            context.fillStyle = this._getBackgroundColor(context);\r\n\r\n            context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            context.restore();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _link(host: AdvancedDynamicTexture): void {\r\n        super._link(host);\r\n\r\n        for (const child of this._children) {\r\n            child._link(host);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    protected _beforeLayout() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (this._isDirty || !this._cachedParentMeasure.isEqualsTo(parentMeasure)) {\r\n            super._processMeasures(parentMeasure, context);\r\n            this._evaluateClippingState(parentMeasure);\r\n            if (this._renderToIntermediateTexture) {\r\n                if (this._intermediateTexture && this._host.getScene() != this._intermediateTexture.getScene()) {\r\n                    this._intermediateTexture.dispose();\r\n                    this._intermediateTexture = null;\r\n                }\r\n                if (!this._intermediateTexture) {\r\n                    this._intermediateTexture = new DynamicTexture(\r\n                        \"\",\r\n                        { width: this._currentMeasure.width, height: this._currentMeasure.height },\r\n                        this._host.getScene(),\r\n                        false,\r\n                        Texture.NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTUREFORMAT_RGBA,\r\n                        false\r\n                    );\r\n                    this._intermediateTexture.hasAlpha = true;\r\n                } else {\r\n                    this._intermediateTexture.scaleTo(this._currentMeasure.width, this._currentMeasure.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _layout(parentMeasure: Measure, context: ICanvasRenderingContext): boolean {\r\n        if (!this.isDirty && (!this.isVisible || this.notRenderable)) {\r\n            return false;\r\n        }\r\n\r\n        this.host._numLayoutCalls++;\r\n\r\n        if (this._isDirty) {\r\n            this._currentMeasure.transformToRef(this._transformMatrix, this._prevCurrentMeasureTransformedIntoGlobalSpace);\r\n        }\r\n\r\n        let rebuildCount = 0;\r\n\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        this._beforeLayout();\r\n\r\n        do {\r\n            let computedWidth = -1;\r\n            let computedHeight = -1;\r\n            this._rebuildLayout = false;\r\n            this._processMeasures(parentMeasure, context);\r\n\r\n            if (!this._isClipped) {\r\n                for (const child of this._children) {\r\n                    child._tempParentMeasure.copyFrom(this._measureForChildren);\r\n\r\n                    if (child._layout(this._measureForChildren, context)) {\r\n                        if (child.isVisible && !child.notRenderable) {\r\n                            if (this.adaptWidthToChildren && child._width.isPixel) {\r\n                                computedWidth = Math.max(computedWidth, child._currentMeasure.width + child._paddingLeftInPixels + child._paddingRightInPixels);\r\n                            }\r\n                            if (this.adaptHeightToChildren && child._height.isPixel) {\r\n                                computedHeight = Math.max(computedHeight, child._currentMeasure.height + child._paddingTopInPixels + child._paddingBottomInPixels);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.adaptWidthToChildren && computedWidth >= 0) {\r\n                    computedWidth += this.paddingLeftInPixels + this.paddingRightInPixels;\r\n                    if (this.width !== computedWidth + \"px\") {\r\n                        this.parent?._markAsDirty();\r\n                        this.width = computedWidth + \"px\";\r\n                        this._width.ignoreAdaptiveScaling = true;\r\n                        this._rebuildLayout = true;\r\n                    }\r\n                }\r\n                if (this.adaptHeightToChildren && computedHeight >= 0) {\r\n                    computedHeight += this.paddingTopInPixels + this.paddingBottomInPixels;\r\n                    if (this.height !== computedHeight + \"px\") {\r\n                        this.parent?._markAsDirty();\r\n                        this.height = computedHeight + \"px\";\r\n                        this._height.ignoreAdaptiveScaling = true;\r\n                        this._rebuildLayout = true;\r\n                    }\r\n                }\r\n\r\n                this._postMeasure();\r\n            }\r\n            rebuildCount++;\r\n        } while (this._rebuildLayout && rebuildCount < this.maxLayoutCycle);\r\n\r\n        if (rebuildCount >= 3 && this.logLayoutCycleErrors) {\r\n            Logger.Error(`Layout cycle detected in GUI (Container name=${this.name}, uniqueId=${this.uniqueId})`);\r\n        }\r\n\r\n        context.restore();\r\n\r\n        if (this._isDirty) {\r\n            this.invalidateRect();\r\n\r\n            this._isDirty = false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _postMeasure() {\r\n        // Do nothing by default\r\n    }\r\n\r\n    private _inverseTransformMatrix = Matrix2D.Identity();\r\n    private _inverseMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(context: ICanvasRenderingContext, invalidatedRectangle?: Measure): void {\r\n        const renderToIntermediateTextureThisDraw = this._renderToIntermediateTexture && this._intermediateTexture;\r\n        const contextToDrawTo = renderToIntermediateTextureThisDraw ? (<DynamicTexture>this._intermediateTexture).getContext() : context;\r\n\r\n        if (renderToIntermediateTextureThisDraw) {\r\n            contextToDrawTo.save();\r\n            contextToDrawTo.translate(-this._currentMeasure.left, -this._currentMeasure.top);\r\n            if (invalidatedRectangle) {\r\n                this._transformMatrix.invertToRef(this._inverseTransformMatrix);\r\n                invalidatedRectangle.transformToRef(this._inverseTransformMatrix, this._inverseMeasure);\r\n                contextToDrawTo.clearRect(this._inverseMeasure.left, this._inverseMeasure.top, this._inverseMeasure.width, this._inverseMeasure.height);\r\n            } else {\r\n                contextToDrawTo.clearRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n        }\r\n\r\n        this._localDraw(contextToDrawTo);\r\n\r\n        context.save();\r\n\r\n        if (this.clipChildren) {\r\n            this._clipForChildren(contextToDrawTo);\r\n        }\r\n\r\n        for (const child of this._children) {\r\n            // Only redraw parts of the screen that are invalidated\r\n            if (invalidatedRectangle) {\r\n                if (!child._intersectsRect(invalidatedRectangle)) {\r\n                    continue;\r\n                }\r\n            }\r\n            child._render(contextToDrawTo, invalidatedRectangle);\r\n        }\r\n\r\n        if (renderToIntermediateTextureThisDraw) {\r\n            contextToDrawTo.restore();\r\n            context.save();\r\n            context.globalAlpha = this.alpha;\r\n            context.drawImage(contextToDrawTo.canvas, this._currentMeasure.left, this._currentMeasure.top);\r\n            context.restore();\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    public getDescendantsToRef(results: Control[], directDescendantsOnly: boolean = false, predicate?: (control: Control) => boolean): void {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            const item = this.children[index];\r\n\r\n            if (!predicate || predicate(item)) {\r\n                results.push(item);\r\n            }\r\n\r\n            if (!directDescendantsOnly) {\r\n                item.getDescendantsToRef(results, false, predicate);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _processPicking(x: number, y: number, pi: Nullable<PointerInfoBase>, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): boolean {\r\n        if (!this._isEnabled || !this.isVisible || this.notRenderable) {\r\n            return false;\r\n        }\r\n\r\n        // checks if the picking position is within the container\r\n        const contains = super.contains(x, y);\r\n\r\n        // if clipChildren is off, we should still pass picking events to children even if we don't contain the pointer\r\n        if (!contains && this.clipChildren) {\r\n            return false;\r\n        }\r\n\r\n        // Checking backwards to pick closest first\r\n        for (let index = this._children.length - 1; index >= 0; index--) {\r\n            const child = this._children[index];\r\n            if (child._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\r\n                if (child.hoverCursor) {\r\n                    this._host._changeCursor(child.hoverCursor);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!contains) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.isHitTestVisible) {\r\n            return false;\r\n        }\r\n\r\n        return this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._measureForChildren.copyFrom(this._currentMeasure);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current control\r\n     * @param serializationObject defined the JSON serialized object\r\n     */\r\n    public serialize(serializationObject: any) {\r\n        super.serialize(serializationObject);\r\n\r\n        if (this.backgroundGradient) {\r\n            serializationObject.backgroundGradient = {};\r\n            this.backgroundGradient.serialize(serializationObject.backgroundGradient);\r\n        }\r\n\r\n        if (!this.children.length) {\r\n            return;\r\n        }\r\n\r\n        serializationObject.children = [];\r\n\r\n        for (const child of this.children) {\r\n            const childSerializationObject = {};\r\n            child.serialize(childSerializationObject);\r\n            serializationObject.children.push(childSerializationObject);\r\n        }\r\n    }\r\n\r\n    /** Releases associated resources */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        for (let index = this.children.length - 1; index >= 0; index--) {\r\n            this.children[index].dispose();\r\n        }\r\n        this._intermediateTexture?.dispose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializedObject, host);\r\n        this._link(host);\r\n\r\n        // Gradient\r\n        if (serializedObject.backgroundGradient) {\r\n            const className = Tools.Instantiate(\"BABYLON.GUI.\" + serializedObject.backgroundGradient.className);\r\n            this._backgroundGradient = new className();\r\n            this._backgroundGradient?.parse(serializedObject.backgroundGradient);\r\n        }\r\n\r\n        if (!serializedObject.children) {\r\n            return;\r\n        }\r\n\r\n        for (const childData of serializedObject.children) {\r\n            this.addControl(Control.Parse(childData, host));\r\n        }\r\n    }\r\n\r\n    public isReady(): boolean {\r\n        for (const child of this.children) {\r\n            if (!child.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Container\", Container);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}