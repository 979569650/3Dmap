{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { FlowGraph } from \"./flowGraph.js\";\nimport { FlowGraphEventCoordinator } from \"./flowGraphEventCoordinator.js\";\n/**\n * @experimental\n * Parameters used to create a flow graph engine.\n */\nexport class IFlowGraphCoordinatorConfiguration {}\n/**\n * This class holds all of the existing flow graphs and is responsible for creating new ones.\n * It also handles starting/stopping multiple graphs and communication between them through an Event Coordinator\n */\nexport class FlowGraphCoordinator {\n  constructor(_config) {\n    var _a;\n    this._config = _config;\n    this._flowGraphs = [];\n    this.eventCoordinator = new FlowGraphEventCoordinator();\n    // When the scene is disposed, dispose all graphs currently running on it.\n    this._config.scene.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n    // Add itself to the SceneCoordinators list for the Inspector.\n    const coordinators = (_a = FlowGraphCoordinator.SceneCoordinators.get(this._config.scene)) !== null && _a !== void 0 ? _a : [];\n    coordinators.push(this);\n  }\n  /**\n   * Creates a new flow graph and adds it to the list of existing flow graphs\n   * @returns a new flow graph\n   */\n  createGraph() {\n    const graph = new FlowGraph({\n      scene: this._config.scene,\n      eventCoordinator: this.eventCoordinator\n    });\n    this._flowGraphs.push(graph);\n    return graph;\n  }\n  /**\n   * Removes a flow graph from the list of existing flow graphs and disposes it\n   * @param graph the graph to remove\n   */\n  removeGraph(graph) {\n    const index = this._flowGraphs.indexOf(graph);\n    if (index !== -1) {\n      graph.dispose();\n      this._flowGraphs.splice(index, 1);\n    }\n  }\n  /**\n   * Starts all graphs\n   */\n  start() {\n    this._flowGraphs.forEach(graph => graph.start());\n  }\n  /**\n   * Disposes all graphs\n   */\n  dispose() {\n    var _a;\n    this._flowGraphs.forEach(graph => graph.dispose());\n    this._flowGraphs.length = 0;\n    // Remove itself from the SceneCoordinators list for the Inspector.\n    const coordinators = (_a = FlowGraphCoordinator.SceneCoordinators.get(this._config.scene)) !== null && _a !== void 0 ? _a : [];\n    const index = coordinators.indexOf(this);\n    if (index !== -1) {\n      coordinators.splice(index, 1);\n    }\n  }\n  serialize(serializationObject, valueSerializeFunction) {\n    serializationObject._flowGraphs = [];\n    this._flowGraphs.forEach(graph => {\n      const serializedGraph = {};\n      graph.serialize(serializedGraph, valueSerializeFunction);\n      serializationObject._flowGraphs.push(serializedGraph);\n    });\n  }\n  static Parse(serializedObject, scene, valueParseFunction) {\n    var _a;\n    const coordinator = new FlowGraphCoordinator({\n      scene\n    });\n    (_a = serializedObject._flowGraphs) === null || _a === void 0 ? void 0 : _a.forEach(serializedGraph => {\n      FlowGraph.Parse(serializedGraph, coordinator, valueParseFunction);\n    });\n    return coordinator;\n  }\n}\n/**\n * @internal\n * A list of all the coordinators per scene. Will be used by the inspector\n */\nFlowGraphCoordinator.SceneCoordinators = new Map();","map":{"version":3,"names":["FlowGraph","FlowGraphEventCoordinator","IFlowGraphCoordinatorConfiguration","FlowGraphCoordinator","constructor","_config","_flowGraphs","eventCoordinator","scene","onDisposeObservable","add","dispose","coordinators","_a","SceneCoordinators","get","push","createGraph","graph","removeGraph","index","indexOf","splice","start","forEach","length","serialize","serializationObject","valueSerializeFunction","serializedGraph","Parse","serializedObject","valueParseFunction","coordinator","Map"],"sources":["../../../../dev/core/src/FlowGraph/flowGraphCoordinator.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { FlowGraph } from \"./flowGraph\";\r\nimport { FlowGraphEventCoordinator } from \"./flowGraphEventCoordinator\";\r\n\r\n/**\r\n * @experimental\r\n * Parameters used to create a flow graph engine.\r\n */\r\nexport class IFlowGraphCoordinatorConfiguration {\r\n    /**\r\n     * The scene that the flow graph engine belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n/**\r\n * This class holds all of the existing flow graphs and is responsible for creating new ones.\r\n * It also handles starting/stopping multiple graphs and communication between them through an Event Coordinator\r\n */\r\nexport class FlowGraphCoordinator {\r\n    /**\r\n     * @internal\r\n     * A list of all the coordinators per scene. Will be used by the inspector\r\n     */\r\n    public static readonly SceneCoordinators: Map<Scene, FlowGraphCoordinator[]> = new Map();\r\n\r\n    /**\r\n     * The event coordinator used by the flow graph coordinator.\r\n     */\r\n    public readonly eventCoordinator: FlowGraphEventCoordinator;\r\n    private readonly _flowGraphs: FlowGraph[] = [];\r\n\r\n    constructor(private _config: IFlowGraphCoordinatorConfiguration) {\r\n        this.eventCoordinator = new FlowGraphEventCoordinator();\r\n\r\n        // When the scene is disposed, dispose all graphs currently running on it.\r\n        this._config.scene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        // Add itself to the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this._config.scene) ?? [];\r\n        coordinators.push(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new flow graph and adds it to the list of existing flow graphs\r\n     * @returns a new flow graph\r\n     */\r\n    createGraph(): FlowGraph {\r\n        const graph = new FlowGraph({ scene: this._config.scene, eventCoordinator: this.eventCoordinator });\r\n        this._flowGraphs.push(graph);\r\n        return graph;\r\n    }\r\n\r\n    /**\r\n     * Removes a flow graph from the list of existing flow graphs and disposes it\r\n     * @param graph the graph to remove\r\n     */\r\n    removeGraph(graph: FlowGraph) {\r\n        const index = this._flowGraphs.indexOf(graph);\r\n        if (index !== -1) {\r\n            graph.dispose();\r\n            this._flowGraphs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts all graphs\r\n     */\r\n    start() {\r\n        this._flowGraphs.forEach((graph) => graph.start());\r\n    }\r\n\r\n    /**\r\n     * Disposes all graphs\r\n     */\r\n    dispose() {\r\n        this._flowGraphs.forEach((graph) => graph.dispose());\r\n        this._flowGraphs.length = 0;\r\n\r\n        // Remove itself from the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this._config.scene) ?? [];\r\n        const index = coordinators.indexOf(this);\r\n        if (index !== -1) {\r\n            coordinators.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    serialize(serializationObject: any, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject._flowGraphs = [];\r\n        this._flowGraphs.forEach((graph) => {\r\n            const serializedGraph = {};\r\n            graph.serialize(serializedGraph, valueSerializeFunction);\r\n            serializationObject._flowGraphs.push(serializedGraph);\r\n        });\r\n    }\r\n\r\n    public static Parse(serializedObject: any, scene: Scene, valueParseFunction?: (key: string, serializationObject: any, scene: Scene) => any) {\r\n        const coordinator = new FlowGraphCoordinator({ scene });\r\n        serializedObject._flowGraphs?.forEach((serializedGraph: any) => {\r\n            FlowGraph.Parse(serializedGraph, coordinator, valueParseFunction);\r\n        });\r\n        return coordinator;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}