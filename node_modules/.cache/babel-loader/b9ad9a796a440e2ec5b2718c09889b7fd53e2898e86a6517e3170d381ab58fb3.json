{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator.js\";\nimport { VertexData } from \"../../../Meshes/mesh.vertexData.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/**\n * Block used to extract unique positions from a geometry\n */\nexport class GeometryOptimizeBlock extends NodeGeometryBlock {\n  /**\n   * Creates a new GeometryOptimizeBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = true;\n    /**\n     * Define the epsilon used to compare similar positions\n     */\n    this.epsilon = Epsilon;\n    this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"GeometryOptimizeBlock\";\n  }\n  /**\n   * Gets the geometry component\n   */\n  get geometry() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      if (!this.geometry.isConnected) {\n        return null;\n      }\n      const vertexData = this.geometry.getConnectedValue(state);\n      const newPositions = [];\n      const newIndicesMap = {};\n      for (let index = 0; index < vertexData.positions.length; index += 3) {\n        const x = vertexData.positions[index];\n        const y = vertexData.positions[index + 1];\n        const z = vertexData.positions[index + 2];\n        // check if we already have it\n        let found = false;\n        for (let checkIndex = 0; checkIndex < newPositions.length; checkIndex += 3) {\n          if (Scalar.WithinEpsilon(x, newPositions[checkIndex], this.epsilon) && Scalar.WithinEpsilon(y, newPositions[checkIndex + 1], this.epsilon) && Scalar.WithinEpsilon(z, newPositions[checkIndex + 2], this.epsilon)) {\n            newIndicesMap[index / 3] = checkIndex / 3;\n            found = true;\n            continue;\n          }\n        }\n        if (!found) {\n          newIndicesMap[index / 3] = newPositions.length / 3;\n          newPositions.push(x, y, z);\n        }\n      }\n      const newVertexData = new VertexData();\n      newVertexData.positions = newPositions;\n      newVertexData.indices = vertexData.indices.map(index => newIndicesMap[index]);\n      return newVertexData;\n    };\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    codeString += `${this._codeVariableName}.epsilon = ${this.epsilon};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.evaluateContext = this.evaluateContext;\n    serializationObject.epsilon = this.epsilon;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.evaluateContext = serializationObject.evaluateContext;\n    this.epsilon = serializationObject.epsilon;\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], GeometryOptimizeBlock.prototype, \"evaluateContext\", void 0);\n__decorate([editableInPropertyPage(\"Epsilon\", PropertyTypeForEdition.Float, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], GeometryOptimizeBlock.prototype, \"epsilon\", void 0);\nRegisterClass(\"BABYLON.GeometryOptimizeBlock\", GeometryOptimizeBlock);","map":{"version":3,"names":["RegisterClass","NodeGeometryBlockConnectionPointTypes","NodeGeometryBlock","PropertyTypeForEdition","editableInPropertyPage","VertexData","Scalar","Epsilon","GeometryOptimizeBlock","constructor","name","evaluateContext","epsilon","registerInput","Geometry","registerOutput","getClassName","geometry","_inputs","output","_outputs","_buildBlock","state","func","isConnected","vertexData","getConnectedValue","newPositions","newIndicesMap","index","positions","length","x","y","z","found","checkIndex","WithinEpsilon","push","newVertexData","indices","map","_storedFunction","_storedValue","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","__decorate","Boolean","notifiers","rebuild","Float"],"sources":["../../../../../../dev/core/src/Meshes/Node/Blocks/geometryOptimizeBlock.ts"],"sourcesContent":["import { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport type { FloatArray } from \"../../../types\";\r\nimport { VertexData } from \"../../../Meshes/mesh.vertexData\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n/**\r\n * Block used to extract unique positions from a geometry\r\n */\r\nexport class GeometryOptimizeBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Define the epsilon used to compare similar positions\r\n     */\r\n    @editableInPropertyPage(\"Epsilon\", PropertyTypeForEdition.Float, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public epsilon = Epsilon;\r\n\r\n    /**\r\n     * Creates a new GeometryOptimizeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryOptimizeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            if (!this.geometry.isConnected) {\r\n                return null;\r\n            }\r\n            const vertexData = this.geometry.getConnectedValue(state);\r\n            const newPositions: FloatArray = [];\r\n            const newIndicesMap: { [key: number]: number } = {};\r\n\r\n            for (let index = 0; index < vertexData.positions.length; index += 3) {\r\n                const x = vertexData.positions[index];\r\n                const y = vertexData.positions[index + 1];\r\n                const z = vertexData.positions[index + 2];\r\n\r\n                // check if we already have it\r\n                let found = false;\r\n                for (let checkIndex = 0; checkIndex < newPositions.length; checkIndex += 3) {\r\n                    if (\r\n                        Scalar.WithinEpsilon(x, newPositions[checkIndex], this.epsilon) &&\r\n                        Scalar.WithinEpsilon(y, newPositions[checkIndex + 1], this.epsilon) &&\r\n                        Scalar.WithinEpsilon(z, newPositions[checkIndex + 2], this.epsilon)\r\n                    ) {\r\n                        newIndicesMap[index / 3] = checkIndex / 3;\r\n                        found = true;\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    newIndicesMap[index / 3] = newPositions.length / 3;\r\n                    newPositions.push(x, y, z);\r\n                }\r\n            }\r\n            const newVertexData = new VertexData();\r\n            newVertexData.positions = newPositions;\r\n            newVertexData.indices = vertexData.indices.map((index: number) => newIndicesMap[index]);\r\n\r\n            return newVertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        codeString += `${this._codeVariableName}.epsilon = ${this.epsilon};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n        serializationObject.epsilon = this.epsilon;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n        this.epsilon = serializationObject.epsilon;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryOptimizeBlock\", GeometryOptimizeBlock);\r\n"],"mappings":";;AAAA,SAASA,aAAa,QAAQ,4BAA0B;AACxD,SAASC,qCAAqC,QAAQ,8CAA4C;AAClG,SAASC,iBAAiB,QAAQ,yBAAuB;AAEzD,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,sCAAoC;AAGnG,SAASC,UAAU,QAAQ,oCAAkC;AAC7D,SAASC,MAAM,QAAQ,+BAA6B;AACpD,SAASC,OAAO,QAAQ,kCAAgC;AACxD;;;AAGA,OAAM,MAAOC,qBAAsB,SAAQN,iBAAiB;EAcxD;;;;EAIAO,YAAmBC,IAAY;IAC3B,KAAK,CAACA,IAAI,CAAC;IAlBf;;;;IAKO,KAAAC,eAAe,GAAG,IAAI;IAE7B;;;IAIO,KAAAC,OAAO,GAAGL,OAAO;IASpB,IAAI,CAACM,aAAa,CAAC,UAAU,EAAEZ,qCAAqC,CAACa,QAAQ,CAAC;IAC9E,IAAI,CAACC,cAAc,CAAC,QAAQ,EAAEd,qCAAqC,CAACa,QAAQ,CAAC;EACjF;EAEA;;;;EAIOE,YAAYA,CAAA;IACf,OAAO,uBAAuB;EAClC;EAEA;;;EAGA,IAAWC,QAAQA,CAAA;IACf,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,MAAMA,CAAA;IACb,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEUC,WAAWA,CAACC,KAA6B;IAC/C,MAAMC,IAAI,GAAID,KAA6B,IAAI;MAC3C,IAAI,CAAC,IAAI,CAACL,QAAQ,CAACO,WAAW,EAAE;QAC5B,OAAO,IAAI;;MAEf,MAAMC,UAAU,GAAG,IAAI,CAACR,QAAQ,CAACS,iBAAiB,CAACJ,KAAK,CAAC;MACzD,MAAMK,YAAY,GAAe,EAAE;MACnC,MAAMC,aAAa,GAA8B,EAAE;MAEnD,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGJ,UAAU,CAACK,SAAS,CAACC,MAAM,EAAEF,KAAK,IAAI,CAAC,EAAE;QACjE,MAAMG,CAAC,GAAGP,UAAU,CAACK,SAAS,CAACD,KAAK,CAAC;QACrC,MAAMI,CAAC,GAAGR,UAAU,CAACK,SAAS,CAACD,KAAK,GAAG,CAAC,CAAC;QACzC,MAAMK,CAAC,GAAGT,UAAU,CAACK,SAAS,CAACD,KAAK,GAAG,CAAC,CAAC;QAEzC;QACA,IAAIM,KAAK,GAAG,KAAK;QACjB,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGT,YAAY,CAACI,MAAM,EAAEK,UAAU,IAAI,CAAC,EAAE;UACxE,IACI9B,MAAM,CAAC+B,aAAa,CAACL,CAAC,EAAEL,YAAY,CAACS,UAAU,CAAC,EAAE,IAAI,CAACxB,OAAO,CAAC,IAC/DN,MAAM,CAAC+B,aAAa,CAACJ,CAAC,EAAEN,YAAY,CAACS,UAAU,GAAG,CAAC,CAAC,EAAE,IAAI,CAACxB,OAAO,CAAC,IACnEN,MAAM,CAAC+B,aAAa,CAACH,CAAC,EAAEP,YAAY,CAACS,UAAU,GAAG,CAAC,CAAC,EAAE,IAAI,CAACxB,OAAO,CAAC,EACrE;YACEgB,aAAa,CAACC,KAAK,GAAG,CAAC,CAAC,GAAGO,UAAU,GAAG,CAAC;YACzCD,KAAK,GAAG,IAAI;YACZ;;;QAIR,IAAI,CAACA,KAAK,EAAE;UACRP,aAAa,CAACC,KAAK,GAAG,CAAC,CAAC,GAAGF,YAAY,CAACI,MAAM,GAAG,CAAC;UAClDJ,YAAY,CAACW,IAAI,CAACN,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;;;MAGlC,MAAMK,aAAa,GAAG,IAAIlC,UAAU,EAAE;MACtCkC,aAAa,CAACT,SAAS,GAAGH,YAAY;MACtCY,aAAa,CAACC,OAAO,GAAGf,UAAU,CAACe,OAAO,CAACC,GAAG,CAAEZ,KAAa,IAAKD,aAAa,CAACC,KAAK,CAAC,CAAC;MAEvF,OAAOU,aAAa;IACxB,CAAC;IAED,IAAI,IAAI,CAAC5B,eAAe,EAAE;MACtB,IAAI,CAACQ,MAAM,CAACuB,eAAe,GAAGnB,IAAI;KACrC,MAAM;MACH,IAAI,CAACJ,MAAM,CAACuB,eAAe,GAAG,IAAI;MAClC,IAAI,CAACvB,MAAM,CAACwB,YAAY,GAAGpB,IAAI,CAACD,KAAK,CAAC;;EAE9C;EAEUsB,mBAAmBA,CAAA;IACzB,IAAIC,UAAU,GAAG,KAAK,CAACD,mBAAmB,EAAE,GAAG,GAAG,IAAI,CAACE,iBAAiB,sBAAsB,IAAI,CAACnC,eAAe,GAAG,MAAM,GAAG,OAAO,KAAK;IAC1IkC,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,cAAc,IAAI,CAAClC,OAAO,KAAK;IACtE,OAAOiC,UAAU;EACrB;EAEA;;;;EAIOE,SAASA,CAAA;IACZ,MAAMC,mBAAmB,GAAG,KAAK,CAACD,SAAS,EAAE;IAE7CC,mBAAmB,CAACrC,eAAe,GAAG,IAAI,CAACA,eAAe;IAC1DqC,mBAAmB,CAACpC,OAAO,GAAG,IAAI,CAACA,OAAO;IAE1C,OAAOoC,mBAAmB;EAC9B;EAEOC,YAAYA,CAACD,mBAAwB;IACxC,KAAK,CAACC,YAAY,CAACD,mBAAmB,CAAC;IAEvC,IAAI,CAACrC,eAAe,GAAGqC,mBAAmB,CAACrC,eAAe;IAC1D,IAAI,CAACC,OAAO,GAAGoC,mBAAmB,CAACpC,OAAO;EAC9C;;AAjHOsC,UAAA,EADN9C,sBAAsB,CAAC,kBAAkB,EAAED,sBAAsB,CAACgD,OAAO,EAAE,UAAU,EAAE;EAAEC,SAAS,EAAE;IAAEC,OAAO,EAAE;EAAI;AAAE,CAAE,CAAC,C,6DAC3F;AAMvBH,UAAA,EADN9C,sBAAsB,CAAC,SAAS,EAAED,sBAAsB,CAACmD,KAAK,EAAE,UAAU,EAAE;EAAEF,SAAS,EAAE;IAAEC,OAAO,EAAE;EAAI;AAAE,CAAE,CAAC,C,qDACrF;AA8G7BrD,aAAa,CAAC,+BAA+B,EAAEQ,qBAAqB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}