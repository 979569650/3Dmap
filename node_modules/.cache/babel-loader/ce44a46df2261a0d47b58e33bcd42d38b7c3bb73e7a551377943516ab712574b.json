{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\n/**\n * Base block used as input for post process\n */\nexport class CurrentScreenBlock extends NodeMaterialBlock {\n  /**\n   * Create a new CurrentScreenBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this._samplerName = \"textureSampler\";\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\n     */\n    this.convertToGammaSpace = false;\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\n     */\n    this.convertToLinearSpace = false;\n    this._isUnique = false;\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[0]._prioritizeVertex = false;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"CurrentScreenBlock\";\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"textureSampler\");\n  }\n  get target() {\n    if (!this.uv.isConnected) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    if (this.uv.sourceBlock.isInput) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    return NodeMaterialBlockTargets.Fragment;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  _injectVertexCode(state) {\n    const uvInput = this.uv;\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\n      }\n    }\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    state._emitVaryingFromString(this._mainUVName, \"vec2\");\n    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\n    if (!this._outputs.some(o => o.isConnectedInVertexShader)) {\n      return;\n    }\n    this._writeTextureRead(state, true);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name, true);\n      }\n    }\n  }\n  _writeTextureRead(state, vertexMode = false) {\n    const uvInput = this.uv;\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\n      return;\n    }\n    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\n`;\n  }\n  _writeOutput(state, output, swizzle, vertexMode = false) {\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n    state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\n    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\n    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\n    state.compilationString += `#endif\\n`;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\n      state.sharedData.blockingBlocks.push(this);\n    }\n    if (state.sharedData.textureBlocks.indexOf(this) < 0) {\n      state.sharedData.textureBlocks.push(this);\n    }\n    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\n      state.sharedData.blocksWithDefines.push(this);\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      state._emit2DSampler(this._samplerName);\n      this._injectVertexCode(state);\n      return;\n    }\n    // Fragment\n    if (!this._outputs.some(o => o.isConnectedInFragmentShader)) {\n      return;\n    }\n    state._emit2DSampler(this._samplerName);\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    this._writeTextureRead(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","Texture","CurrentScreenBlock","constructor","name","VertexAndFragment","_samplerName","convertToGammaSpace","convertToLinearSpace","_isUnique","registerInput","AutoDetect","registerOutput","Color4","Neutral","Color3","Float","_inputs","addExcludedConnectionPointFromAllowedTypes","Vector2","Vector3","Vector4","_prioritizeVertex","getClassName","uv","rgba","_outputs","rgb","r","g","b","a","initialize","state","_excludeVariableName","target","isConnected","sourceBlock","isInput","Fragment","prepareDefines","mesh","nodeMaterial","defines","setValue","_linearDefineName","_gammaDefineName","isReady","texture","isReadyOrNotBlocking","_injectVertexCode","uvInput","connectedPoint","ownerBlock","uvInputOwnerBlock","isAttribute","_emitUniformFromString","associatedVariableName","_mainUVName","_emitVaryingFromString","compilationString","some","o","isConnectedInVertexShader","_writeTextureRead","output","hasEndpoints","_writeOutput","vertexMode","_tempTextureRead","swizzle","_declareOutput","_buildBlock","_getFreeVariableName","sharedData","blockingBlocks","indexOf","push","textureBlocks","blocksWithDefines","_emit2DSampler","isConnectedInFragmentShader","_getFreeDefineName","comments","_emitFunctionFromInclude","serialize","serializationObject","isRenderTarget","_deserialize","scene","rootUrl","url","Parse"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Dual/currentScreenBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\n\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\n\r\n/**\r\n * Base block used as input for post process\r\n */\r\nexport class CurrentScreenBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"textureSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _mainUVName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new CurrentScreenBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"CurrentScreenBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"textureSampler\");\r\n    }\r\n\r\n    public get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\r\n            }\r\n        }\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n\r\n        state._emitVaryingFromString(this._mainUVName, \"vec2\");\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\n`;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\r\n            state.sharedData.blockingBlocks.push(this);\r\n        }\r\n        if (state.sharedData.textureBlocks.indexOf(this) < 0) {\r\n            state.sharedData.textureBlocks.push(this);\r\n        }\r\n        if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            state._emit2DSampler(this._samplerName);\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}