{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { ValueAndUnit } from \"../valueAndUnit.js\";\nimport { Control } from \"./control.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\nimport { EngineStore } from \"@babylonjs/core/Engines/engineStore.js\";\n/**\n * Enum that determines the text-wrapping mode to use.\n */\nexport var TextWrapping;\n(function (TextWrapping) {\n  /**\n   * Clip the text when it's larger than Control.width; this is the default mode.\n   */\n  TextWrapping[TextWrapping[\"Clip\"] = 0] = \"Clip\";\n  /**\n   * Wrap the text word-wise, i.e. try to add line-breaks at word boundary to fit within Control.width.\n   */\n  TextWrapping[TextWrapping[\"WordWrap\"] = 1] = \"WordWrap\";\n  /**\n   * Ellipsize the text, i.e. shrink with trailing … when text is larger than Control.width.\n   */\n  TextWrapping[TextWrapping[\"Ellipsis\"] = 2] = \"Ellipsis\";\n  /**\n   * Wrap the text word-wise and clip the text when the text's height is larger than the Control.height, and shrink the last line with trailing … .\n   */\n  TextWrapping[TextWrapping[\"WordWrapEllipsis\"] = 3] = \"WordWrapEllipsis\";\n})(TextWrapping || (TextWrapping = {}));\n/**\n * Class used to create text block control\n */\nexport class TextBlock extends Control {\n  /**\n   * Return the line list (you may need to use the onLinesReadyObservable to make sure the list is ready)\n   */\n  get lines() {\n    return this._lines;\n  }\n  /**\n   * Gets or sets an boolean indicating that the TextBlock will be resized to fit its content\n    */\n  get resizeToFit() {\n    return this._resizeToFit;\n  }\n  /**\n   * Gets or sets an boolean indicating that the TextBlock will be resized to fit its content\n    */\n  set resizeToFit(value) {\n    if (this._resizeToFit === value) {\n      return;\n    }\n    this._resizeToFit = value;\n    if (this._resizeToFit) {\n      this._width.ignoreAdaptiveScaling = true;\n      this._height.ignoreAdaptiveScaling = true;\n    }\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets a boolean indicating if text must be wrapped\n   */\n  get textWrapping() {\n    return this._textWrapping;\n  }\n  /**\n   * Gets or sets a boolean indicating if text must be wrapped\n   */\n  set textWrapping(value) {\n    if (this._textWrapping === value) {\n      return;\n    }\n    this._textWrapping = +value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets text to display\n   */\n  get text() {\n    return this._text;\n  }\n  /**\n   * Gets or sets text to display\n   */\n  set text(value) {\n    if (this._text === value) {\n      return;\n    }\n    this._text = value + \"\"; // Making sure it is a text\n    this._markAsDirty();\n    this.onTextChangedObservable.notifyObservers(this);\n  }\n  /**\n   * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\n   */\n  get textHorizontalAlignment() {\n    return this._textHorizontalAlignment;\n  }\n  /**\n   * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\n   */\n  set textHorizontalAlignment(value) {\n    if (this._textHorizontalAlignment === value) {\n      return;\n    }\n    this._textHorizontalAlignment = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\n   */\n  get textVerticalAlignment() {\n    return this._textVerticalAlignment;\n  }\n  /**\n   * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\n   */\n  set textVerticalAlignment(value) {\n    if (this._textVerticalAlignment === value) {\n      return;\n    }\n    this._textVerticalAlignment = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets line spacing value\n   */\n  set lineSpacing(value) {\n    if (this._lineSpacing.fromString(value)) {\n      this._markAsDirty();\n    }\n  }\n  /**\n   * Gets or sets line spacing value\n   */\n  get lineSpacing() {\n    return this._lineSpacing.toString(this._host);\n  }\n  /**\n   * Gets or sets outlineWidth of the text to display\n   */\n  get outlineWidth() {\n    return this._outlineWidth;\n  }\n  /**\n   * Gets or sets outlineWidth of the text to display\n   */\n  set outlineWidth(value) {\n    if (this._outlineWidth === value) {\n      return;\n    }\n    this._outlineWidth = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets a boolean indicating that text must have underline\n   */\n  get underline() {\n    return this._underline;\n  }\n  /**\n   * Gets or sets a boolean indicating that text must have underline\n   */\n  set underline(value) {\n    if (this._underline === value) {\n      return;\n    }\n    this._underline = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets an boolean indicating that text must be crossed out\n   */\n  get lineThrough() {\n    return this._lineThrough;\n  }\n  /**\n   * Gets or sets an boolean indicating that text must be crossed out\n   */\n  set lineThrough(value) {\n    if (this._lineThrough === value) {\n      return;\n    }\n    this._lineThrough = value;\n    this._markAsDirty();\n  }\n  /**\n   * If the outline should be applied to the underline/strike-through too. Has different behavior in Edge/Chrome vs Firefox.\n   */\n  get applyOutlineToUnderline() {\n    return this._applyOutlineToUnderline;\n  }\n  set applyOutlineToUnderline(value) {\n    if (this._applyOutlineToUnderline === value) {\n      return;\n    }\n    this._applyOutlineToUnderline = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets outlineColor of the text to display\n   */\n  get outlineColor() {\n    return this._outlineColor;\n  }\n  /**\n   * Gets or sets outlineColor of the text to display\n   */\n  set outlineColor(value) {\n    if (this._outlineColor === value) {\n      return;\n    }\n    this._outlineColor = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets word divider\n   */\n  get wordDivider() {\n    return this._wordDivider;\n  }\n  /**\n   * Gets or sets word divider\n   */\n  set wordDivider(value) {\n    if (this._wordDivider === value) {\n      return;\n    }\n    this._wordDivider = value;\n    this._markAsDirty();\n  }\n  /**\n   * By default, if a text block has text wrapping other than Clip, its width\n   * is not resized even if resizeToFit = true. This parameter forces the width\n   * to be resized.\n   */\n  get forceResizeWidth() {\n    return this._forceResizeWidth;\n  }\n  set forceResizeWidth(value) {\n    if (this._forceResizeWidth === value) {\n      return;\n    }\n    this._forceResizeWidth = value;\n    this._markAsDirty();\n  }\n  /**\n   * Creates a new TextBlock object\n   * @param name defines the name of the control\n   * @param text defines the text to display (empty string by default)\n   */\n  constructor(\n  /**\n   * Defines the name of the control\n   */\n  name, text = \"\") {\n    super(name);\n    this.name = name;\n    this._text = \"\";\n    this._textWrapping = TextWrapping.Clip;\n    this._textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this._textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n    this._resizeToFit = false;\n    this._lineSpacing = new ValueAndUnit(0);\n    this._outlineWidth = 0;\n    this._outlineColor = \"white\";\n    this._underline = false;\n    this._lineThrough = false;\n    this._wordDivider = \" \";\n    this._forceResizeWidth = false;\n    this._applyOutlineToUnderline = false;\n    /**\n     * An event triggered after the text is changed\n     */\n    this.onTextChangedObservable = new Observable();\n    /**\n     * An event triggered after the text was broken up into lines\n     */\n    this.onLinesReadyObservable = new Observable();\n    this._linesTemp = [];\n    this.text = text;\n  }\n  _getTypeName() {\n    return \"TextBlock\";\n  }\n  _processMeasures(parentMeasure, context) {\n    if (!this._fontOffset || this.isDirty) {\n      this._fontOffset = Control._GetFontOffset(context.font);\n    }\n    super._processMeasures(parentMeasure, context);\n    // Prepare lines\n    this._lines = this._breakLines(this._currentMeasure.width, this._currentMeasure.height, context);\n    this.onLinesReadyObservable.notifyObservers(this);\n    let maxLineWidth = 0;\n    for (let i = 0; i < this._lines.length; i++) {\n      const line = this._lines[i];\n      if (line.width > maxLineWidth) {\n        maxLineWidth = line.width;\n      }\n    }\n    if (this._resizeToFit) {\n      if (this._textWrapping === TextWrapping.Clip || this._forceResizeWidth) {\n        const newWidth = Math.ceil(this._paddingLeftInPixels) + Math.ceil(this._paddingRightInPixels) + Math.ceil(maxLineWidth);\n        if (newWidth !== this._width.getValueInPixel(this._host, this._tempParentMeasure.width)) {\n          this._width.updateInPlace(newWidth, ValueAndUnit.UNITMODE_PIXEL);\n          this._rebuildLayout = true;\n        }\n      }\n      let newHeight = this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * this._lines.length | 0;\n      if (this._lines.length > 0 && this._lineSpacing.internalValue !== 0) {\n        let lineSpacing = 0;\n        if (this._lineSpacing.isPixel) {\n          lineSpacing = this._lineSpacing.getValue(this._host);\n        } else {\n          lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\n        }\n        newHeight += (this._lines.length - 1) * lineSpacing;\n      }\n      if (newHeight !== this._height.internalValue) {\n        this._height.updateInPlace(newHeight, ValueAndUnit.UNITMODE_PIXEL);\n        this._rebuildLayout = true;\n      }\n    }\n  }\n  _drawText(text, textWidth, y, context) {\n    const width = this._currentMeasure.width;\n    let x = 0;\n    switch (this._textHorizontalAlignment) {\n      case Control.HORIZONTAL_ALIGNMENT_LEFT:\n        x = 0;\n        break;\n      case Control.HORIZONTAL_ALIGNMENT_RIGHT:\n        x = width - textWidth;\n        break;\n      case Control.HORIZONTAL_ALIGNMENT_CENTER:\n        x = (width - textWidth) / 2;\n        break;\n    }\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n    }\n    if (this.outlineWidth) {\n      context.strokeText(text, this._currentMeasure.left + x, y);\n    }\n    context.fillText(text, this._currentMeasure.left + x, y);\n    if (this._underline) {\n      this._drawLine(this._currentMeasure.left + x, y + 3, this._currentMeasure.left + x + textWidth, y + 3, context);\n    }\n    if (this._lineThrough) {\n      this._drawLine(this._currentMeasure.left + x, y - this.fontSizeInPixels / 3, this._currentMeasure.left + x + textWidth, y - this.fontSizeInPixels / 3, context);\n    }\n  }\n  _drawLine(xFrom, yFrom, xTo, yTo, context) {\n    context.beginPath();\n    context.lineWidth = Math.round(this.fontSizeInPixels * 0.05);\n    context.moveTo(xFrom, yFrom);\n    context.lineTo(xTo, yTo);\n    if (this.outlineWidth && this.applyOutlineToUnderline) {\n      context.stroke();\n      context.fill();\n    } else {\n      const currentStroke = context.strokeStyle;\n      context.strokeStyle = context.fillStyle;\n      context.stroke();\n      context.strokeStyle = currentStroke;\n    }\n    context.closePath();\n  }\n  /**\n   * @internal\n   */\n  _draw(context) {\n    context.save();\n    this._applyStates(context);\n    // Render lines\n    this._renderLines(context);\n    context.restore();\n  }\n  _applyStates(context) {\n    super._applyStates(context);\n    if (this.outlineWidth) {\n      context.lineWidth = this.outlineWidth;\n      context.strokeStyle = this.outlineColor;\n      context.lineJoin = \"miter\";\n      context.miterLimit = 2;\n    }\n  }\n  _breakLines(refWidth, refHeight, context) {\n    this._linesTemp.length = 0;\n    const _lines = this.text.split(\"\\n\");\n    if (this._textWrapping === TextWrapping.Ellipsis) {\n      for (const _line of _lines) {\n        this._linesTemp.push(this._parseLineEllipsis(_line, refWidth, context));\n      }\n    } else if (this._textWrapping === TextWrapping.WordWrap) {\n      for (const _line of _lines) {\n        this._linesTemp.push(...this._parseLineWordWrap(_line, refWidth, context));\n      }\n    } else if (this._textWrapping === TextWrapping.WordWrapEllipsis) {\n      for (const _line of _lines) {\n        this._linesTemp.push(...this._parseLineWordWrapEllipsis(_line, refWidth, refHeight, context));\n      }\n    } else {\n      for (const _line of _lines) {\n        this._linesTemp.push(this._parseLine(_line, context));\n      }\n    }\n    return this._linesTemp;\n  }\n  _parseLine(line = \"\", context) {\n    return {\n      text: line,\n      width: this._getTextMetricsWidth(context.measureText(line))\n    };\n  }\n  //Calculate how many characters approximately we need to remove\n  _getCharsToRemove(lineWidth, width, lineLength) {\n    const diff = lineWidth > width ? lineWidth - width : 0;\n    // This isn't exact unless the font is monospaced\n    const charWidth = lineWidth / lineLength;\n    const removeChars = Math.max(Math.floor(diff / charWidth), 1);\n    return removeChars;\n  }\n  _parseLineEllipsis(line = \"\", width, context) {\n    let lineWidth = this._getTextMetricsWidth(context.measureText(line));\n    let removeChars = this._getCharsToRemove(lineWidth, width, line.length);\n    // unicode support. split('') does not work with unicode!\n    // make sure Array.from is available\n    const characters = Array.from && Array.from(line);\n    if (!characters) {\n      // no array.from, use the old method\n      while (line.length > 2 && lineWidth > width) {\n        line = line.slice(0, -removeChars);\n        lineWidth = this._getTextMetricsWidth(context.measureText(line + \"…\"));\n        removeChars = this._getCharsToRemove(lineWidth, width, line.length);\n      }\n      // Add on the end\n      line += \"…\";\n    } else {\n      while (characters.length && lineWidth > width) {\n        characters.splice(characters.length - removeChars, removeChars);\n        line = `${characters.join(\"\")}…`;\n        lineWidth = this._getTextMetricsWidth(context.measureText(line));\n        removeChars = this._getCharsToRemove(lineWidth, width, line.length);\n      }\n    }\n    return {\n      text: line,\n      width: lineWidth\n    };\n  }\n  _getTextMetricsWidth(textMetrics) {\n    if (textMetrics.actualBoundingBoxLeft !== undefined) {\n      return Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight);\n    }\n    return textMetrics.width;\n  }\n  _parseLineWordWrap(line = \"\", width, context) {\n    const lines = [];\n    const words = this.wordSplittingFunction ? this.wordSplittingFunction(line) : line.split(this._wordDivider);\n    let lineWidth = this._getTextMetricsWidth(context.measureText(line));\n    for (let n = 0; n < words.length; n++) {\n      const testLine = n > 0 ? line + this._wordDivider + words[n] : words[0];\n      const testWidth = this._getTextMetricsWidth(context.measureText(testLine));\n      if (testWidth > width && n > 0) {\n        lines.push({\n          text: line,\n          width: lineWidth\n        });\n        line = words[n];\n        lineWidth = this._getTextMetricsWidth(context.measureText(line));\n      } else {\n        lineWidth = testWidth;\n        line = testLine;\n      }\n    }\n    lines.push({\n      text: line,\n      width: lineWidth\n    });\n    return lines;\n  }\n  _parseLineWordWrapEllipsis(line = \"\", width, height, context) {\n    const lines = this._parseLineWordWrap(line, width, context);\n    for (let n = 1; n <= lines.length; n++) {\n      const currentHeight = this._computeHeightForLinesOf(n);\n      if (currentHeight > height && n > 1) {\n        const lastLine = lines[n - 2];\n        const currentLine = lines[n - 1];\n        lines[n - 2] = this._parseLineEllipsis(lastLine.text + this._wordDivider + currentLine.text, width, context);\n        const linesToRemove = lines.length - n + 1;\n        for (let i = 0; i < linesToRemove; i++) {\n          lines.pop();\n        }\n        return lines;\n      }\n    }\n    return lines;\n  }\n  _renderLines(context) {\n    if (!this._fontOffset || !this._lines) {\n      return;\n    }\n    const height = this._currentMeasure.height;\n    let rootY = 0;\n    switch (this._textVerticalAlignment) {\n      case Control.VERTICAL_ALIGNMENT_TOP:\n        rootY = this._fontOffset.ascent;\n        break;\n      case Control.VERTICAL_ALIGNMENT_BOTTOM:\n        rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;\n        break;\n      case Control.VERTICAL_ALIGNMENT_CENTER:\n        rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;\n        break;\n    }\n    rootY += this._currentMeasure.top;\n    for (let i = 0; i < this._lines.length; i++) {\n      const line = this._lines[i];\n      if (i !== 0 && this._lineSpacing.internalValue !== 0) {\n        if (this._lineSpacing.isPixel) {\n          rootY += this._lineSpacing.getValue(this._host);\n        } else {\n          rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\n        }\n      }\n      this._drawText(line.text, line.width, rootY, context);\n      rootY += this._fontOffset.height;\n    }\n  }\n  _computeHeightForLinesOf(lineCount) {\n    let newHeight = this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * lineCount;\n    if (lineCount > 0 && this._lineSpacing.internalValue !== 0) {\n      let lineSpacing = 0;\n      if (this._lineSpacing.isPixel) {\n        lineSpacing = this._lineSpacing.getValue(this._host);\n      } else {\n        lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\n      }\n      newHeight += (lineCount - 1) * lineSpacing;\n    }\n    return newHeight;\n  }\n  /**\n   * Given a width constraint applied on the text block, find the expected height\n   * @returns expected height\n   */\n  computeExpectedHeight() {\n    var _a;\n    if (this.text && this.widthInPixels) {\n      // Should abstract platform instead of using LastCreatedEngine\n      const context = (_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.createCanvas(0, 0).getContext(\"2d\");\n      if (context) {\n        this._applyStates(context);\n        if (!this._fontOffset) {\n          this._fontOffset = Control._GetFontOffset(context.font);\n        }\n        const lines = this._lines ? this._lines : this._breakLines(this.widthInPixels - this._paddingLeftInPixels - this._paddingRightInPixels, this.heightInPixels - this._paddingTopInPixels - this._paddingBottomInPixels, context);\n        return this._computeHeightForLinesOf(lines.length);\n      }\n    }\n    return 0;\n  }\n  dispose() {\n    super.dispose();\n    this.onTextChangedObservable.clear();\n  }\n}\n__decorate([serialize()], TextBlock.prototype, \"resizeToFit\", null);\n__decorate([serialize()], TextBlock.prototype, \"textWrapping\", null);\n__decorate([serialize()], TextBlock.prototype, \"text\", null);\n__decorate([serialize()], TextBlock.prototype, \"textHorizontalAlignment\", null);\n__decorate([serialize()], TextBlock.prototype, \"textVerticalAlignment\", null);\n__decorate([serialize()], TextBlock.prototype, \"lineSpacing\", null);\n__decorate([serialize()], TextBlock.prototype, \"outlineWidth\", null);\n__decorate([serialize()], TextBlock.prototype, \"underline\", null);\n__decorate([serialize()], TextBlock.prototype, \"lineThrough\", null);\n__decorate([serialize()], TextBlock.prototype, \"applyOutlineToUnderline\", null);\n__decorate([serialize()], TextBlock.prototype, \"outlineColor\", null);\n__decorate([serialize()], TextBlock.prototype, \"wordDivider\", null);\n__decorate([serialize()], TextBlock.prototype, \"forceResizeWidth\", null);\nRegisterClass(\"BABYLON.GUI.TextBlock\", TextBlock);","map":{"version":3,"names":["Observable","ValueAndUnit","Control","RegisterClass","serialize","EngineStore","TextWrapping","TextBlock","lines","_lines","resizeToFit","_resizeToFit","value","_width","ignoreAdaptiveScaling","_height","_markAsDirty","textWrapping","_textWrapping","text","_text","onTextChangedObservable","notifyObservers","textHorizontalAlignment","_textHorizontalAlignment","textVerticalAlignment","_textVerticalAlignment","lineSpacing","_lineSpacing","fromString","toString","_host","outlineWidth","_outlineWidth","underline","_underline","lineThrough","_lineThrough","applyOutlineToUnderline","_applyOutlineToUnderline","outlineColor","_outlineColor","wordDivider","_wordDivider","forceResizeWidth","_forceResizeWidth","constructor","name","Clip","HORIZONTAL_ALIGNMENT_CENTER","VERTICAL_ALIGNMENT_CENTER","onLinesReadyObservable","_linesTemp","_getTypeName","_processMeasures","parentMeasure","context","_fontOffset","isDirty","_GetFontOffset","font","_breakLines","_currentMeasure","width","height","maxLineWidth","i","length","line","newWidth","Math","ceil","_paddingLeftInPixels","_paddingRightInPixels","getValueInPixel","_tempParentMeasure","updateInPlace","UNITMODE_PIXEL","_rebuildLayout","newHeight","_paddingTopInPixels","_paddingBottomInPixels","internalValue","isPixel","getValue","_cachedParentMeasure","_drawText","textWidth","y","x","HORIZONTAL_ALIGNMENT_LEFT","HORIZONTAL_ALIGNMENT_RIGHT","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","strokeText","left","fillText","_drawLine","fontSizeInPixels","xFrom","yFrom","xTo","yTo","beginPath","lineWidth","round","moveTo","lineTo","stroke","fill","currentStroke","strokeStyle","fillStyle","closePath","_draw","save","_applyStates","_renderLines","restore","lineJoin","miterLimit","refWidth","refHeight","split","Ellipsis","_line","push","_parseLineEllipsis","WordWrap","_parseLineWordWrap","WordWrapEllipsis","_parseLineWordWrapEllipsis","_parseLine","_getTextMetricsWidth","measureText","_getCharsToRemove","lineLength","diff","charWidth","removeChars","max","floor","characters","Array","from","slice","splice","join","textMetrics","actualBoundingBoxLeft","undefined","abs","actualBoundingBoxRight","words","wordSplittingFunction","n","testLine","testWidth","currentHeight","_computeHeightForLinesOf","lastLine","currentLine","linesToRemove","pop","rootY","VERTICAL_ALIGNMENT_TOP","ascent","VERTICAL_ALIGNMENT_BOTTOM","descent","top","lineCount","computeExpectedHeight","widthInPixels","_a","LastCreatedEngine","createCanvas","getContext","heightInPixels","dispose","clear","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/textBlock.ts"],"sourcesContent":["import { Observable } from \"core/Misc/observable\";\r\nimport type { Measure } from \"../measure\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport { Control } from \"./control\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext, ITextMetrics } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\n/**\r\n * Enum that determines the text-wrapping mode to use.\r\n */\r\nexport enum TextWrapping {\r\n    /**\r\n     * Clip the text when it's larger than Control.width; this is the default mode.\r\n     */\r\n    Clip = 0,\r\n\r\n    /**\r\n     * Wrap the text word-wise, i.e. try to add line-breaks at word boundary to fit within Control.width.\r\n     */\r\n    WordWrap = 1,\r\n\r\n    /**\r\n     * Ellipsize the text, i.e. shrink with trailing … when text is larger than Control.width.\r\n     */\r\n    Ellipsis = 2,\r\n\r\n    /**\r\n     * Wrap the text word-wise and clip the text when the text's height is larger than the Control.height, and shrink the last line with trailing … .\r\n     */\r\n    WordWrapEllipsis,\r\n}\r\n\r\n/**\r\n * Class used to create text block control\r\n */\r\nexport class TextBlock extends Control {\r\n    private _text = \"\";\r\n    private _textWrapping = TextWrapping.Clip;\r\n    private _textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    private _textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n    private _lines: any[];\r\n    private _resizeToFit: boolean = false;\r\n    private _lineSpacing: ValueAndUnit = new ValueAndUnit(0);\r\n    private _outlineWidth: number = 0;\r\n    private _outlineColor: string = \"white\";\r\n    private _underline: boolean = false;\r\n    private _lineThrough: boolean = false;\r\n    private _wordDivider: string = \" \";\r\n    private _forceResizeWidth: boolean = false;\r\n    private _applyOutlineToUnderline: boolean = false;\r\n\r\n    /**\r\n     * An event triggered after the text is changed\r\n     */\r\n    public onTextChangedObservable = new Observable<TextBlock>();\r\n\r\n    /**\r\n     * An event triggered after the text was broken up into lines\r\n     */\r\n    public onLinesReadyObservable = new Observable<TextBlock>();\r\n\r\n    /**\r\n     * Function used to split a string into words. By default, a string is split at each space character found\r\n     */\r\n    public wordSplittingFunction: Nullable<(line: string) => string[]>;\r\n\r\n    /**\r\n     * Return the line list (you may need to use the onLinesReadyObservable to make sure the list is ready)\r\n     */\r\n    public get lines(): any[] {\r\n        return this._lines;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that the TextBlock will be resized to fit its content\r\n\r\n     */\r\n    @serialize()\r\n    public get resizeToFit(): boolean {\r\n        return this._resizeToFit;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that the TextBlock will be resized to fit its content\r\n\r\n     */\r\n    public set resizeToFit(value: boolean) {\r\n        if (this._resizeToFit === value) {\r\n            return;\r\n        }\r\n        this._resizeToFit = value;\r\n\r\n        if (this._resizeToFit) {\r\n            this._width.ignoreAdaptiveScaling = true;\r\n            this._height.ignoreAdaptiveScaling = true;\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if text must be wrapped\r\n     */\r\n    @serialize()\r\n    public get textWrapping(): TextWrapping | boolean {\r\n        return this._textWrapping;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if text must be wrapped\r\n     */\r\n    public set textWrapping(value: TextWrapping | boolean) {\r\n        if (this._textWrapping === value) {\r\n            return;\r\n        }\r\n        this._textWrapping = +value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text to display\r\n     */\r\n    @serialize()\r\n    public get text(): string {\r\n        return this._text;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text to display\r\n     */\r\n    public set text(value: string) {\r\n        if (this._text === value) {\r\n            return;\r\n        }\r\n        this._text = value + \"\"; // Making sure it is a text\r\n        this._markAsDirty();\r\n\r\n        this.onTextChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    @serialize()\r\n    public get textHorizontalAlignment(): number {\r\n        return this._textHorizontalAlignment;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    public set textHorizontalAlignment(value: number) {\r\n        if (this._textHorizontalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._textHorizontalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    @serialize()\r\n    public get textVerticalAlignment(): number {\r\n        return this._textVerticalAlignment;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    public set textVerticalAlignment(value: number) {\r\n        if (this._textVerticalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._textVerticalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets line spacing value\r\n     */\r\n    @serialize()\r\n    public set lineSpacing(value: string | number) {\r\n        if (this._lineSpacing.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets line spacing value\r\n     */\r\n    public get lineSpacing(): string | number {\r\n        return this._lineSpacing.toString(this._host);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    @serialize()\r\n    public get outlineWidth(): number {\r\n        return this._outlineWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    public set outlineWidth(value: number) {\r\n        if (this._outlineWidth === value) {\r\n            return;\r\n        }\r\n        this._outlineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that text must have underline\r\n     */\r\n    @serialize()\r\n    public get underline(): boolean {\r\n        return this._underline;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that text must have underline\r\n     */\r\n    public set underline(value: boolean) {\r\n        if (this._underline === value) {\r\n            return;\r\n        }\r\n        this._underline = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that text must be crossed out\r\n     */\r\n    @serialize()\r\n    public get lineThrough(): boolean {\r\n        return this._lineThrough;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that text must be crossed out\r\n     */\r\n    public set lineThrough(value: boolean) {\r\n        if (this._lineThrough === value) {\r\n            return;\r\n        }\r\n        this._lineThrough = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * If the outline should be applied to the underline/strike-through too. Has different behavior in Edge/Chrome vs Firefox.\r\n     */\r\n    @serialize()\r\n    public get applyOutlineToUnderline(): boolean {\r\n        return this._applyOutlineToUnderline;\r\n    }\r\n\r\n    public set applyOutlineToUnderline(value: boolean) {\r\n        if (this._applyOutlineToUnderline === value) {\r\n            return;\r\n        }\r\n        this._applyOutlineToUnderline = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    @serialize()\r\n    public get outlineColor(): string {\r\n        return this._outlineColor;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    public set outlineColor(value: string) {\r\n        if (this._outlineColor === value) {\r\n            return;\r\n        }\r\n        this._outlineColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets word divider\r\n     */\r\n    @serialize()\r\n    public get wordDivider(): string {\r\n        return this._wordDivider;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets word divider\r\n     */\r\n    public set wordDivider(value: string) {\r\n        if (this._wordDivider === value) {\r\n            return;\r\n        }\r\n        this._wordDivider = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * By default, if a text block has text wrapping other than Clip, its width\r\n     * is not resized even if resizeToFit = true. This parameter forces the width\r\n     * to be resized.\r\n     */\r\n    @serialize()\r\n    public get forceResizeWidth(): boolean {\r\n        return this._forceResizeWidth;\r\n    }\r\n\r\n    public set forceResizeWidth(value: boolean) {\r\n        if (this._forceResizeWidth === value) {\r\n            return;\r\n        }\r\n        this._forceResizeWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextBlock object\r\n     * @param name defines the name of the control\r\n     * @param text defines the text to display (empty string by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the control\r\n         */\r\n        public name?: string,\r\n        text: string = \"\"\r\n    ) {\r\n        super(name);\r\n\r\n        this.text = text;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"TextBlock\";\r\n    }\r\n\r\n    protected _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (!this._fontOffset || this.isDirty) {\r\n            this._fontOffset = Control._GetFontOffset(context.font);\r\n        }\r\n        super._processMeasures(parentMeasure, context);\r\n\r\n        // Prepare lines\r\n        this._lines = this._breakLines(this._currentMeasure.width, this._currentMeasure.height, context);\r\n        this.onLinesReadyObservable.notifyObservers(this);\r\n\r\n        let maxLineWidth: number = 0;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (line.width > maxLineWidth) {\r\n                maxLineWidth = line.width;\r\n            }\r\n        }\r\n\r\n        if (this._resizeToFit) {\r\n            if (this._textWrapping === TextWrapping.Clip || this._forceResizeWidth) {\r\n                const newWidth = Math.ceil(this._paddingLeftInPixels) + Math.ceil(this._paddingRightInPixels) + Math.ceil(maxLineWidth);\r\n                if (newWidth !== this._width.getValueInPixel(this._host, this._tempParentMeasure.width)) {\r\n                    this._width.updateInPlace(newWidth, ValueAndUnit.UNITMODE_PIXEL);\r\n                    this._rebuildLayout = true;\r\n                }\r\n            }\r\n            let newHeight = (this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * this._lines.length) | 0;\r\n\r\n            if (this._lines.length > 0 && this._lineSpacing.internalValue !== 0) {\r\n                let lineSpacing = 0;\r\n                if (this._lineSpacing.isPixel) {\r\n                    lineSpacing = this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n\r\n                newHeight += (this._lines.length - 1) * lineSpacing;\r\n            }\r\n\r\n            if (newHeight !== this._height.internalValue) {\r\n                this._height.updateInPlace(newHeight, ValueAndUnit.UNITMODE_PIXEL);\r\n                this._rebuildLayout = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _drawText(text: string, textWidth: number, y: number, context: ICanvasRenderingContext): void {\r\n        const width = this._currentMeasure.width;\r\n        let x = 0;\r\n        switch (this._textHorizontalAlignment) {\r\n            case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                x = 0;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                x = width - textWidth;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                x = (width - textWidth) / 2;\r\n                break;\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        if (this.outlineWidth) {\r\n            context.strokeText(text, this._currentMeasure.left + x, y);\r\n        }\r\n        context.fillText(text, this._currentMeasure.left + x, y);\r\n\r\n        if (this._underline) {\r\n            this._drawLine(this._currentMeasure.left + x, y + 3, this._currentMeasure.left + x + textWidth, y + 3, context);\r\n        }\r\n\r\n        if (this._lineThrough) {\r\n            this._drawLine(this._currentMeasure.left + x, y - this.fontSizeInPixels / 3, this._currentMeasure.left + x + textWidth, y - this.fontSizeInPixels / 3, context);\r\n        }\r\n    }\r\n\r\n    private _drawLine(xFrom: number, yFrom: number, xTo: number, yTo: number, context: ICanvasRenderingContext): void {\r\n        context.beginPath();\r\n        context.lineWidth = Math.round(this.fontSizeInPixels * 0.05);\r\n        context.moveTo(xFrom, yFrom);\r\n        context.lineTo(xTo, yTo);\r\n        if (this.outlineWidth && this.applyOutlineToUnderline) {\r\n            context.stroke();\r\n            context.fill();\r\n        } else {\r\n            const currentStroke = context.strokeStyle;\r\n            context.strokeStyle = context.fillStyle;\r\n            context.stroke();\r\n            context.strokeStyle = currentStroke;\r\n        }\r\n        context.closePath();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        // Render lines\r\n        this._renderLines(context);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected _applyStates(context: ICanvasRenderingContext): void {\r\n        super._applyStates(context);\r\n        if (this.outlineWidth) {\r\n            context.lineWidth = this.outlineWidth;\r\n            context.strokeStyle = this.outlineColor;\r\n            context.lineJoin = \"miter\";\r\n            context.miterLimit = 2;\r\n        }\r\n    }\r\n\r\n    private _linesTemp: object[] = [];\r\n\r\n    protected _breakLines(refWidth: number, refHeight: number, context: ICanvasRenderingContext): object[] {\r\n        this._linesTemp.length = 0;\r\n        const _lines = this.text.split(\"\\n\");\r\n\r\n        if (this._textWrapping === TextWrapping.Ellipsis) {\r\n            for (const _line of _lines) {\r\n                this._linesTemp.push(this._parseLineEllipsis(_line, refWidth, context));\r\n            }\r\n        } else if (this._textWrapping === TextWrapping.WordWrap) {\r\n            for (const _line of _lines) {\r\n                this._linesTemp.push(...this._parseLineWordWrap(_line, refWidth, context));\r\n            }\r\n        } else if (this._textWrapping === TextWrapping.WordWrapEllipsis) {\r\n            for (const _line of _lines) {\r\n                this._linesTemp.push(...this._parseLineWordWrapEllipsis(_line, refWidth, refHeight!, context));\r\n            }\r\n        } else {\r\n            for (const _line of _lines) {\r\n                this._linesTemp.push(this._parseLine(_line, context));\r\n            }\r\n        }\r\n\r\n        return this._linesTemp;\r\n    }\r\n\r\n    protected _parseLine(line: string = \"\", context: ICanvasRenderingContext): object {\r\n        return { text: line, width: this._getTextMetricsWidth(context.measureText(line)) };\r\n    }\r\n\r\n    //Calculate how many characters approximately we need to remove\r\n    private _getCharsToRemove(lineWidth: number, width: number, lineLength: number) {\r\n        const diff = lineWidth > width ? lineWidth - width : 0;\r\n        // This isn't exact unless the font is monospaced\r\n        const charWidth = lineWidth / lineLength;\r\n        const removeChars = Math.max(Math.floor(diff / charWidth), 1);\r\n        return removeChars;\r\n    }\r\n\r\n    protected _parseLineEllipsis(line: string = \"\", width: number, context: ICanvasRenderingContext): object {\r\n        let lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n        let removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n\r\n        // unicode support. split('') does not work with unicode!\r\n        // make sure Array.from is available\r\n        const characters = Array.from && Array.from(line);\r\n        if (!characters) {\r\n            // no array.from, use the old method\r\n            while (line.length > 2 && lineWidth > width) {\r\n                line = line.slice(0, -removeChars);\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line + \"…\"));\r\n\r\n                removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n            }\r\n            // Add on the end\r\n            line += \"…\";\r\n        } else {\r\n            while (characters.length && lineWidth > width) {\r\n                characters.splice(characters.length - removeChars, removeChars);\r\n                line = `${characters.join(\"\")}…`;\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n                removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n            }\r\n        }\r\n\r\n        return { text: line, width: lineWidth };\r\n    }\r\n\r\n    private _getTextMetricsWidth(textMetrics: ITextMetrics) {\r\n        if (textMetrics.actualBoundingBoxLeft !== undefined) {\r\n            return Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight);\r\n        }\r\n        return textMetrics.width;\r\n    }\r\n\r\n    protected _parseLineWordWrap(line: string = \"\", width: number, context: ICanvasRenderingContext): object[] {\r\n        const lines = [];\r\n        const words = this.wordSplittingFunction ? this.wordSplittingFunction(line) : line.split(this._wordDivider);\r\n        let lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n        for (let n = 0; n < words.length; n++) {\r\n            const testLine = n > 0 ? line + this._wordDivider + words[n] : words[0];\r\n            const testWidth = this._getTextMetricsWidth(context.measureText(testLine));\r\n            if (testWidth > width && n > 0) {\r\n                lines.push({ text: line, width: lineWidth });\r\n                line = words[n];\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n            } else {\r\n                lineWidth = testWidth;\r\n                line = testLine;\r\n            }\r\n        }\r\n        lines.push({ text: line, width: lineWidth });\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _parseLineWordWrapEllipsis(line: string = \"\", width: number, height: number, context: ICanvasRenderingContext): object[] {\r\n        const lines = this._parseLineWordWrap(line, width, context);\r\n        for (let n = 1; n <= lines.length; n++) {\r\n            const currentHeight = this._computeHeightForLinesOf(n);\r\n            if (currentHeight > height && n > 1) {\r\n                const lastLine = lines[n - 2] as { text: string; width: number };\r\n                const currentLine = lines[n - 1] as { text: string; width: number };\r\n                lines[n - 2] = this._parseLineEllipsis(lastLine.text + this._wordDivider + currentLine.text, width, context);\r\n                const linesToRemove = lines.length - n + 1;\r\n                for (let i = 0; i < linesToRemove; i++) {\r\n                    lines.pop();\r\n                }\r\n                return lines;\r\n            }\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _renderLines(context: ICanvasRenderingContext): void {\r\n        if (!this._fontOffset || !this._lines) {\r\n            return;\r\n        }\r\n        const height = this._currentMeasure.height;\r\n        let rootY = 0;\r\n        switch (this._textVerticalAlignment) {\r\n            case Control.VERTICAL_ALIGNMENT_TOP:\r\n                rootY = this._fontOffset.ascent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_BOTTOM:\r\n                rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_CENTER:\r\n                rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;\r\n                break;\r\n        }\r\n\r\n        rootY += this._currentMeasure.top;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (i !== 0 && this._lineSpacing.internalValue !== 0) {\r\n                if (this._lineSpacing.isPixel) {\r\n                    rootY += this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n            }\r\n\r\n            this._drawText(line.text, line.width, rootY, context);\r\n            rootY += this._fontOffset.height;\r\n        }\r\n    }\r\n\r\n    private _computeHeightForLinesOf(lineCount: number): number {\r\n        let newHeight = this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * lineCount;\r\n\r\n        if (lineCount > 0 && this._lineSpacing.internalValue !== 0) {\r\n            let lineSpacing = 0;\r\n            if (this._lineSpacing.isPixel) {\r\n                lineSpacing = this._lineSpacing.getValue(this._host);\r\n            } else {\r\n                lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n            }\r\n\r\n            newHeight += (lineCount - 1) * lineSpacing;\r\n        }\r\n\r\n        return newHeight;\r\n    }\r\n\r\n    /**\r\n     * Given a width constraint applied on the text block, find the expected height\r\n     * @returns expected height\r\n     */\r\n    public computeExpectedHeight(): number {\r\n        if (this.text && this.widthInPixels) {\r\n            // Should abstract platform instead of using LastCreatedEngine\r\n            const context = EngineStore.LastCreatedEngine?.createCanvas(0, 0).getContext(\"2d\");\r\n            if (context) {\r\n                this._applyStates(context);\r\n                if (!this._fontOffset) {\r\n                    this._fontOffset = Control._GetFontOffset(context.font);\r\n                }\r\n                const lines = this._lines\r\n                    ? this._lines\r\n                    : this._breakLines(\r\n                          this.widthInPixels - this._paddingLeftInPixels - this._paddingRightInPixels,\r\n                          this.heightInPixels - this._paddingTopInPixels - this._paddingBottomInPixels,\r\n                          context\r\n                      );\r\n                return this._computeHeightForLinesOf(lines.length);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onTextChangedObservable.clear();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.TextBlock\", TextBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}