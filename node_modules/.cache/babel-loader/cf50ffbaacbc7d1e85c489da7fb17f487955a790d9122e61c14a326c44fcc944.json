{"ast":null,"code":"import { Vector2 } from \"@babylonjs/core/Maths/math.vector.js\";\nconst tmpRect = [new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0)];\nconst tmpRect2 = [new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0)];\nconst tmpV1 = new Vector2(0, 0);\nconst tmpV2 = new Vector2(0, 0);\n/**\n * Class used to store 2D control sizes\n */\nexport class Measure {\n  /**\n   * Creates a new measure\n   * @param left defines left coordinate\n   * @param top defines top coordinate\n   * @param width defines width dimension\n   * @param height defines height dimension\n   */\n  constructor( /** defines left coordinate */\n  left, /** defines top coordinate  */\n  top, /** defines width dimension  */\n  width, /** defines height dimension */\n  height) {\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * Copy from another measure\n   * @param other defines the other measure to copy from\n   */\n  copyFrom(other) {\n    this.left = other.left;\n    this.top = other.top;\n    this.width = other.width;\n    this.height = other.height;\n  }\n  /**\n   * Copy from a group of 4 floats\n   * @param left defines left coordinate\n   * @param top defines top coordinate\n   * @param width defines width dimension\n   * @param height defines height dimension\n   */\n  copyFromFloats(left, top, width, height) {\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * Computes the axis aligned bounding box measure for two given measures\n   * @param a Input measure\n   * @param b Input measure\n   * @param result the resulting bounding measure\n   */\n  static CombineToRef(a, b, result) {\n    const left = Math.min(a.left, b.left);\n    const top = Math.min(a.top, b.top);\n    const right = Math.max(a.left + a.width, b.left + b.width);\n    const bottom = Math.max(a.top + a.height, b.top + b.height);\n    result.left = left;\n    result.top = top;\n    result.width = right - left;\n    result.height = bottom - top;\n  }\n  /**\n   * Computes the axis aligned bounding box of the measure after it is modified by a given transform\n   * @param transform the matrix to transform the measure before computing the AABB\n   * @param addX number to add to left\n   * @param addY number to add to top\n   * @param addWidth number to add to width\n   * @param addHeight number to add to height\n   * @param result the resulting AABB\n   */\n  addAndTransformToRef(transform, addX, addY, addWidth, addHeight, result) {\n    const left = this.left + addX;\n    const top = this.top + addY;\n    const width = this.width + addWidth;\n    const height = this.height + addHeight;\n    tmpRect[0].copyFromFloats(left, top);\n    tmpRect[1].copyFromFloats(left + width, top);\n    tmpRect[2].copyFromFloats(left + width, top + height);\n    tmpRect[3].copyFromFloats(left, top + height);\n    tmpV1.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE);\n    tmpV2.copyFromFloats(0, 0);\n    for (let i = 0; i < 4; i++) {\n      transform.transformCoordinates(tmpRect[i].x, tmpRect[i].y, tmpRect2[i]);\n      tmpV1.x = Math.floor(Math.min(tmpV1.x, tmpRect2[i].x));\n      tmpV1.y = Math.floor(Math.min(tmpV1.y, tmpRect2[i].y));\n      tmpV2.x = Math.ceil(Math.max(tmpV2.x, tmpRect2[i].x));\n      tmpV2.y = Math.ceil(Math.max(tmpV2.y, tmpRect2[i].y));\n    }\n    result.left = tmpV1.x;\n    result.top = tmpV1.y;\n    result.width = tmpV2.x - tmpV1.x;\n    result.height = tmpV2.y - tmpV1.y;\n  }\n  /**\n   * Computes the axis aligned bounding box of the measure after it is modified by a given transform\n   * @param transform the matrix to transform the measure before computing the AABB\n   * @param result the resulting AABB\n   */\n  transformToRef(transform, result) {\n    this.addAndTransformToRef(transform, 0, 0, 0, 0, result);\n  }\n  /**\n   * Check equality between this measure and another one\n   * @param other defines the other measures\n   * @returns true if both measures are equals\n   */\n  isEqualsTo(other) {\n    if (this.left !== other.left) {\n      return false;\n    }\n    if (this.top !== other.top) {\n      return false;\n    }\n    if (this.width !== other.width) {\n      return false;\n    }\n    if (this.height !== other.height) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Creates an empty measure\n   * @returns a new measure\n   */\n  static Empty() {\n    return new Measure(0, 0, 0, 0);\n  }\n}","map":{"version":3,"names":["Vector2","tmpRect","tmpRect2","tmpV1","tmpV2","Measure","constructor","left","top","width","height","copyFrom","other","copyFromFloats","CombineToRef","a","b","result","Math","min","right","max","bottom","addAndTransformToRef","transform","addX","addY","addWidth","addHeight","Number","MAX_VALUE","i","transformCoordinates","x","y","floor","ceil","transformToRef","isEqualsTo","Empty"],"sources":["../../../../dev/gui/src/2D/measure.ts"],"sourcesContent":["import type { Matrix2D } from \"./math2D\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nconst tmpRect = [new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0)];\r\n\r\nconst tmpRect2 = [new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0)];\r\n\r\nconst tmpV1 = new Vector2(0, 0);\r\nconst tmpV2 = new Vector2(0, 0);\r\n\r\n/**\r\n * Class used to store 2D control sizes\r\n */\r\nexport class Measure {\r\n    /**\r\n     * Creates a new measure\r\n     * @param left defines left coordinate\r\n     * @param top defines top coordinate\r\n     * @param width defines width dimension\r\n     * @param height defines height dimension\r\n     */\r\n    public constructor(\r\n        /** defines left coordinate */\r\n        public left: number,\r\n        /** defines top coordinate  */\r\n        public top: number,\r\n        /** defines width dimension  */\r\n        public width: number,\r\n        /** defines height dimension */\r\n        public height: number\r\n    ) {}\r\n\r\n    /**\r\n     * Copy from another measure\r\n     * @param other defines the other measure to copy from\r\n     */\r\n    public copyFrom(other: Measure): void {\r\n        this.left = other.left;\r\n        this.top = other.top;\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n    }\r\n\r\n    /**\r\n     * Copy from a group of 4 floats\r\n     * @param left defines left coordinate\r\n     * @param top defines top coordinate\r\n     * @param width defines width dimension\r\n     * @param height defines height dimension\r\n     */\r\n    public copyFromFloats(left: number, top: number, width: number, height: number): void {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Computes the axis aligned bounding box measure for two given measures\r\n     * @param a Input measure\r\n     * @param b Input measure\r\n     * @param result the resulting bounding measure\r\n     */\r\n    public static CombineToRef(a: Measure, b: Measure, result: Measure) {\r\n        const left = Math.min(a.left, b.left);\r\n        const top = Math.min(a.top, b.top);\r\n        const right = Math.max(a.left + a.width, b.left + b.width);\r\n        const bottom = Math.max(a.top + a.height, b.top + b.height);\r\n        result.left = left;\r\n        result.top = top;\r\n        result.width = right - left;\r\n        result.height = bottom - top;\r\n    }\r\n\r\n    /**\r\n     * Computes the axis aligned bounding box of the measure after it is modified by a given transform\r\n     * @param transform the matrix to transform the measure before computing the AABB\r\n     * @param addX number to add to left\r\n     * @param addY number to add to top\r\n     * @param addWidth number to add to width\r\n     * @param addHeight number to add to height\r\n     * @param result the resulting AABB\r\n     */\r\n    public addAndTransformToRef(transform: Matrix2D, addX: number, addY: number, addWidth: number, addHeight: number, result: Measure) {\r\n        const left = this.left + addX;\r\n        const top = this.top + addY;\r\n        const width = this.width + addWidth;\r\n        const height = this.height + addHeight;\r\n\r\n        tmpRect[0].copyFromFloats(left, top);\r\n        tmpRect[1].copyFromFloats(left + width, top);\r\n        tmpRect[2].copyFromFloats(left + width, top + height);\r\n        tmpRect[3].copyFromFloats(left, top + height);\r\n\r\n        tmpV1.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE);\r\n        tmpV2.copyFromFloats(0, 0);\r\n        for (let i = 0; i < 4; i++) {\r\n            transform.transformCoordinates(tmpRect[i].x, tmpRect[i].y, tmpRect2[i]);\r\n            tmpV1.x = Math.floor(Math.min(tmpV1.x, tmpRect2[i].x));\r\n            tmpV1.y = Math.floor(Math.min(tmpV1.y, tmpRect2[i].y));\r\n            tmpV2.x = Math.ceil(Math.max(tmpV2.x, tmpRect2[i].x));\r\n            tmpV2.y = Math.ceil(Math.max(tmpV2.y, tmpRect2[i].y));\r\n        }\r\n        result.left = tmpV1.x;\r\n        result.top = tmpV1.y;\r\n        result.width = tmpV2.x - tmpV1.x;\r\n        result.height = tmpV2.y - tmpV1.y;\r\n    }\r\n\r\n    /**\r\n     * Computes the axis aligned bounding box of the measure after it is modified by a given transform\r\n     * @param transform the matrix to transform the measure before computing the AABB\r\n     * @param result the resulting AABB\r\n     */\r\n    public transformToRef(transform: Matrix2D, result: Measure) {\r\n        this.addAndTransformToRef(transform, 0, 0, 0, 0, result);\r\n    }\r\n    /**\r\n     * Check equality between this measure and another one\r\n     * @param other defines the other measures\r\n     * @returns true if both measures are equals\r\n     */\r\n    public isEqualsTo(other: Measure): boolean {\r\n        if (this.left !== other.left) {\r\n            return false;\r\n        }\r\n\r\n        if (this.top !== other.top) {\r\n            return false;\r\n        }\r\n\r\n        if (this.width !== other.width) {\r\n            return false;\r\n        }\r\n\r\n        if (this.height !== other.height) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates an empty measure\r\n     * @returns a new measure\r\n     */\r\n    public static Empty(): Measure {\r\n        return new Measure(0, 0, 0, 0);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}