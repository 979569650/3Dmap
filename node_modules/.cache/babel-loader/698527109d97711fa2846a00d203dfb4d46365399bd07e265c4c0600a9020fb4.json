{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { IsNavigatorAvailable } from \"../Misc/domManagement.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { DeviceEventFactory } from \"./eventFactory.js\";\nimport { DeviceType, PointerInput } from \"./InputDevices/deviceEnums.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst MAX_KEYCODES = 255;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;\n/** @internal */\nexport class WebDeviceInputSystem {\n  /**\n   * Constructor for the WebDeviceInputSystem\n   * @param engine Engine to reference\n   * @param onDeviceConnected Callback to execute when device is connected\n   * @param onDeviceDisconnected Callback to execute when device is disconnected\n   * @param onInputChanged Callback to execute when input changes on device\n   */\n  constructor(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {\n    // Private Members\n    this._inputs = [];\n    this._keyboardActive = false;\n    this._pointerActive = false;\n    this._usingSafari = Tools.IsSafari();\n    // Found solution for determining if MacOS is being used here:\n    // https://stackoverflow.com/questions/10527983/best-way-to-detect-mac-os-x-or-windows-computers-with-javascript-or-jquery\n    this._usingMacOS = IsNavigatorAvailable() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardDownEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardUpEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardBlurEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerMoveEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerDownEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerUpEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerCancelEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerWheelEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerBlurEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerMacOSChromeOutEvent = evt => {};\n    this._eventsAttached = false;\n    this._mouseId = -1;\n    this._isUsingFirefox = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Firefox\") !== -1;\n    this._isUsingChromium = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Chrome\") !== -1;\n    this._maxTouchPoints = 0;\n    this._pointerInputClearObserver = null;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._gamepadConnectedEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._gamepadDisconnectedEvent = evt => {};\n    this._eventPrefix = Tools.GetPointerPrefix(engine);\n    this._engine = engine;\n    this._onDeviceConnected = onDeviceConnected;\n    this._onDeviceDisconnected = onDeviceDisconnected;\n    this._onInputChanged = onInputChanged;\n    // If we need a pointerId, set one for future use\n    this._mouseId = this._isUsingFirefox ? 0 : 1;\n    this._enableEvents();\n    if (this._usingMacOS) {\n      this._metaKeys = [];\n    }\n    // Set callback to enable event handler switching when inputElement changes\n    if (!this._engine._onEngineViewChanged) {\n      this._engine._onEngineViewChanged = () => {\n        this._enableEvents();\n      };\n    }\n  }\n  // Public functions\n  /**\n   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   * @returns Current value of input\n   */\n  pollInput(deviceType, deviceSlot, inputIndex) {\n    const device = this._inputs[deviceType][deviceSlot];\n    if (!device) {\n      throw `Unable to find device ${DeviceType[deviceType]}`;\n    }\n    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {\n      this._updateDevice(deviceType, deviceSlot, inputIndex);\n    }\n    const currentValue = device[inputIndex];\n    if (currentValue === undefined) {\n      throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;\n    }\n    if (inputIndex === PointerInput.Move) {\n      Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);\n    }\n    return currentValue;\n  }\n  /**\n   * Check for a specific device in the DeviceInputSystem\n   * @param deviceType Type of device to check for\n   * @returns bool with status of device's existence\n   */\n  isDeviceAvailable(deviceType) {\n    return this._inputs[deviceType] !== undefined;\n  }\n  /**\n   * Dispose of all the eventlisteners\n   */\n  dispose() {\n    // Callbacks\n    this._onDeviceConnected = () => {};\n    this._onDeviceDisconnected = () => {};\n    this._onInputChanged = () => {};\n    delete this._engine._onEngineViewChanged;\n    if (this._elementToAttachTo) {\n      this._disableEvents();\n    }\n  }\n  /**\n   * Enable listening for user input events\n   */\n  _enableEvents() {\n    const inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();\n    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {\n      // Remove events before adding to avoid double events or simultaneous events on multiple canvases\n      this._disableEvents();\n      // If the inputs array has already been created, zero it out to before setting up events\n      if (this._inputs) {\n        for (const inputs of this._inputs) {\n          if (inputs) {\n            for (const deviceSlotKey in inputs) {\n              const deviceSlot = +deviceSlotKey;\n              const device = inputs[deviceSlot];\n              if (device) {\n                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {\n                  device[inputIndex] = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n      this._elementToAttachTo = inputElement;\n      // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1\n      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;\n      this._handleKeyActions();\n      this._handlePointerActions();\n      this._handleGamepadActions();\n      this._eventsAttached = true;\n      // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse\n      this._checkForConnectedDevices();\n    }\n  }\n  /**\n   * Disable listening for user input events\n   */\n  _disableEvents() {\n    if (this._elementToAttachTo) {\n      // Blur Events\n      this._elementToAttachTo.removeEventListener(\"blur\", this._keyboardBlurEvent);\n      this._elementToAttachTo.removeEventListener(\"blur\", this._pointerBlurEvent);\n      // Keyboard Events\n      this._elementToAttachTo.removeEventListener(\"keydown\", this._keyboardDownEvent);\n      this._elementToAttachTo.removeEventListener(\"keyup\", this._keyboardUpEvent);\n      // Pointer Events\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);\n      if (this._usingMacOS && this._isUsingChromium) {\n        this._elementToAttachTo.removeEventListener(\"lostpointercapture\", this._pointerMacOSChromeOutEvent);\n      }\n      // Gamepad Events\n      window.removeEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n      window.removeEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n    }\n    if (this._pointerInputClearObserver) {\n      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);\n    }\n    this._eventsAttached = false;\n  }\n  /**\n   * Checks for existing connections to devices and register them, if necessary\n   * Currently handles gamepads and mouse\n   */\n  _checkForConnectedDevices() {\n    if (navigator.getGamepads) {\n      const gamepads = navigator.getGamepads();\n      for (const gamepad of gamepads) {\n        if (gamepad) {\n          this._addGamePad(gamepad);\n        }\n      }\n    }\n    // If the device in use has mouse capabilities, pre-register mouse\n    if (typeof matchMedia === \"function\" && matchMedia(\"(pointer:fine)\").matches) {\n      // This will provide a dummy value for the cursor position and is expected to be overridden when the first mouse event happens.\n      // There isn't any good way to get the current position outside of a pointer event so that's why this was done.\n      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);\n    }\n  }\n  // Private functions\n  /**\n   * Add a gamepad to the DeviceInputSystem\n   * @param gamepad A single DOM Gamepad object\n   */\n  _addGamePad(gamepad) {\n    const deviceType = this._getGamepadDeviceType(gamepad.id);\n    const deviceSlot = gamepad.index;\n    this._gamepads = this._gamepads || new Array(gamepad.index + 1);\n    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);\n    this._gamepads[deviceSlot] = deviceType;\n  }\n  /**\n   * Add pointer device to DeviceInputSystem\n   * @param deviceType Type of Pointer to add\n   * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)\n   * @param currentX Current X at point of adding\n   * @param currentY Current Y at point of adding\n   */\n  _addPointerDevice(deviceType, deviceSlot, currentX, currentY) {\n    if (!this._pointerActive) {\n      this._pointerActive = true;\n    }\n    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n    const pointer = this._inputs[deviceType][deviceSlot]; /* initialize our pointer position immediately after registration */\n    pointer[0] = currentX;\n    pointer[1] = currentY;\n  }\n  /**\n   * Add device and inputs to device array\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param numberOfInputs Number of input entries to create for given device\n   */\n  _registerDevice(deviceType, deviceSlot, numberOfInputs) {\n    if (deviceSlot === undefined) {\n      throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;\n    }\n    if (!this._inputs[deviceType]) {\n      this._inputs[deviceType] = {};\n    }\n    if (!this._inputs[deviceType][deviceSlot]) {\n      const device = new Array(numberOfInputs);\n      device.fill(0);\n      this._inputs[deviceType][deviceSlot] = device;\n      this._onDeviceConnected(deviceType, deviceSlot);\n    }\n  }\n  /**\n   * Given a specific device name, remove that device from the device map\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   */\n  _unregisterDevice(deviceType, deviceSlot) {\n    if (this._inputs[deviceType][deviceSlot]) {\n      delete this._inputs[deviceType][deviceSlot];\n      this._onDeviceDisconnected(deviceType, deviceSlot);\n    }\n  }\n  /**\n   * Handle all actions that come from keyboard interaction\n   */\n  _handleKeyActions() {\n    this._keyboardDownEvent = evt => {\n      if (!this._keyboardActive) {\n        this._keyboardActive = true;\n        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n      const kbKey = this._inputs[DeviceType.Keyboard][0];\n      if (kbKey) {\n        kbKey[evt.keyCode] = 1;\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n        if (this._usingMacOS && evt.metaKey && evt.key !== \"Meta\") {\n          if (!this._metaKeys.includes(evt.keyCode)) {\n            this._metaKeys.push(evt.keyCode);\n          }\n        }\n        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n    this._keyboardUpEvent = evt => {\n      if (!this._keyboardActive) {\n        this._keyboardActive = true;\n        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n      const kbKey = this._inputs[DeviceType.Keyboard][0];\n      if (kbKey) {\n        kbKey[evt.keyCode] = 0;\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n        if (this._usingMacOS && evt.key === \"Meta\" && this._metaKeys.length > 0) {\n          for (const keyCode of this._metaKeys) {\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);\n            kbKey[keyCode] = 0;\n            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n          }\n          this._metaKeys.splice(0, this._metaKeys.length);\n        }\n        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n    this._keyboardBlurEvent = () => {\n      if (this._keyboardActive) {\n        const kbKey = this._inputs[DeviceType.Keyboard][0];\n        for (let i = 0; i < kbKey.length; i++) {\n          if (kbKey[i] !== 0) {\n            kbKey[i] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n          }\n        }\n        if (this._usingMacOS) {\n          this._metaKeys.splice(0, this._metaKeys.length);\n        }\n      }\n    };\n    this._elementToAttachTo.addEventListener(\"keydown\", this._keyboardDownEvent);\n    this._elementToAttachTo.addEventListener(\"keyup\", this._keyboardUpEvent);\n    this._elementToAttachTo.addEventListener(\"blur\", this._keyboardBlurEvent);\n  }\n  /**\n   * Handle all actions that come from pointer interaction\n   */\n  _handlePointerActions() {\n    // If maxTouchPoints is defined, use that value.  Otherwise, allow for a minimum for supported gestures like pinch\n    this._maxTouchPoints = IsNavigatorAvailable() && navigator.maxTouchPoints || 2;\n    if (!this._activeTouchIds) {\n      this._activeTouchIds = new Array(this._maxTouchPoints);\n    }\n    for (let i = 0; i < this._maxTouchPoints; i++) {\n      this._activeTouchIds[i] = -1;\n    }\n    this._pointerMoveEvent = evt => {\n      const deviceType = this._getPointerType(evt);\n      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\n      // In the event that we're gettting pointermove events from touch inputs that we aren't tracking,\n      // look for an available slot and retroactively connect it.\n      if (deviceType === DeviceType.Touch && deviceSlot === -1) {\n        const idx = this._activeTouchIds.indexOf(-1);\n        if (idx >= 0) {\n          deviceSlot = idx;\n          this._activeTouchIds[idx] = evt.pointerId;\n          // Because this is a \"new\" input, inform the connected callback\n          this._onDeviceConnected(deviceType, deviceSlot);\n        } else {\n          // We can't find an open slot to store new pointer so just return (can only support max number of touches)\n          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\n          return;\n        }\n      }\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = {};\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = PointerInput.Move;\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        // For touches that aren't started with a down, we need to set the button state to 1\n        if (deviceType === DeviceType.Touch && pointer[PointerInput.LeftClick] === 0) {\n          pointer[PointerInput.LeftClick] = 1;\n        }\n        if (evt.pointerId === undefined) {\n          evt.pointerId = this._mouseId;\n        }\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        // Lets Propagate the event for move with same position.\n        if (!this._usingSafari && evt.button !== -1) {\n          deviceEvent.inputIndex = evt.button + 2;\n          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1; // Reverse state of button if evt.button has value\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    this._pointerDownEvent = evt => {\n      const deviceType = this._getPointerType(evt);\n      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;\n      if (deviceType === DeviceType.Touch) {\n        const idx = this._activeTouchIds.indexOf(-1);\n        if (idx >= 0) {\n          deviceSlot = idx;\n          this._activeTouchIds[idx] = evt.pointerId;\n        } else {\n          // We can't find an open slot to store new pointer so just return (can only support max number of touches)\n          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\n          return;\n        }\n      }\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = {};\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      } else if (deviceType === DeviceType.Touch) {\n        this._onDeviceConnected(deviceType, deviceSlot);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        const previousHorizontal = pointer[PointerInput.Horizontal];\n        const previousVertical = pointer[PointerInput.Vertical];\n        if (deviceType === DeviceType.Mouse) {\n          // Mouse; Set pointerId if undefined\n          if (evt.pointerId === undefined) {\n            evt.pointerId = this._mouseId;\n          }\n          if (!document.pointerLockElement) {\n            try {\n              this._elementToAttachTo.setPointerCapture(this._mouseId);\n            } catch (e) {\n              // DO NOTHING\n            }\n          }\n        } else {\n          // Touch; Since touches are dynamically assigned, only set capture if we have an id\n          if (evt.pointerId && !document.pointerLockElement) {\n            try {\n              this._elementToAttachTo.setPointerCapture(evt.pointerId);\n            } catch (e) {\n              // DO NOTHING\n            }\n          }\n        }\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 1;\n        const deviceEvent = evt;\n        // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n        deviceEvent.inputIndex = evt.button + 2;\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    this._pointerUpEvent = evt => {\n      var _a, _b, _c, _d, _e;\n      const deviceType = this._getPointerType(evt);\n      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\n      if (deviceType === DeviceType.Touch) {\n        // If we're getting a pointerup event for a touch that isn't active, just return.\n        if (deviceSlot === -1) {\n          return;\n        } else {\n          this._activeTouchIds[deviceSlot] = -1;\n        }\n      }\n      const pointer = (_a = this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];\n      if (pointer && pointer[evt.button + 2] !== 0) {\n        const previousHorizontal = pointer[PointerInput.Horizontal];\n        const previousVertical = pointer[PointerInput.Vertical];\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 0;\n        const deviceEvent = evt;\n        if (evt.pointerId === undefined) {\n          evt.pointerId = this._mouseId;\n        }\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n        deviceEvent.inputIndex = evt.button + 2;\n        if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && ((_c = (_b = this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, this._mouseId))) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        } else if (evt.pointerId && ((_e = (_d = this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {\n          this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        if (deviceType === DeviceType.Touch) {\n          this._onDeviceDisconnected(deviceType, deviceSlot);\n        }\n      }\n    };\n    this._pointerCancelEvent = evt => {\n      var _a, _b, _c, _d;\n      if (evt.pointerType === \"mouse\") {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        }\n        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      } else {\n        const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);\n        // If we're getting a pointercancel event for a touch that isn't active, just return\n        if (deviceSlot === -1) {\n          return;\n        }\n        if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, evt.pointerId)) {\n          this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n        this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;\n        const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, evt.pointerId);\n        this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n        this._activeTouchIds[deviceSlot] = -1;\n        this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n      }\n    };\n    // Set Wheel Event Name, code originally from scene.inputManager\n    this._wheelEventName = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" // Modern browsers support \"wheel\"\n    : document.onmousewheel !== undefined ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n    : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n    // Code originally in scene.inputManager.ts\n    // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.\n    // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.\n    // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)\n    let passiveSupported = false;\n    const noop = function () {};\n    try {\n      const options = Object.defineProperty({}, \"passive\", {\n        get: function () {\n          passiveSupported = true;\n        }\n      });\n      this._elementToAttachTo.addEventListener(\"test\", noop, options);\n      this._elementToAttachTo.removeEventListener(\"test\", noop, options);\n    } catch (e) {\n      /* */\n    }\n    this._pointerBlurEvent = () => {\n      var _a, _b, _c, _d, _e;\n      // Handle mouse buttons\n      if (this.isDeviceAvailable(DeviceType.Mouse)) {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        }\n        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      }\n      // Handle Active Touches\n      if (this.isDeviceAvailable(DeviceType.Touch)) {\n        const pointer = this._inputs[DeviceType.Touch];\n        for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {\n          const pointerId = this._activeTouchIds[deviceSlot];\n          if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {\n            this._elementToAttachTo.releasePointerCapture(pointerId);\n          }\n          if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {\n            pointer[deviceSlot][PointerInput.LeftClick] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, pointerId);\n            this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n            this._activeTouchIds[deviceSlot] = -1;\n            this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n          }\n        }\n      }\n    };\n    this._pointerWheelEvent = evt => {\n      const deviceType = DeviceType.Mouse;\n      const deviceSlot = 0;\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = [];\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._pointerActive = true;\n        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;\n        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;\n        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;\n        const deviceEvent = evt;\n        // By default, there is no pointerId for mouse wheel events so we'll add one here\n        // This logic was originally in the InputManager but was added here to make the\n        // InputManager more platform-agnostic\n        if (evt.pointerId === undefined) {\n          evt.pointerId = this._mouseId;\n        }\n        if (pointer[PointerInput.MouseWheelX] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelX;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        if (pointer[PointerInput.MouseWheelY] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelY;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        if (pointer[PointerInput.MouseWheelZ] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelZ;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    // Workaround for MacOS Chromium Browsers for lost pointer capture bug\n    if (this._usingMacOS && this._isUsingChromium) {\n      this._pointerMacOSChromeOutEvent = evt => {\n        if (evt.buttons > 1) {\n          this._pointerCancelEvent(evt);\n        }\n      };\n      this._elementToAttachTo.addEventListener(\"lostpointercapture\", this._pointerMacOSChromeOutEvent);\n    }\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n    this._elementToAttachTo.addEventListener(\"blur\", this._pointerBlurEvent);\n    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? {\n      passive: false\n    } : false);\n    // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame\n    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {\n      if (this.isDeviceAvailable(DeviceType.Mouse)) {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        pointer[PointerInput.MouseWheelX] = 0;\n        pointer[PointerInput.MouseWheelY] = 0;\n        pointer[PointerInput.MouseWheelZ] = 0;\n      }\n    });\n  }\n  /**\n   * Handle all actions that come from gamepad interaction\n   */\n  _handleGamepadActions() {\n    this._gamepadConnectedEvent = evt => {\n      this._addGamePad(evt.gamepad);\n    };\n    this._gamepadDisconnectedEvent = evt => {\n      if (this._gamepads) {\n        const deviceType = this._getGamepadDeviceType(evt.gamepad.id);\n        const deviceSlot = evt.gamepad.index;\n        this._unregisterDevice(deviceType, deviceSlot);\n        delete this._gamepads[deviceSlot];\n      }\n    };\n    window.addEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n    window.addEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n  }\n  /**\n   * Update all non-event based devices with each frame\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   */\n  _updateDevice(deviceType, deviceSlot, inputIndex) {\n    // Gamepads\n    const gp = navigator.getGamepads()[deviceSlot];\n    if (gp && deviceType === this._gamepads[deviceSlot]) {\n      const device = this._inputs[deviceType][deviceSlot];\n      if (inputIndex >= gp.buttons.length) {\n        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();\n      } else {\n        device[inputIndex] = gp.buttons[inputIndex].value;\n      }\n    }\n  }\n  /**\n   * Gets DeviceType from the device name\n   * @param deviceName Name of Device from DeviceInputSystem\n   * @returns DeviceType enum value\n   */\n  _getGamepadDeviceType(deviceName) {\n    if (deviceName.indexOf(\"054c\") !== -1) {\n      // DualShock 4 Gamepad\n      return deviceName.indexOf(\"0ce6\") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;\n    } else if (deviceName.indexOf(\"Xbox One\") !== -1 || deviceName.search(\"Xbox 360\") !== -1 || deviceName.search(\"xinput\") !== -1) {\n      // Xbox Gamepad\n      return DeviceType.Xbox;\n    } else if (deviceName.indexOf(\"057e\") !== -1) {\n      // Switch Gamepad\n      return DeviceType.Switch;\n    }\n    return DeviceType.Generic;\n  }\n  /**\n   * Get DeviceType from a given pointer/mouse/touch event.\n   * @param evt PointerEvent to evaluate\n   * @returns DeviceType interpreted from event\n   */\n  _getPointerType(evt) {\n    let deviceType = DeviceType.Mouse;\n    if (evt.pointerType === \"touch\" || evt.pointerType === \"pen\" || evt.touches) {\n      deviceType = DeviceType.Touch;\n    }\n    return deviceType;\n  }\n}","map":{"version":3,"names":["IsNavigatorAvailable","Tools","DeviceEventFactory","DeviceType","PointerInput","MAX_KEYCODES","MAX_POINTER_INPUTS","Object","keys","length","WebDeviceInputSystem","constructor","engine","onDeviceConnected","onDeviceDisconnected","onInputChanged","_inputs","_keyboardActive","_pointerActive","_usingSafari","IsSafari","_usingMacOS","test","navigator","platform","_keyboardDownEvent","evt","_keyboardUpEvent","_keyboardBlurEvent","_pointerMoveEvent","_pointerDownEvent","_pointerUpEvent","_pointerCancelEvent","_pointerWheelEvent","_pointerBlurEvent","_pointerMacOSChromeOutEvent","_eventsAttached","_mouseId","_isUsingFirefox","userAgent","indexOf","_isUsingChromium","_maxTouchPoints","_pointerInputClearObserver","_gamepadConnectedEvent","_gamepadDisconnectedEvent","_eventPrefix","GetPointerPrefix","_engine","_onDeviceConnected","_onDeviceDisconnected","_onInputChanged","_enableEvents","_metaKeys","_onEngineViewChanged","pollInput","deviceType","deviceSlot","inputIndex","device","DualShock","DualSense","_updateDevice","currentValue","undefined","Move","Warn","isDeviceAvailable","dispose","_elementToAttachTo","_disableEvents","inputElement","getInputElement","inputs","deviceSlotKey","tabIndex","canvasTabIndex","_handleKeyActions","_handlePointerActions","_handleGamepadActions","_checkForConnectedDevices","removeEventListener","_wheelEventName","window","onEndFrameObservable","remove","getGamepads","gamepads","gamepad","_addGamePad","matchMedia","matches","_addPointerDevice","Mouse","_getGamepadDeviceType","id","index","_gamepads","Array","_registerDevice","buttons","axes","currentX","currentY","pointer","numberOfInputs","fill","_unregisterDevice","Keyboard","kbKey","keyCode","deviceEvent","metaKey","key","includes","push","CreateDeviceEvent","splice","i","addEventListener","maxTouchPoints","_activeTouchIds","_getPointerType","pointerId","Touch","idx","clientX","clientY","Horizontal","Vertical","LeftClick","button","previousHorizontal","previousVertical","document","pointerLockElement","setPointerCapture","e","_a","_c","_b","hasPointerCapture","call","releasePointerCapture","_e","_d","pointerType","BrowserForward","createElement","onmousewheel","passiveSupported","noop","options","defineProperty","get","MouseWheelX","deltaX","MouseWheelY","deltaY","wheelDelta","MouseWheelZ","deltaZ","passive","add","gp","valueOf","value","deviceName","search","Xbox","Switch","Generic","touches"],"sources":["../../../../dev/core/src/DeviceInput/webDeviceInputSystem.ts"],"sourcesContent":["import type { Engine } from \"../Engines/engine\";\r\nimport type { IPointerEvent, IUIEvent } from \"../Events/deviceInputEvents\";\r\nimport { IsNavigatorAvailable } from \"../Misc/domManagement\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { DeviceEventFactory } from \"./eventFactory\";\r\nimport { DeviceType, PointerInput } from \"./InputDevices/deviceEnums\";\r\nimport type { IDeviceInputSystem } from \"./inputInterfaces\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst MAX_KEYCODES = 255;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;\r\n\r\n/** @internal */\r\nexport class WebDeviceInputSystem implements IDeviceInputSystem {\r\n    // Private Members\r\n    private _inputs: Array<{ [deviceSlot: number]: Array<number> }> = [];\r\n    private _gamepads: Array<DeviceType>;\r\n    private _keyboardActive: boolean = false;\r\n    private _pointerActive: boolean = false;\r\n    private _elementToAttachTo: HTMLElement;\r\n    private _metaKeys: Array<number>;\r\n    private readonly _engine: Engine;\r\n    private readonly _usingSafari: boolean = Tools.IsSafari();\r\n    // Found solution for determining if MacOS is being used here:\r\n    // https://stackoverflow.com/questions/10527983/best-way-to-detect-mac-os-x-or-windows-computers-with-javascript-or-jquery\r\n    private readonly _usingMacOS: boolean = IsNavigatorAvailable() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\r\n\r\n    private _onDeviceConnected: (deviceType: DeviceType, deviceSlot: number) => void;\r\n    private _onDeviceDisconnected: (deviceType: DeviceType, deviceSlot: number) => void;\r\n    private _onInputChanged: (deviceType: DeviceType, deviceSlot: number, eventData: IUIEvent) => void;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardDownEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardUpEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardBlurEvent = (evt: any) => {};\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerMoveEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerDownEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerUpEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerCancelEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerWheelEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerBlurEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerMacOSChromeOutEvent = (evt: any) => {};\r\n    private _wheelEventName: string;\r\n    private _eventsAttached: boolean = false;\r\n\r\n    private _mouseId = -1;\r\n    private readonly _isUsingFirefox = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Firefox\") !== -1;\r\n    private readonly _isUsingChromium = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Chrome\") !== -1;\r\n\r\n    // Array to store active Pointer ID values; prevents issues with negative pointerIds\r\n    private _activeTouchIds: Array<number>;\r\n    private _maxTouchPoints: number = 0;\r\n\r\n    private _pointerInputClearObserver: Nullable<Observer<Engine>> = null;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _gamepadConnectedEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _gamepadDisconnectedEvent = (evt: any) => {};\r\n\r\n    private _eventPrefix: string;\r\n\r\n    /**\r\n     * Constructor for the WebDeviceInputSystem\r\n     * @param engine Engine to reference\r\n     * @param onDeviceConnected Callback to execute when device is connected\r\n     * @param onDeviceDisconnected Callback to execute when device is disconnected\r\n     * @param onInputChanged Callback to execute when input changes on device\r\n     */\r\n    constructor(\r\n        engine: Engine,\r\n        onDeviceConnected: (deviceType: DeviceType, deviceSlot: number) => void,\r\n        onDeviceDisconnected: (deviceType: DeviceType, deviceSlot: number) => void,\r\n        onInputChanged: (deviceType: DeviceType, deviceSlot: number, eventData: IUIEvent) => void\r\n    ) {\r\n        this._eventPrefix = Tools.GetPointerPrefix(engine);\r\n        this._engine = engine;\r\n\r\n        this._onDeviceConnected = onDeviceConnected;\r\n        this._onDeviceDisconnected = onDeviceDisconnected;\r\n        this._onInputChanged = onInputChanged;\r\n\r\n        // If we need a pointerId, set one for future use\r\n        this._mouseId = this._isUsingFirefox ? 0 : 1;\r\n\r\n        this._enableEvents();\r\n\r\n        if (this._usingMacOS) {\r\n            this._metaKeys = [];\r\n        }\r\n\r\n        // Set callback to enable event handler switching when inputElement changes\r\n        if (!this._engine._onEngineViewChanged) {\r\n            this._engine._onEngineViewChanged = () => {\r\n                this._enableEvents();\r\n            };\r\n        }\r\n    }\r\n\r\n    // Public functions\r\n    /**\r\n     * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param inputIndex Id of input to be checked\r\n     * @returns Current value of input\r\n     */\r\n    public pollInput(deviceType: DeviceType, deviceSlot: number, inputIndex: number): number {\r\n        const device = this._inputs[deviceType][deviceSlot];\r\n\r\n        if (!device) {\r\n            throw `Unable to find device ${DeviceType[deviceType]}`;\r\n        }\r\n\r\n        if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {\r\n            this._updateDevice(deviceType, deviceSlot, inputIndex);\r\n        }\r\n\r\n        const currentValue = device[inputIndex];\r\n        if (currentValue === undefined) {\r\n            throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;\r\n        }\r\n\r\n        if (inputIndex === PointerInput.Move) {\r\n            Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);\r\n        }\r\n\r\n        return currentValue;\r\n    }\r\n\r\n    /**\r\n     * Check for a specific device in the DeviceInputSystem\r\n     * @param deviceType Type of device to check for\r\n     * @returns bool with status of device's existence\r\n     */\r\n    public isDeviceAvailable(deviceType: DeviceType): boolean {\r\n        return this._inputs[deviceType] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Dispose of all the eventlisteners\r\n     */\r\n    public dispose(): void {\r\n        // Callbacks\r\n        this._onDeviceConnected = () => {};\r\n        this._onDeviceDisconnected = () => {};\r\n        this._onInputChanged = () => {};\r\n        delete this._engine._onEngineViewChanged;\r\n\r\n        if (this._elementToAttachTo) {\r\n            this._disableEvents();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable listening for user input events\r\n     */\r\n    private _enableEvents(): void {\r\n        const inputElement = this?._engine.getInputElement();\r\n        if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {\r\n            // Remove events before adding to avoid double events or simultaneous events on multiple canvases\r\n            this._disableEvents();\r\n\r\n            // If the inputs array has already been created, zero it out to before setting up events\r\n            if (this._inputs) {\r\n                for (const inputs of this._inputs) {\r\n                    if (inputs) {\r\n                        for (const deviceSlotKey in inputs) {\r\n                            const deviceSlot = +deviceSlotKey;\r\n                            const device = inputs[deviceSlot];\r\n                            if (device) {\r\n                                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {\r\n                                    device[inputIndex] = 0;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._elementToAttachTo = inputElement;\r\n            // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1\r\n            this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;\r\n            this._handleKeyActions();\r\n            this._handlePointerActions();\r\n            this._handleGamepadActions();\r\n            this._eventsAttached = true;\r\n\r\n            // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse\r\n            this._checkForConnectedDevices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable listening for user input events\r\n     */\r\n    private _disableEvents(): void {\r\n        if (this._elementToAttachTo) {\r\n            // Blur Events\r\n            this._elementToAttachTo.removeEventListener(\"blur\", this._keyboardBlurEvent);\r\n            this._elementToAttachTo.removeEventListener(\"blur\", this._pointerBlurEvent);\r\n\r\n            // Keyboard Events\r\n            this._elementToAttachTo.removeEventListener(\"keydown\", this._keyboardDownEvent);\r\n            this._elementToAttachTo.removeEventListener(\"keyup\", this._keyboardUpEvent);\r\n\r\n            // Pointer Events\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\r\n            this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);\r\n            if (this._usingMacOS && this._isUsingChromium) {\r\n                this._elementToAttachTo.removeEventListener(\"lostpointercapture\", this._pointerMacOSChromeOutEvent);\r\n            }\r\n\r\n            // Gamepad Events\r\n            window.removeEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\r\n            window.removeEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\r\n        }\r\n\r\n        if (this._pointerInputClearObserver) {\r\n            this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);\r\n        }\r\n\r\n        this._eventsAttached = false;\r\n    }\r\n\r\n    /**\r\n     * Checks for existing connections to devices and register them, if necessary\r\n     * Currently handles gamepads and mouse\r\n     */\r\n    private _checkForConnectedDevices(): void {\r\n        if (navigator.getGamepads) {\r\n            const gamepads = navigator.getGamepads();\r\n\r\n            for (const gamepad of gamepads) {\r\n                if (gamepad) {\r\n                    this._addGamePad(gamepad);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the device in use has mouse capabilities, pre-register mouse\r\n        if (typeof matchMedia === \"function\" && matchMedia(\"(pointer:fine)\").matches) {\r\n            // This will provide a dummy value for the cursor position and is expected to be overridden when the first mouse event happens.\r\n            // There isn't any good way to get the current position outside of a pointer event so that's why this was done.\r\n            this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);\r\n        }\r\n    }\r\n\r\n    // Private functions\r\n    /**\r\n     * Add a gamepad to the DeviceInputSystem\r\n     * @param gamepad A single DOM Gamepad object\r\n     */\r\n    private _addGamePad(gamepad: any): void {\r\n        const deviceType = this._getGamepadDeviceType(gamepad.id);\r\n        const deviceSlot = gamepad.index;\r\n\r\n        this._gamepads = this._gamepads || new Array<DeviceType>(gamepad.index + 1);\r\n        this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);\r\n\r\n        this._gamepads[deviceSlot] = deviceType;\r\n    }\r\n\r\n    /**\r\n     * Add pointer device to DeviceInputSystem\r\n     * @param deviceType Type of Pointer to add\r\n     * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)\r\n     * @param currentX Current X at point of adding\r\n     * @param currentY Current Y at point of adding\r\n     */\r\n    private _addPointerDevice(deviceType: DeviceType, deviceSlot: number, currentX: number, currentY: number): void {\r\n        if (!this._pointerActive) {\r\n            this._pointerActive = true;\r\n        }\r\n        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\r\n        const pointer = this._inputs[deviceType][deviceSlot]; /* initialize our pointer position immediately after registration */\r\n        pointer[0] = currentX;\r\n        pointer[1] = currentY;\r\n    }\r\n\r\n    /**\r\n     * Add device and inputs to device array\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param numberOfInputs Number of input entries to create for given device\r\n     */\r\n    private _registerDevice(deviceType: DeviceType, deviceSlot: number, numberOfInputs: number): void {\r\n        if (deviceSlot === undefined) {\r\n            throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;\r\n        }\r\n\r\n        if (!this._inputs[deviceType]) {\r\n            this._inputs[deviceType] = {};\r\n        }\r\n\r\n        if (!this._inputs[deviceType][deviceSlot]) {\r\n            const device = new Array<number>(numberOfInputs);\r\n\r\n            device.fill(0);\r\n\r\n            this._inputs[deviceType][deviceSlot] = device;\r\n            this._onDeviceConnected(deviceType, deviceSlot);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a specific device name, remove that device from the device map\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     */\r\n    private _unregisterDevice(deviceType: DeviceType, deviceSlot: number): void {\r\n        if (this._inputs[deviceType][deviceSlot]) {\r\n            delete this._inputs[deviceType][deviceSlot];\r\n            this._onDeviceDisconnected(deviceType, deviceSlot);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from keyboard interaction\r\n     */\r\n    private _handleKeyActions(): void {\r\n        this._keyboardDownEvent = (evt) => {\r\n            if (!this._keyboardActive) {\r\n                this._keyboardActive = true;\r\n                this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\r\n            }\r\n\r\n            const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n            if (kbKey) {\r\n                kbKey[evt.keyCode] = 1;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                deviceEvent.inputIndex = evt.keyCode;\r\n\r\n                if (this._usingMacOS && evt.metaKey && evt.key !== \"Meta\") {\r\n                    if (!this._metaKeys.includes(evt.keyCode)) {\r\n                        this._metaKeys.push(evt.keyCode);\r\n                    }\r\n                }\r\n\r\n                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n            }\r\n        };\r\n\r\n        this._keyboardUpEvent = (evt) => {\r\n            if (!this._keyboardActive) {\r\n                this._keyboardActive = true;\r\n                this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\r\n            }\r\n\r\n            const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n            if (kbKey) {\r\n                kbKey[evt.keyCode] = 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                deviceEvent.inputIndex = evt.keyCode;\r\n\r\n                if (this._usingMacOS && evt.key === \"Meta\" && this._metaKeys.length > 0) {\r\n                    for (const keyCode of this._metaKeys) {\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);\r\n                        kbKey[keyCode] = 0;\r\n                        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n                    }\r\n                    this._metaKeys.splice(0, this._metaKeys.length);\r\n                }\r\n\r\n                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n            }\r\n        };\r\n\r\n        this._keyboardBlurEvent = () => {\r\n            if (this._keyboardActive) {\r\n                const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n\r\n                for (let i = 0; i < kbKey.length; i++) {\r\n                    if (kbKey[i] !== 0) {\r\n                        kbKey[i] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n                    }\r\n                }\r\n                if (this._usingMacOS) {\r\n                    this._metaKeys.splice(0, this._metaKeys.length);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._elementToAttachTo.addEventListener(\"keydown\", this._keyboardDownEvent);\r\n        this._elementToAttachTo.addEventListener(\"keyup\", this._keyboardUpEvent);\r\n        this._elementToAttachTo.addEventListener(\"blur\", this._keyboardBlurEvent);\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from pointer interaction\r\n     */\r\n    private _handlePointerActions(): void {\r\n        // If maxTouchPoints is defined, use that value.  Otherwise, allow for a minimum for supported gestures like pinch\r\n        this._maxTouchPoints = (IsNavigatorAvailable() && navigator.maxTouchPoints) || 2;\r\n        if (!this._activeTouchIds) {\r\n            this._activeTouchIds = new Array<number>(this._maxTouchPoints);\r\n        }\r\n\r\n        for (let i = 0; i < this._maxTouchPoints; i++) {\r\n            this._activeTouchIds[i] = -1;\r\n        }\r\n\r\n        this._pointerMoveEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            let deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n            // In the event that we're gettting pointermove events from touch inputs that we aren't tracking,\r\n            // look for an available slot and retroactively connect it.\r\n            if (deviceType === DeviceType.Touch && deviceSlot === -1) {\r\n                const idx = this._activeTouchIds.indexOf(-1);\r\n\r\n                if (idx >= 0) {\r\n                    deviceSlot = idx;\r\n                    this._activeTouchIds[idx] = evt.pointerId;\r\n                    // Because this is a \"new\" input, inform the connected callback\r\n                    this._onDeviceConnected(deviceType, deviceSlot);\r\n                } else {\r\n                    // We can't find an open slot to store new pointer so just return (can only support max number of touches)\r\n                    Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = {};\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                const deviceEvent = evt as IPointerEvent;\r\n                deviceEvent.inputIndex = PointerInput.Move;\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n\r\n                // For touches that aren't started with a down, we need to set the button state to 1\r\n                if (deviceType === DeviceType.Touch && pointer[PointerInput.LeftClick] === 0) {\r\n                    pointer[PointerInput.LeftClick] = 1;\r\n                }\r\n\r\n                if (evt.pointerId === undefined) {\r\n                    evt.pointerId = this._mouseId;\r\n                }\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                // Lets Propagate the event for move with same position.\r\n                if (!this._usingSafari && evt.button !== -1) {\r\n                    deviceEvent.inputIndex = evt.button + 2;\r\n                    pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1; // Reverse state of button if evt.button has value\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerDownEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;\r\n\r\n            if (deviceType === DeviceType.Touch) {\r\n                const idx = this._activeTouchIds.indexOf(-1);\r\n\r\n                if (idx >= 0) {\r\n                    deviceSlot = idx;\r\n                    this._activeTouchIds[idx] = evt.pointerId;\r\n                } else {\r\n                    // We can't find an open slot to store new pointer so just return (can only support max number of touches)\r\n                    Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = {};\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\r\n            } else if (deviceType === DeviceType.Touch) {\r\n                this._onDeviceConnected(deviceType, deviceSlot);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                const previousHorizontal = pointer[PointerInput.Horizontal];\r\n                const previousVertical = pointer[PointerInput.Vertical];\r\n\r\n                if (deviceType === DeviceType.Mouse) {\r\n                    // Mouse; Set pointerId if undefined\r\n                    if (evt.pointerId === undefined) {\r\n                        evt.pointerId = this._mouseId;\r\n                    }\r\n\r\n                    if (!document.pointerLockElement) {\r\n                        try {\r\n                            this._elementToAttachTo.setPointerCapture(this._mouseId);\r\n                        } catch (e) {\r\n                            // DO NOTHING\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Touch; Since touches are dynamically assigned, only set capture if we have an id\r\n                    if (evt.pointerId && !document.pointerLockElement) {\r\n                        try {\r\n                            this._elementToAttachTo.setPointerCapture(evt.pointerId);\r\n                        } catch (e) {\r\n                            // DO NOTHING\r\n                        }\r\n                    }\r\n                }\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n                pointer[evt.button + 2] = 1;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\r\n                // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\r\n                // EG. ([X, Y, Left-click], Middle-click, etc...)\r\n                deviceEvent.inputIndex = evt.button + 2;\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\r\n                    deviceEvent.inputIndex = PointerInput.Move;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerUpEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n            if (deviceType === DeviceType.Touch) {\r\n                // If we're getting a pointerup event for a touch that isn't active, just return.\r\n                if (deviceSlot === -1) {\r\n                    return;\r\n                } else {\r\n                    this._activeTouchIds[deviceSlot] = -1;\r\n                }\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType]?.[deviceSlot];\r\n            if (pointer && pointer[evt.button + 2] !== 0) {\r\n                const previousHorizontal = pointer[PointerInput.Horizontal];\r\n                const previousVertical = pointer[PointerInput.Vertical];\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n                pointer[evt.button + 2] = 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                if (evt.pointerId === undefined) {\r\n                    evt.pointerId = this._mouseId;\r\n                }\r\n\r\n                if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\r\n                    deviceEvent.inputIndex = PointerInput.Move;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n\r\n                // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\r\n                // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\r\n                // EG. ([X, Y, Left-click], Middle-click, etc...)\r\n                deviceEvent.inputIndex = evt.button + 2;\r\n\r\n                if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                } else if (evt.pointerId && this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(evt.pointerId);\r\n                }\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                if (deviceType === DeviceType.Touch) {\r\n                    this._onDeviceDisconnected(deviceType, deviceSlot);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerCancelEvent = (evt) => {\r\n            if (evt.pointerType === \"mouse\") {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n\r\n                if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                }\r\n\r\n                for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\r\n                    if (pointer[inputIndex] === 1) {\r\n                        pointer[inputIndex] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\r\n                    }\r\n                }\r\n            } else {\r\n                const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n                // If we're getting a pointercancel event for a touch that isn't active, just return\r\n                if (deviceSlot === -1) {\r\n                    return;\r\n                }\r\n\r\n                if (this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(evt.pointerId);\r\n                }\r\n\r\n                this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;\r\n\r\n                const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(\r\n                    DeviceType.Touch,\r\n                    deviceSlot,\r\n                    PointerInput.LeftClick,\r\n                    0,\r\n                    this,\r\n                    this._elementToAttachTo,\r\n                    evt.pointerId\r\n                );\r\n\r\n                this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\r\n\r\n                this._activeTouchIds[deviceSlot] = -1;\r\n                this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\r\n            }\r\n        };\r\n\r\n        // Set Wheel Event Name, code originally from scene.inputManager\r\n        this._wheelEventName =\r\n            \"onwheel\" in document.createElement(\"div\")\r\n                ? \"wheel\" // Modern browsers support \"wheel\"\r\n                : (<any>document).onmousewheel !== undefined\r\n                ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\r\n                : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\r\n\r\n        // Code originally in scene.inputManager.ts\r\n        // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.\r\n        // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.\r\n        // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)\r\n        let passiveSupported = false;\r\n        const noop = function () {};\r\n\r\n        try {\r\n            const options = Object.defineProperty({}, \"passive\", {\r\n                get: function () {\r\n                    passiveSupported = true;\r\n                },\r\n            });\r\n\r\n            this._elementToAttachTo.addEventListener(\"test\", noop, options);\r\n            this._elementToAttachTo.removeEventListener(\"test\", noop, options);\r\n        } catch (e) {\r\n            /* */\r\n        }\r\n\r\n        this._pointerBlurEvent = () => {\r\n            // Handle mouse buttons\r\n            if (this.isDeviceAvailable(DeviceType.Mouse)) {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n\r\n                if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                }\r\n\r\n                for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\r\n                    if (pointer[inputIndex] === 1) {\r\n                        pointer[inputIndex] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Handle Active Touches\r\n            if (this.isDeviceAvailable(DeviceType.Touch)) {\r\n                const pointer = this._inputs[DeviceType.Touch];\r\n\r\n                for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {\r\n                    const pointerId = this._activeTouchIds[deviceSlot];\r\n\r\n                    if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {\r\n                        this._elementToAttachTo.releasePointerCapture(pointerId);\r\n                    }\r\n\r\n                    if (pointerId !== -1 && pointer[deviceSlot]?.[PointerInput.LeftClick] === 1) {\r\n                        pointer[deviceSlot][PointerInput.LeftClick] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(\r\n                            DeviceType.Touch,\r\n                            deviceSlot,\r\n                            PointerInput.LeftClick,\r\n                            0,\r\n                            this,\r\n                            this._elementToAttachTo,\r\n                            pointerId\r\n                        );\r\n\r\n                        this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\r\n\r\n                        this._activeTouchIds[deviceSlot] = -1;\r\n                        this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerWheelEvent = (evt) => {\r\n            const deviceType = DeviceType.Mouse;\r\n            const deviceSlot = 0;\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = [];\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._pointerActive = true;\r\n                this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;\r\n                pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;\r\n                pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                // By default, there is no pointerId for mouse wheel events so we'll add one here\r\n                // This logic was originally in the InputManager but was added here to make the\r\n                // InputManager more platform-agnostic\r\n                if (evt.pointerId === undefined) {\r\n                    evt.pointerId = this._mouseId;\r\n                }\r\n\r\n                if (pointer[PointerInput.MouseWheelX] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelX;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n                if (pointer[PointerInput.MouseWheelY] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelY;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n                if (pointer[PointerInput.MouseWheelZ] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelZ;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Workaround for MacOS Chromium Browsers for lost pointer capture bug\r\n        if (this._usingMacOS && this._isUsingChromium) {\r\n            this._pointerMacOSChromeOutEvent = (evt) => {\r\n                if (evt.buttons > 1) {\r\n                    this._pointerCancelEvent(evt);\r\n                }\r\n            };\r\n            this._elementToAttachTo.addEventListener(\"lostpointercapture\", this._pointerMacOSChromeOutEvent);\r\n        }\r\n\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\r\n        this._elementToAttachTo.addEventListener(\"blur\", this._pointerBlurEvent);\r\n        this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);\r\n\r\n        // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame\r\n        this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {\r\n            if (this.isDeviceAvailable(DeviceType.Mouse)) {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n                pointer[PointerInput.MouseWheelX] = 0;\r\n                pointer[PointerInput.MouseWheelY] = 0;\r\n                pointer[PointerInput.MouseWheelZ] = 0;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from gamepad interaction\r\n     */\r\n    private _handleGamepadActions(): void {\r\n        this._gamepadConnectedEvent = (evt: any) => {\r\n            this._addGamePad(evt.gamepad);\r\n        };\r\n\r\n        this._gamepadDisconnectedEvent = (evt: any) => {\r\n            if (this._gamepads) {\r\n                const deviceType = this._getGamepadDeviceType(evt.gamepad.id);\r\n                const deviceSlot = evt.gamepad.index;\r\n\r\n                this._unregisterDevice(deviceType, deviceSlot);\r\n                delete this._gamepads[deviceSlot];\r\n            }\r\n        };\r\n\r\n        window.addEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\r\n        window.addEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\r\n    }\r\n\r\n    /**\r\n     * Update all non-event based devices with each frame\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param inputIndex Id of input to be checked\r\n     */\r\n    private _updateDevice(deviceType: DeviceType, deviceSlot: number, inputIndex: number): void {\r\n        // Gamepads\r\n        const gp = navigator.getGamepads()[deviceSlot];\r\n\r\n        if (gp && deviceType === this._gamepads[deviceSlot]) {\r\n            const device = this._inputs[deviceType][deviceSlot];\r\n\r\n            if (inputIndex >= gp.buttons.length) {\r\n                device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();\r\n            } else {\r\n                device[inputIndex] = gp.buttons[inputIndex].value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets DeviceType from the device name\r\n     * @param deviceName Name of Device from DeviceInputSystem\r\n     * @returns DeviceType enum value\r\n     */\r\n    private _getGamepadDeviceType(deviceName: string): DeviceType {\r\n        if (deviceName.indexOf(\"054c\") !== -1) {\r\n            // DualShock 4 Gamepad\r\n            return deviceName.indexOf(\"0ce6\") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;\r\n        } else if (deviceName.indexOf(\"Xbox One\") !== -1 || deviceName.search(\"Xbox 360\") !== -1 || deviceName.search(\"xinput\") !== -1) {\r\n            // Xbox Gamepad\r\n            return DeviceType.Xbox;\r\n        } else if (deviceName.indexOf(\"057e\") !== -1) {\r\n            // Switch Gamepad\r\n            return DeviceType.Switch;\r\n        }\r\n\r\n        return DeviceType.Generic;\r\n    }\r\n\r\n    /**\r\n     * Get DeviceType from a given pointer/mouse/touch event.\r\n     * @param evt PointerEvent to evaluate\r\n     * @returns DeviceType interpreted from event\r\n     */\r\n    private _getPointerType(evt: any): DeviceType {\r\n        let deviceType = DeviceType.Mouse;\r\n\r\n        if (evt.pointerType === \"touch\" || evt.pointerType === \"pen\" || evt.touches) {\r\n            deviceType = DeviceType.Touch;\r\n        }\r\n\r\n        return deviceType;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}