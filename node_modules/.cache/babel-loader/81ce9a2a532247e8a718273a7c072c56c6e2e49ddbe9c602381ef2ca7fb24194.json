{"ast":null,"code":"import { ExternalTexture } from \"../../Materials/Textures/externalTexture.js\";\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler.js\";\n/** @internal */\nexport class WebGPUMaterialContext {\n  get forceBindGroupCreation() {\n    // If there is at least one external texture to bind, we must recreate the bind groups each time\n    // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\n    return this._numExternalTextures > 0;\n  }\n  get hasFloatTextures() {\n    return this._numFloatTextures > 0;\n  }\n  constructor() {\n    this.uniqueId = WebGPUMaterialContext._Counter++;\n    this.updateId = 0;\n    this.textureState = 0;\n    this.reset();\n  }\n  reset() {\n    this.samplers = {};\n    this.textures = {};\n    this.isDirty = true;\n    this._numFloatTextures = 0;\n    this._numExternalTextures = 0;\n  }\n  setSampler(name, sampler) {\n    let samplerCache = this.samplers[name];\n    let currentHashCode = -1;\n    if (!samplerCache) {\n      this.samplers[name] = samplerCache = {\n        sampler,\n        hashCode: 0\n      };\n    } else {\n      currentHashCode = samplerCache.hashCode;\n    }\n    samplerCache.sampler = sampler;\n    samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\n    const isDirty = currentHashCode !== samplerCache.hashCode;\n    if (isDirty) {\n      this.updateId++;\n    }\n    this.isDirty || (this.isDirty = isDirty);\n  }\n  setTexture(name, texture) {\n    var _a, _b, _c;\n    let textureCache = this.textures[name];\n    let currentTextureId = -1;\n    if (!textureCache) {\n      this.textures[name] = textureCache = {\n        texture,\n        isFloatTexture: false,\n        isExternalTexture: false\n      };\n    } else {\n      currentTextureId = (_b = (_a = textureCache.texture) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : -1;\n    }\n    if (textureCache.isExternalTexture) {\n      this._numExternalTextures--;\n    }\n    if (textureCache.isFloatTexture) {\n      this._numFloatTextures--;\n    }\n    if (texture) {\n      textureCache.isFloatTexture = texture.type === 1;\n      textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\n      if (textureCache.isFloatTexture) {\n        this._numFloatTextures++;\n      }\n      if (textureCache.isExternalTexture) {\n        this._numExternalTextures++;\n      }\n    } else {\n      textureCache.isFloatTexture = false;\n      textureCache.isExternalTexture = false;\n    }\n    textureCache.texture = texture;\n    const isDirty = currentTextureId !== ((_c = texture === null || texture === void 0 ? void 0 : texture.uniqueId) !== null && _c !== void 0 ? _c : -1);\n    if (isDirty) {\n      this.updateId++;\n    }\n    this.isDirty || (this.isDirty = isDirty);\n  }\n}\nWebGPUMaterialContext._Counter = 0;","map":{"version":3,"names":["ExternalTexture","WebGPUCacheSampler","WebGPUMaterialContext","forceBindGroupCreation","_numExternalTextures","hasFloatTextures","_numFloatTextures","constructor","uniqueId","_Counter","updateId","textureState","reset","samplers","textures","isDirty","setSampler","name","sampler","samplerCache","currentHashCode","hashCode","GetSamplerHashCode","setTexture","texture","textureCache","currentTextureId","isFloatTexture","isExternalTexture","_b","_a","type","IsExternalTexture","_c"],"sources":["../../../../../dev/core/src/Engines/WebGPU/webgpuMaterialContext.ts"],"sourcesContent":["import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { IMaterialContext } from \"../IMaterialContext\";\r\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextSamplerCache {\r\n    sampler: Nullable<TextureSampler>;\r\n    hashCode: number;\r\n}\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextTextureCache {\r\n    texture: Nullable<InternalTexture | ExternalTexture>;\r\n    isFloatTexture: boolean;\r\n    isExternalTexture: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUMaterialContext implements IMaterialContext {\r\n    private static _Counter = 0;\r\n\r\n    public uniqueId: number;\r\n    public updateId: number;\r\n    public isDirty: boolean;\r\n    public samplers: { [name: string]: Nullable<IWebGPUMaterialContextSamplerCache> };\r\n    public textures: { [name: string]: Nullable<IWebGPUMaterialContextTextureCache> };\r\n\r\n    // The texture state is a bitfield where each bit is set if the texture is a float32 texture (calculated in @WebGPUEngine._draw).\r\n    // Float32 textures must be handled differently because float filtering may not be supported by the underlying browser implementation.\r\n    // In this case, we must configure the sampler as \"non filtering\", as well as set the texture sample type to \"unfilterable-float\" when creating the bind group layout.\r\n    // When that happens, we end up with different bind group layouts (depending on which type of textures have been set in the material), that we must all store\r\n    // in the WebGPUPipelineContext (see @WebGPUPipelineContext.bindGroupLayouts) for later retrieval in the bind group cache implementation (see @WebGPUCacheBindGroups.getBindGroups), thanks to this property.\r\n    public textureState: number;\r\n\r\n    public get forceBindGroupCreation() {\r\n        // If there is at least one external texture to bind, we must recreate the bind groups each time\r\n        // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\r\n        return this._numExternalTextures > 0;\r\n    }\r\n\r\n    public get hasFloatTextures() {\r\n        return this._numFloatTextures > 0;\r\n    }\r\n\r\n    protected _numFloatTextures: number;\r\n    protected _numExternalTextures: number;\r\n\r\n    constructor() {\r\n        this.uniqueId = WebGPUMaterialContext._Counter++;\r\n        this.updateId = 0;\r\n        this.textureState = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.samplers = {};\r\n        this.textures = {};\r\n        this.isDirty = true;\r\n        this._numFloatTextures = 0;\r\n        this._numExternalTextures = 0;\r\n    }\r\n\r\n    public setSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        let samplerCache = this.samplers[name];\r\n        let currentHashCode = -1;\r\n        if (!samplerCache) {\r\n            this.samplers[name] = samplerCache = { sampler, hashCode: 0 };\r\n        } else {\r\n            currentHashCode = samplerCache.hashCode;\r\n        }\r\n\r\n        samplerCache.sampler = sampler;\r\n        samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\r\n\r\n        const isDirty = currentHashCode !== samplerCache.hashCode;\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n\r\n    public setTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>): void {\r\n        let textureCache = this.textures[name];\r\n        let currentTextureId = -1;\r\n        if (!textureCache) {\r\n            this.textures[name] = textureCache = { texture, isFloatTexture: false, isExternalTexture: false };\r\n        } else {\r\n            currentTextureId = textureCache.texture?.uniqueId ?? -1;\r\n        }\r\n\r\n        if (textureCache.isExternalTexture) {\r\n            this._numExternalTextures--;\r\n        }\r\n        if (textureCache.isFloatTexture) {\r\n            this._numFloatTextures--;\r\n        }\r\n\r\n        if (texture) {\r\n            textureCache.isFloatTexture = texture.type === Constants.TEXTURETYPE_FLOAT;\r\n            textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\r\n            if (textureCache.isFloatTexture) {\r\n                this._numFloatTextures++;\r\n            }\r\n            if (textureCache.isExternalTexture) {\r\n                this._numExternalTextures++;\r\n            }\r\n        } else {\r\n            textureCache.isFloatTexture = false;\r\n            textureCache.isExternalTexture = false;\r\n        }\r\n\r\n        textureCache.texture = texture;\r\n\r\n        const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}