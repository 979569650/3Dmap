{"ast":null,"code":"import { Quaternion, Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Light } from \"../Lights/light.js\";\n/**\n * Anchor options where the Gizmo can be positioned in relation to its anchored node\n */\nexport var GizmoAnchorPoint;\n(function (GizmoAnchorPoint) {\n  /** The origin of the attached node */\n  GizmoAnchorPoint[GizmoAnchorPoint[\"Origin\"] = 0] = \"Origin\";\n  /** The pivot point of the attached node*/\n  GizmoAnchorPoint[GizmoAnchorPoint[\"Pivot\"] = 1] = \"Pivot\";\n})(GizmoAnchorPoint || (GizmoAnchorPoint = {}));\n/**\n * Coordinates mode: Local or World. Defines how axis is aligned: either on world axis or transform local axis\n */\nexport var GizmoCoordinatesMode;\n(function (GizmoCoordinatesMode) {\n  GizmoCoordinatesMode[GizmoCoordinatesMode[\"World\"] = 0] = \"World\";\n  GizmoCoordinatesMode[GizmoCoordinatesMode[\"Local\"] = 1] = \"Local\";\n})(GizmoCoordinatesMode || (GizmoCoordinatesMode = {}));\n/**\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\n */\nexport class Gizmo {\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * True when the mouse pointer is hovered a gizmo mesh\n   */\n  get isHovered() {\n    return this._isHovered;\n  }\n  /**\n   * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\n   * * When set, interactions will be enabled\n   */\n  get attachedMesh() {\n    return this._attachedMesh;\n  }\n  set attachedMesh(value) {\n    this._attachedMesh = value;\n    if (value) {\n      this._attachedNode = value;\n    }\n    this._rootMesh.setEnabled(value ? true : false);\n    this._attachedNodeChanged(value);\n  }\n  /**\n   * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\n   * * When set, interactions will be enabled\n   */\n  get attachedNode() {\n    return this._attachedNode;\n  }\n  set attachedNode(value) {\n    this._attachedNode = value;\n    this._attachedMesh = null;\n    this._rootMesh.setEnabled(value ? true : false);\n    this._attachedNodeChanged(value);\n  }\n  /**\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\n   * @param mesh The mesh to replace the default mesh of the gizmo\n   */\n  setCustomMesh(mesh) {\n    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\n      throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n    }\n    this._rootMesh.getChildMeshes().forEach(c => {\n      c.dispose();\n    });\n    mesh.parent = this._rootMesh;\n    this._customMeshSet = true;\n  }\n  /**\n   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n   */\n  set updateGizmoRotationToMatchAttachedMesh(value) {\n    this._updateGizmoRotationToMatchAttachedMesh = value;\n  }\n  get updateGizmoRotationToMatchAttachedMesh() {\n    return this._updateGizmoRotationToMatchAttachedMesh;\n  }\n  /**\n   * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\n   */\n  set updateGizmoPositionToMatchAttachedMesh(value) {\n    this._updateGizmoPositionToMatchAttachedMesh = value;\n  }\n  get updateGizmoPositionToMatchAttachedMesh() {\n    return this._updateGizmoPositionToMatchAttachedMesh;\n  }\n  /**\n   * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\n   * (Default: GizmoAnchorPoint.Origin)\n   */\n  set anchorPoint(value) {\n    this._anchorPoint = value;\n  }\n  get anchorPoint() {\n    return this._anchorPoint;\n  }\n  /**\n   * Set the coordinate system to use. By default it's local.\n   * But it's possible for a user to tweak so its local for translation and world for rotation.\n   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n   */\n  set coordinatesMode(coordinatesMode) {\n    this._coordinatesMode = coordinatesMode;\n    const local = coordinatesMode == GizmoCoordinatesMode.Local;\n    this.updateGizmoRotationToMatchAttachedMesh = local;\n    this.updateGizmoPositionToMatchAttachedMesh = true;\n  }\n  get coordinatesMode() {\n    return this._coordinatesMode;\n  }\n  /**\n   * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\n   */\n  set updateScale(value) {\n    this._updateScale = value;\n  }\n  get updateScale() {\n    return this._updateScale;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _attachedNodeChanged(value) {}\n  /**\n   * Creates a gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor( /** The utility layer the gizmo will be added to */\n  gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {\n    this.gizmoLayer = gizmoLayer;\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._customRotationQuaternion = null;\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    this._scaleRatio = 1;\n    /**\n     * boolean updated by pointermove when a gizmo mesh is hovered\n     */\n    this._isHovered = false;\n    /**\n     * If a custom mesh has been set (Default: false)\n     */\n    this._customMeshSet = false;\n    this._updateGizmoRotationToMatchAttachedMesh = true;\n    this._updateGizmoPositionToMatchAttachedMesh = true;\n    this._anchorPoint = GizmoAnchorPoint.Origin;\n    this._updateScale = true;\n    this._coordinatesMode = GizmoCoordinatesMode.Local;\n    this._interactionsEnabled = true;\n    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\n    this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\n    this._rootMesh.rotationQuaternion = Quaternion.Identity();\n    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\n      this._update();\n    });\n  }\n  /**\n   * posture that the gizmo will be display\n   * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n   */\n  get customRotationQuaternion() {\n    return this._customRotationQuaternion;\n  }\n  set customRotationQuaternion(customRotationQuaternion) {\n    this._customRotationQuaternion = customRotationQuaternion;\n  }\n  /**\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    if (this.attachedNode) {\n      let effectiveNode = this.attachedNode;\n      if (this.attachedMesh) {\n        effectiveNode = this.attachedMesh || this.attachedNode;\n      }\n      // Position\n      if (this.updateGizmoPositionToMatchAttachedMesh) {\n        if (this.anchorPoint == GizmoAnchorPoint.Pivot && effectiveNode.getAbsolutePivotPoint) {\n          const position = effectiveNode.getAbsolutePivotPoint();\n          this._rootMesh.position.copyFrom(position);\n        } else {\n          const row = effectiveNode.getWorldMatrix().getRow(3);\n          const position = row ? row.toVector3() : new Vector3(0, 0, 0);\n          this._rootMesh.position.copyFrom(position);\n        }\n      }\n      // Rotation\n      if (this.updateGizmoRotationToMatchAttachedMesh) {\n        const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === \"AbstractMesh\" || effectiveNode.getClassName() === \"TransformNode\" || effectiveNode.getClassName() === \"InstancedMesh\";\n        const transformNode = supportedNode ? effectiveNode : undefined;\n        effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\n        this._rootMesh.rotationQuaternion.normalize();\n      } else {\n        if (this._customRotationQuaternion) {\n          this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);\n        } else {\n          this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);\n        }\n      }\n      // Scale\n      if (this.updateScale) {\n        const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;\n        const cameraPosition = activeCamera.globalPosition;\n        this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);\n        let scale = this.scaleRatio;\n        if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\n          if (activeCamera.orthoTop && activeCamera.orthoBottom) {\n            const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\n            scale *= orthoHeight;\n          }\n        } else {\n          const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\n          const direction = activeCamera.getDirection(camForward);\n          scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);\n        }\n        this._rootMesh.scaling.setAll(scale);\n        // Account for handedness, similar to Matrix.decompose\n        if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\n          this._rootMesh.scaling.y *= -1;\n        }\n      } else {\n        this._rootMesh.scaling.setAll(this.scaleRatio);\n      }\n    }\n  }\n  /**\n   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\n   */\n  _matrixChanged() {\n    if (!this._attachedNode) {\n      return;\n    }\n    if (this._attachedNode._isCamera) {\n      const camera = this._attachedNode;\n      let worldMatrix;\n      let worldMatrixUC;\n      if (camera.parent) {\n        const parentInv = TmpVectors.Matrix[1];\n        camera.parent._worldMatrix.invertToRef(parentInv);\n        this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);\n        worldMatrix = TmpVectors.Matrix[0];\n      } else {\n        worldMatrix = this._attachedNode._worldMatrix;\n      }\n      if (camera.getScene().useRightHandedSystem) {\n        // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\n        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);\n        worldMatrixUC = TmpVectors.Matrix[1];\n      } else {\n        worldMatrixUC = worldMatrix;\n      }\n      worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n      const inheritsTargetCamera = this._attachedNode.getClassName() === \"FreeCamera\" || this._attachedNode.getClassName() === \"FlyCamera\" || this._attachedNode.getClassName() === \"ArcFollowCamera\" || this._attachedNode.getClassName() === \"TargetCamera\" || this._attachedNode.getClassName() === \"TouchCamera\" || this._attachedNode.getClassName() === \"UniversalCamera\";\n      if (inheritsTargetCamera) {\n        const targetCamera = this._attachedNode;\n        targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();\n        if (targetCamera.rotationQuaternion) {\n          targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\n          targetCamera.rotationQuaternion.normalize();\n        }\n      }\n      camera.position.copyFrom(TmpVectors.Vector3[0]);\n    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === \"AbstractMesh\" || this._attachedNode.getClassName() === \"TransformNode\" || this._attachedNode.getClassName() === \"InstancedMesh\") {\n      const transform = this._attachedNode;\n      if (transform.parent) {\n        const parentInv = TmpVectors.Matrix[0];\n        const localMat = TmpVectors.Matrix[1];\n        transform.parent.getWorldMatrix().invertToRef(parentInv);\n        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\n        localMat.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position);\n        TmpVectors.Quaternion[0].normalize();\n        if (transform.isUsingPivotMatrix()) {\n          // Calculate the local matrix without the translation.\n          // Copied from TranslateNode.computeWorldMatrix\n          const r = TmpVectors.Quaternion[1];\n          Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);\n          const scaleMatrix = TmpVectors.Matrix[2];\n          Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);\n          const rotationMatrix = TmpVectors.Matrix[2];\n          r.toRotationMatrix(rotationMatrix);\n          const pivotMatrix = transform.getPivotMatrix();\n          const invPivotMatrix = TmpVectors.Matrix[3];\n          pivotMatrix.invertToRef(invPivotMatrix);\n          pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\n          TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);\n          TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);\n          TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);\n          transform.position.subtractInPlace(TmpVectors.Vector3[1]);\n        }\n      } else {\n        this._attachedNode._worldMatrix.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined);\n      }\n      TmpVectors.Vector3[0].scaleInPlace(1.0 / transform.scalingDeterminant);\n      transform.scaling.copyFrom(TmpVectors.Vector3[0]);\n      if (!transform.billboardMode) {\n        if (transform.rotationQuaternion) {\n          transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\n          transform.rotationQuaternion.normalize();\n        } else {\n          transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();\n        }\n      }\n    } else if (this._attachedNode.getClassName() === \"Bone\") {\n      const bone = this._attachedNode;\n      const parent = bone.getParent();\n      if (parent) {\n        const invParent = TmpVectors.Matrix[0];\n        const boneLocalMatrix = TmpVectors.Matrix[1];\n        parent.getFinalMatrix().invertToRef(invParent);\n        bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);\n        const lmat = bone.getLocalMatrix();\n        lmat.copyFrom(boneLocalMatrix);\n      } else {\n        const lmat = bone.getLocalMatrix();\n        lmat.copyFrom(bone.getFinalMatrix());\n      }\n      bone.markAsDirty();\n    } else {\n      const light = this._attachedNode;\n      if (light.getTypeID) {\n        const type = light.getTypeID();\n        if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\n          const parent = light.parent;\n          if (parent) {\n            const invParent = TmpVectors.Matrix[0];\n            const nodeLocalMatrix = TmpVectors.Matrix[1];\n            parent.getWorldMatrix().invertToRef(invParent);\n            light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\n            nodeLocalMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n          } else {\n            this._attachedNode._worldMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n          }\n          // setter doesn't copy values. Need a new Vector3\n          light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);\n          if (light.direction) {\n            light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * refresh gizmo mesh material\n   * @param gizmoMeshes\n   * @param material material to apply\n   */\n  _setGizmoMeshMaterial(gizmoMeshes, material) {\n    if (gizmoMeshes) {\n      gizmoMeshes.forEach(m => {\n        m.material = material;\n        if (m.color) {\n          m.color = material.diffuseColor;\n        }\n      });\n    }\n  }\n  /**\n   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   * @returns {Observer<PointerInfo>} pointerObserver\n   */\n  static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {\n    let dragging = false;\n    const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      var _a, _b;\n      if (pointerInfo.pickInfo) {\n        // On Hover Logic\n        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\n          if (dragging) {\n            return;\n          }\n          gizmoAxisCache.forEach(cache => {\n            var _a, _b;\n            if (cache.colliderMeshes && cache.gizmoMeshes) {\n              const isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(m => {\n                m.material = material;\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            }\n          });\n        }\n        // On Mouse Down\n        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n          // If user Clicked Gizmo\n          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) === null || _a === void 0 ? void 0 : _a.parent)) {\n            dragging = true;\n            const statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) === null || _b === void 0 ? void 0 : _b.parent);\n            statusMap.active = true;\n            gizmoAxisCache.forEach(cache => {\n              var _a, _b;\n              const isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(m => {\n                m.material = material;\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            });\n          }\n        }\n        // On Mouse Up\n        if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n          gizmoAxisCache.forEach(cache => {\n            cache.active = false;\n            dragging = false;\n            cache.gizmoMeshes.forEach(m => {\n              m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\n              if (m.color) {\n                m.color = cache.material.diffuseColor;\n              }\n            });\n          });\n        }\n      }\n    });\n    return pointerObserver;\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this._rootMesh.dispose();\n    if (this._beforeRenderObserver) {\n      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n  }\n}\n/**\n * When enabled, any gizmo operation will perserve scaling sign. Default is off.\n * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\n */\nGizmo.PreserveScaling = false;","map":{"version":3,"names":["Quaternion","Vector3","Matrix","TmpVectors","Mesh","Camera","UtilityLayerRenderer","PointerEventTypes","Light","GizmoAnchorPoint","GizmoCoordinatesMode","Gizmo","scaleRatio","value","_scaleRatio","isHovered","_isHovered","attachedMesh","_attachedMesh","_attachedNode","_rootMesh","setEnabled","_attachedNodeChanged","attachedNode","setCustomMesh","mesh","getScene","gizmoLayer","utilityLayerScene","getChildMeshes","forEach","c","dispose","parent","_customMeshSet","updateGizmoRotationToMatchAttachedMesh","_updateGizmoRotationToMatchAttachedMesh","updateGizmoPositionToMatchAttachedMesh","_updateGizmoPositionToMatchAttachedMesh","anchorPoint","_anchorPoint","coordinatesMode","_coordinatesMode","local","Local","updateScale","_updateScale","constructor","DefaultUtilityLayer","_customRotationQuaternion","Origin","_interactionsEnabled","_rightHandtoLeftHandMatrix","RotationY","Math","PI","rotationQuaternion","Identity","_beforeRenderObserver","onBeforeRenderObservable","add","_update","customRotationQuaternion","effectiveNode","Pivot","getAbsolutePivotPoint","position","copyFrom","row","getWorldMatrix","getRow","toVector3","supportedNode","_isMesh","getClassName","transformNode","undefined","decompose","PreserveScaling","normalize","set","activeCamera","cameraPosition","globalPosition","subtractToRef","scale","mode","ORTHOGRAPHIC_CAMERA","orthoTop","orthoBottom","orthoHeight","camForward","useRightHandedSystem","RightHandedForwardReadOnly","LeftHandedForwardReadOnly","direction","getDirection","Dot","scaling","setAll","_getWorldMatrixDeterminant","y","_matrixChanged","_isCamera","camera","worldMatrix","worldMatrixUC","parentInv","_worldMatrix","invertToRef","multiplyToRef","inheritsTargetCamera","targetCamera","rotation","toEulerAngles","transform","localMat","isUsingPivotMatrix","r","RotationYawPitchRollToRef","x","z","scaleMatrix","ScalingToRef","rotationMatrix","toRotationMatrix","pivotMatrix","getPivotMatrix","invPivotMatrix","getTranslationToRef","subtractInPlace","scaleInPlace","scalingDeterminant","billboardMode","bone","getParent","invParent","boneLocalMatrix","getFinalMatrix","lmat","getLocalMatrix","markAsDirty","light","getTypeID","type","LIGHTTYPEID_DIRECTIONALLIGHT","LIGHTTYPEID_SPOTLIGHT","LIGHTTYPEID_POINTLIGHT","nodeLocalMatrix","_setGizmoMeshMaterial","gizmoMeshes","material","m","color","diffuseColor","GizmoAxisPointerObserver","gizmoAxisCache","dragging","pointerObserver","onPointerObservable","pointerInfo","pickInfo","POINTERMOVE","cache","colliderMeshes","_a","indexOf","_b","pickedMesh","dragBehavior","enabled","active","hoverMaterial","disableMaterial","POINTERDOWN","has","statusMap","get","POINTERUP","remove"],"sources":["../../../../dev/core/src/Gizmos/gizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { ShadowLight } from \"../Lights/shadowLight\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to render the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to indicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to indicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to indicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n    /** DragBehavior */\r\n    dragBehavior: PointerDragBehavior;\r\n}\r\n\r\n/**\r\n * Anchor options where the Gizmo can be positioned in relation to its anchored node\r\n */\r\nexport enum GizmoAnchorPoint {\r\n    /** The origin of the attached node */\r\n    Origin,\r\n    /** The pivot point of the attached node*/\r\n    Pivot,\r\n}\r\n\r\n/**\r\n * Coordinates mode: Local or World. Defines how axis is aligned: either on world axis or transform local axis\r\n */\r\nexport enum GizmoCoordinatesMode {\r\n    World,\r\n    Local,\r\n}\r\n\r\n/**\r\n * Interface for basic gizmo\r\n */\r\nexport interface IGizmo extends IDisposable {\r\n    /** True when the mouse pointer is hovered a gizmo mesh */\r\n    readonly isHovered: boolean;\r\n    /** The root mesh of the gizmo */\r\n    _rootMesh: Mesh;\r\n    /** Ratio for the scale of the gizmo */\r\n    scaleRatio: number;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedMesh: Nullable<AbstractMesh>;\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedNode: Nullable<Node>;\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoRotationToMatchAttachedMesh: boolean;\r\n    /** The utility layer the gizmo will be added to */\r\n    gizmoLayer: UtilityLayerRenderer;\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoPositionToMatchAttachedMesh: boolean;\r\n    /**\r\n     * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\r\n     * (Default: GizmoAnchorPoint.Origin)\r\n     */\r\n    anchorPoint: GizmoAnchorPoint;\r\n\r\n    /**\r\n     * Set the coordinate mode to use. By default it's local.\r\n     */\r\n    coordinatesMode: GizmoCoordinatesMode;\r\n\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale: boolean;\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    customRotationQuaternion: Nullable<Quaternion>;\r\n    /** Disposes and replaces the current meshes in the gizmo with the specified mesh */\r\n    setCustomMesh(mesh: Mesh): void;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IGizmo {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _customRotationQuaternion: Nullable<Quaternion> = null;\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * When enabled, any gizmo operation will perserve scaling sign. Default is off.\r\n     * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\r\n     */\r\n    public static PreserveScaling = false;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n    protected _updateGizmoPositionToMatchAttachedMesh = true;\r\n    protected _anchorPoint = GizmoAnchorPoint.Origin;\r\n    protected _updateScale = true;\r\n    protected _coordinatesMode = GizmoCoordinatesMode.Local;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoPositionToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoPositionToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoPositionToMatchAttachedMesh() {\r\n        return this._updateGizmoPositionToMatchAttachedMesh;\r\n    }\r\n\r\n    /**\r\n     * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\r\n     * (Default: GizmoAnchorPoint.Origin)\r\n     */\r\n    public set anchorPoint(value: GizmoAnchorPoint) {\r\n        this._anchorPoint = value;\r\n    }\r\n    public get anchorPoint() {\r\n        return this._anchorPoint;\r\n    }\r\n\r\n    /**\r\n     * Set the coordinate system to use. By default it's local.\r\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\r\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\r\n     */\r\n    public set coordinatesMode(coordinatesMode: GizmoCoordinatesMode) {\r\n        this._coordinatesMode = coordinatesMode;\r\n        const local = coordinatesMode == GizmoCoordinatesMode.Local;\r\n        this.updateGizmoRotationToMatchAttachedMesh = local;\r\n        this.updateGizmoPositionToMatchAttachedMesh = true;\r\n    }\r\n\r\n    public get coordinatesMode() {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n\r\n    public set updateScale(value: boolean) {\r\n        this._updateScale = value;\r\n    }\r\n    public get updateScale() {\r\n        return this._updateScale;\r\n    }\r\n    protected _interactionsEnabled = true;\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {}\r\n\r\n    protected _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer\r\n    ) {\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    public get customRotationQuaternion(): Nullable<Quaternion> {\r\n        return this._customRotationQuaternion;\r\n    }\r\n\r\n    public set customRotationQuaternion(customRotationQuaternion: Nullable<Quaternion>) {\r\n        this._customRotationQuaternion = customRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            let effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                if (this.anchorPoint == GizmoAnchorPoint.Pivot && (<TransformNode>effectiveNode).getAbsolutePivotPoint) {\r\n                    const position = (<TransformNode>effectiveNode).getAbsolutePivotPoint();\r\n                    this._rootMesh.position.copyFrom(position);\r\n                } else {\r\n                    const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                    const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                    this._rootMesh.position.copyFrom(position);\r\n                }\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                const supportedNode =\r\n                    (<Mesh>effectiveNode)._isMesh ||\r\n                    effectiveNode.getClassName() === \"AbstractMesh\" ||\r\n                    effectiveNode.getClassName() === \"TransformNode\" ||\r\n                    effectiveNode.getClassName() === \"InstancedMesh\";\r\n                const transformNode = supportedNode ? (effectiveNode as TransformNode) : undefined;\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n                this._rootMesh.rotationQuaternion!.normalize();\r\n            } else {\r\n                if (this._customRotationQuaternion) {\r\n                    this._rootMesh.rotationQuaternion!.copyFrom(this._customRotationQuaternion);\r\n                } else {\r\n                    this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n                }\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                const cameraPosition = activeCamera.globalPosition;\r\n                this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);\r\n                let scale = this.scaleRatio;\r\n                if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\r\n                    if (activeCamera.orthoTop && activeCamera.orthoBottom) {\r\n                        const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\r\n                        scale *= orthoHeight;\r\n                    }\r\n                } else {\r\n                    const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\r\n                    const direction = activeCamera.getDirection(camForward);\r\n                    scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);\r\n                }\r\n                this._rootMesh.scaling.setAll(scale);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     */\r\n    protected _matrixChanged() {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if ((<Camera>this._attachedNode)._isCamera) {\r\n            const camera = this._attachedNode as Camera;\r\n            let worldMatrix;\r\n            let worldMatrixUC;\r\n            if (camera.parent) {\r\n                const parentInv = TmpVectors.Matrix[1];\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);\r\n                worldMatrix = TmpVectors.Matrix[0];\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);\r\n                worldMatrixUC = TmpVectors.Matrix[1];\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n\r\n            const inheritsTargetCamera =\r\n                this._attachedNode.getClassName() === \"FreeCamera\" ||\r\n                this._attachedNode.getClassName() === \"FlyCamera\" ||\r\n                this._attachedNode.getClassName() === \"ArcFollowCamera\" ||\r\n                this._attachedNode.getClassName() === \"TargetCamera\" ||\r\n                this._attachedNode.getClassName() === \"TouchCamera\" ||\r\n                this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                const targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    targetCamera.rotationQuaternion.normalize();\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(TmpVectors.Vector3[0]);\r\n        } else if (\r\n            (<Mesh>this._attachedNode)._isMesh ||\r\n            this._attachedNode.getClassName() === \"AbstractMesh\" ||\r\n            this._attachedNode.getClassName() === \"TransformNode\" ||\r\n            this._attachedNode.getClassName() === \"InstancedMesh\"\r\n        ) {\r\n            const transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                const parentInv = TmpVectors.Matrix[0];\r\n                const localMat = TmpVectors.Matrix[1];\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                localMat.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position);\r\n                TmpVectors.Quaternion[0].normalize();\r\n                if (transform.isUsingPivotMatrix()) {\r\n                    // Calculate the local matrix without the translation.\r\n                    // Copied from TranslateNode.computeWorldMatrix\r\n                    const r = TmpVectors.Quaternion[1];\r\n                    Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);\r\n\r\n                    const scaleMatrix = TmpVectors.Matrix[2];\r\n                    Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);\r\n\r\n                    const rotationMatrix = TmpVectors.Matrix[2];\r\n                    r.toRotationMatrix(rotationMatrix);\r\n\r\n                    const pivotMatrix = transform.getPivotMatrix();\r\n                    const invPivotMatrix = TmpVectors.Matrix[3];\r\n                    pivotMatrix.invertToRef(invPivotMatrix);\r\n\r\n                    pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\r\n                    TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);\r\n                    TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);\r\n\r\n                    TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);\r\n\r\n                    transform.position.subtractInPlace(TmpVectors.Vector3[1]);\r\n                }\r\n            } else {\r\n                this._attachedNode._worldMatrix.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            }\r\n            TmpVectors.Vector3[0].scaleInPlace(1.0 / transform.scalingDeterminant);\r\n            transform.scaling.copyFrom(TmpVectors.Vector3[0]);\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    transform.rotationQuaternion.normalize();\r\n                } else {\r\n                    transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            const bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                const invParent = TmpVectors.Matrix[0];\r\n                const boneLocalMatrix = TmpVectors.Matrix[1];\r\n                parent.getFinalMatrix().invertToRef(invParent);\r\n                bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getFinalMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        } else {\r\n            const light = this._attachedNode as ShadowLight;\r\n            if (light.getTypeID) {\r\n                const type = light.getTypeID();\r\n                if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\r\n                    const parent = light.parent;\r\n\r\n                    if (parent) {\r\n                        const invParent = TmpVectors.Matrix[0];\r\n                        const nodeLocalMatrix = TmpVectors.Matrix[1];\r\n                        parent.getWorldMatrix().invertToRef(invParent);\r\n                        light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\r\n                        nodeLocalMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    } else {\r\n                        this._attachedNode._worldMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    }\r\n                    // setter doesn't copy values. Need a new Vector3\r\n                    light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);\r\n                    if (light.direction) {\r\n                        light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * refresh gizmo mesh material\r\n     * @param gizmoMeshes\r\n     * @param material material to apply\r\n     */\r\n    protected _setGizmoMeshMaterial(gizmoMeshes: Mesh[], material: StandardMaterial) {\r\n        if (gizmoMeshes) {\r\n            gizmoMeshes.forEach((m: Mesh) => {\r\n                m.material = material;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = material.diffuseColor;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n        let dragging = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // On Hover Logic\r\n                if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (dragging) {\r\n                        return;\r\n                    }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = cache.dragBehavior.enabled ? (isHovered || cache.active ? cache.hoverMaterial : cache.material) : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // On Mouse Down\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // On Mouse Up\r\n                if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}