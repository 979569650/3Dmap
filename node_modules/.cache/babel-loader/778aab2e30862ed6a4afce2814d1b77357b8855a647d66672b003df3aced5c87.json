{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUComputeContext {\n  getBindGroups(bindings, computePipeline, bindingsMapping) {\n    if (!bindingsMapping) {\n      throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\n    }\n    if (this._bindGroups.length === 0) {\n      const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\n      for (const key in bindings) {\n        const binding = bindings[key],\n          location = bindingsMapping[key],\n          group = location.group,\n          index = location.binding,\n          type = binding.type,\n          object = binding.object;\n        let indexInGroupEntries = binding.indexInGroupEntries;\n        let entries = this._bindGroupEntries[group];\n        if (!entries) {\n          entries = this._bindGroupEntries[group] = [];\n        }\n        switch (type) {\n          case ComputeBindingType.Sampler:\n            {\n              const sampler = object;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: this._cacheSampler.getSampler(sampler)\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.Texture:\n          case ComputeBindingType.TextureWithoutSampler:\n            {\n              const texture = object;\n              const hardwareTexture = texture._texture._hardwareTexture;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                if (type === ComputeBindingType.Texture) {\n                  entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture);\n                }\n                entries[indexInGroupEntries].resource = hardwareTexture.view;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                if (type === ComputeBindingType.Texture) {\n                  entries.push({\n                    binding: index - 1,\n                    resource: this._cacheSampler.getSampler(texture._texture)\n                  });\n                }\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.view\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.StorageTexture:\n            {\n              const texture = object;\n              const hardwareTexture = texture._texture._hardwareTexture;\n              if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\n                Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\n              }\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.viewForWriting\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.ExternalTexture:\n            {\n              const texture = object;\n              const externalTexture = texture.underlyingResource;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = this._device.importExternalTexture({\n                  source: externalTexture\n                });\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: this._device.importExternalTexture({\n                    source: externalTexture\n                  })\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.UniformBuffer:\n          case ComputeBindingType.StorageBuffer:\n            {\n              const buffer = type === ComputeBindingType.UniformBuffer ? object : object;\n              const dataBuffer = buffer.getBuffer();\n              const webgpuBuffer = dataBuffer.underlyingResource;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource.buffer = webgpuBuffer;\n                entries[indexInGroupEntries].resource.size = dataBuffer.capacity;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: {\n                    buffer: webgpuBuffer,\n                    offset: 0,\n                    size: dataBuffer.capacity\n                  }\n                });\n              }\n              break;\n            }\n        }\n      }\n      for (let i = 0; i < this._bindGroupEntries.length; ++i) {\n        const entries = this._bindGroupEntries[i];\n        if (!entries) {\n          this._bindGroups[i] = undefined;\n          continue;\n        }\n        this._bindGroups[i] = this._device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(i),\n          entries\n        });\n      }\n      this._bindGroups.length = this._bindGroupEntries.length;\n    }\n    return this._bindGroups;\n  }\n  constructor(device, cacheSampler) {\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this.uniqueId = WebGPUComputeContext._Counter++;\n    this._bindGroupEntries = [];\n    this.clear();\n  }\n  clear() {\n    this._bindGroups = [];\n    // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\n  }\n}\n\nWebGPUComputeContext._Counter = 0;","map":{"version":3,"names":["Logger","ComputeBindingType","WebGPUConstants","WebGPUComputeContext","getBindGroups","bindings","computePipeline","bindingsMapping","Error","_bindGroups","length","bindGroupEntriesExist","_bindGroupEntries","key","binding","location","group","index","type","object","indexInGroupEntries","entries","Sampler","sampler","undefined","resource","_cacheSampler","getSampler","push","Texture","TextureWithoutSampler","texture","hardwareTexture","_texture","_hardwareTexture","view","StorageTexture","textureAdditionalUsages","TextureUsage","StorageBinding","name","uniqueId","viewForWriting","ExternalTexture","externalTexture","underlyingResource","_device","importExternalTexture","source","UniformBuffer","StorageBuffer","buffer","dataBuffer","getBuffer","webgpuBuffer","size","capacity","offset","i","createBindGroup","layout","getBindGroupLayout","constructor","device","cacheSampler","_Counter","clear"],"sources":["../../../../../dev/core/src/Engines/WebGPU/webgpuComputeContext.ts"],"sourcesContent":["import type { StorageBuffer } from \"../../Buffers/storageBuffer\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"core/Materials/Textures/externalTexture\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputeContext implements IComputeContext {\r\n    private static _Counter = 0;\r\n\r\n    public readonly uniqueId: number;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _bindGroups: GPUBindGroup[];\r\n    private _bindGroupEntries: GPUBindGroupEntry[][];\r\n\r\n    public getBindGroups(bindings: ComputeBindingList, computePipeline: GPUComputePipeline, bindingsMapping?: ComputeBindingMapping): GPUBindGroup[] {\r\n        if (!bindingsMapping) {\r\n            throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\r\n        }\r\n        if (this._bindGroups.length === 0) {\r\n            const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\r\n            for (const key in bindings) {\r\n                const binding = bindings[key],\r\n                    location = bindingsMapping[key],\r\n                    group = location.group,\r\n                    index = location.binding,\r\n                    type = binding.type,\r\n                    object = binding.object;\r\n                let indexInGroupEntries = binding.indexInGroupEntries;\r\n\r\n                let entries = this._bindGroupEntries[group];\r\n                if (!entries) {\r\n                    entries = this._bindGroupEntries[group] = [];\r\n                }\r\n\r\n                switch (type) {\r\n                    case ComputeBindingType.Sampler: {\r\n                        const sampler = object as TextureSampler;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._cacheSampler.getSampler(sampler),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.Texture:\r\n                    case ComputeBindingType.TextureWithoutSampler: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture!);\r\n                            }\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.view!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries.push({\r\n                                    binding: index - 1,\r\n                                    resource: this._cacheSampler.getSampler(texture._texture!),\r\n                                });\r\n                            }\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.view!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.StorageTexture: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\r\n                            Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\r\n                        }\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.viewForWriting!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.ExternalTexture: {\r\n                        const texture = object as ExternalTexture;\r\n                        const externalTexture = texture.underlyingResource;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._device.importExternalTexture({ source: externalTexture }),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.UniformBuffer:\r\n                    case ComputeBindingType.StorageBuffer: {\r\n                        const buffer = type === ComputeBindingType.UniformBuffer ? (object as UniformBuffer) : (object as StorageBuffer);\r\n                        const dataBuffer = buffer.getBuffer()!;\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: {\r\n                                    buffer: webgpuBuffer,\r\n                                    offset: 0,\r\n                                    size: dataBuffer.capacity,\r\n                                },\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this._bindGroupEntries.length; ++i) {\r\n                const entries = this._bindGroupEntries[i];\r\n                if (!entries) {\r\n                    this._bindGroups[i] = undefined as any;\r\n                    continue;\r\n                }\r\n                this._bindGroups[i] = this._device.createBindGroup({\r\n                    layout: computePipeline.getBindGroupLayout(i),\r\n                    entries,\r\n                });\r\n            }\r\n\r\n            this._bindGroups.length = this._bindGroupEntries.length;\r\n        }\r\n\r\n        return this._bindGroups;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this.uniqueId = WebGPUComputeContext._Counter++;\r\n        this._bindGroupEntries = [];\r\n        this.clear();\r\n    }\r\n\r\n    public clear(): void {\r\n        this._bindGroups = [];\r\n        // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}