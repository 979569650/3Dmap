{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport * as WebGPUConstants from \"../webgpuConstants.js\";\nimport { Effect } from \"../../../Materials/effect.js\";\nEffect.prototype.setStorageBuffer = function (name, buffer) {\n  this._engine.setStorageBuffer(name, buffer);\n};\nWebGPUEngine.prototype.createStorageBuffer = function (data, creationFlags, label) {\n  return this._createBuffer(data, creationFlags | 32, label);\n};\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer, data, byteOffset, byteLength) {\n  const dataBuffer = buffer;\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  }\n  let view;\n  if (byteLength === undefined) {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    byteLength = view.byteLength;\n  } else {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n  }\n  this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\n};\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer, offset, size, buffer) {\n  size = size || storageBuffer.capacity;\n  const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst, undefined, \"TempReadFromStorageBuffer\");\n  this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset !== null && offset !== void 0 ? offset : 0, gpuBuffer, 0, size);\n  return new Promise((resolve, reject) => {\n    // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\n    // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\n    this.onEndFrameObservable.addOnce(() => {\n      gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(() => {\n        const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\n        let data = buffer;\n        if (data === undefined) {\n          data = new Uint8Array(size);\n          data.set(new Uint8Array(copyArrayBuffer));\n        } else {\n          const ctor = data.constructor; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\n          data = new ctor(data.buffer);\n          data.set(new ctor(copyArrayBuffer));\n        }\n        gpuBuffer.unmap();\n        this._bufferManager.releaseBuffer(gpuBuffer);\n        resolve(data);\n      }, reason => reject(reason));\n    });\n  });\n};\nWebGPUEngine.prototype.setStorageBuffer = function (name, buffer) {\n  var _a, _b;\n  (_a = this._currentDrawContext) === null || _a === void 0 ? void 0 : _a.setBuffer(name, (_b = buffer === null || buffer === void 0 ? void 0 : buffer.getBuffer()) !== null && _b !== void 0 ? _b : null);\n};","map":{"version":3,"names":["WebGPUEngine","WebGPUConstants","Effect","prototype","setStorageBuffer","name","buffer","_engine","createStorageBuffer","data","creationFlags","label","_createBuffer","updateStorageBuffer","byteOffset","byteLength","dataBuffer","undefined","view","Array","Float32Array","ArrayBuffer","Uint8Array","_bufferManager","setSubData","readFromStorageBuffer","storageBuffer","offset","size","capacity","gpuBuffer","createRawBuffer","BufferUsage","MapRead","CopyDst","_renderTargetEncoder","copyBufferToBuffer","underlyingResource","Promise","resolve","reject","onEndFrameObservable","addOnce","mapAsync","MapMode","Read","then","copyArrayBuffer","getMappedRange","set","ctor","constructor","unmap","releaseBuffer","reason","_a","_currentDrawContext","setBuffer","_b","getBuffer"],"sources":["../../../../../../dev/core/src/Engines/WebGPU/Extensions/engine.storageBuffer.ts"],"sourcesContent":["import type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { DataArray, Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\nimport type { StorageBuffer } from \"../../../Buffers/storageBuffer\";\r\n\r\ndeclare module \"../../../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a storage buffer on the engine to be used in the shader.\r\n         * @param name Name of the storage buffer variable.\r\n         * @param buffer Storage buffer to set.\r\n         * @param label defines the label of the buffer (for debug purpose)\r\n         */\r\n        setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>, label?: string): void;\r\n    }\r\n}\r\n\r\nEffect.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._engine.setStorageBuffer(name, buffer);\r\n};\r\n\r\nWebGPUEngine.prototype.createStorageBuffer = function (data: DataArray | number, creationFlags: number, label?: string): DataBuffer {\r\n    return this._createBuffer(data, creationFlags | Constants.BUFFER_CREATIONFLAG_STORAGE, label);\r\n};\r\n\r\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    const dataBuffer = buffer as WebGPUDataBuffer;\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    let view: ArrayBufferView;\r\n    if (byteLength === undefined) {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n        byteLength = view.byteLength;\r\n    } else {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n};\r\n\r\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView> {\r\n    size = size || storageBuffer.capacity;\r\n\r\n    const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst, undefined, \"TempReadFromStorageBuffer\");\r\n\r\n    this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\r\n\r\n    return new Promise((resolve, reject) => {\r\n        // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\r\n        // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\r\n        this.onEndFrameObservable.addOnce(() => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\r\n                    let data: ArrayBufferView | undefined = buffer;\r\n                    if (data === undefined) {\r\n                        data = new Uint8Array(size!);\r\n                        (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                    } else {\r\n                        const ctor = data.constructor as any; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\r\n                        data = new ctor(data.buffer);\r\n                        (data as any).set(new ctor(copyArrayBuffer));\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    this._bufferManager.releaseBuffer(gpuBuffer);\r\n                    resolve(data!);\r\n                },\r\n                (reason) => reject(reason)\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\nWebGPUEngine.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._currentDrawContext?.setBuffer(name, (buffer?.getBuffer() as WebGPUDataBuffer) ?? null);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}