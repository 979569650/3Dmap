{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { DataBuffer } from \"./dataBuffer.js\";\n/**\n * Class used to store data that will be store in GPU memory\n */\nexport class Buffer {\n  /**\n   * Gets a boolean indicating if the Buffer is disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Constructor\n   * @param engine the engine\n   * @param data the data to use for this buffer\n   * @param updatable whether the data is updatable\n   * @param stride the stride (optional)\n   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n   * @param instanced whether the buffer is instanced (optional)\n   * @param useBytes set to true if the stride in in bytes (optional)\n   * @param divisor sets an optional divisor for instances (1 by default)\n   * @param label defines the label of the buffer (for debug purpose)\n   */\n  constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor, label) {\n    this._isAlreadyOwned = false;\n    this._isDisposed = false;\n    if (engine && engine.getScene) {\n      // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\n      this._engine = engine.getScene().getEngine();\n    } else {\n      this._engine = engine;\n    }\n    this._updatable = updatable;\n    this._instanced = instanced;\n    this._divisor = divisor || 1;\n    this._label = label;\n    if (data instanceof DataBuffer) {\n      this._data = null;\n      this._buffer = data;\n    } else {\n      this._data = data;\n      this._buffer = null;\n    }\n    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\n    if (!postponeInternalCreation) {\n      // by default\n      this.create();\n    }\n  }\n  /**\n   * Create a new VertexBuffer based on the current buffer\n   * @param kind defines the vertex buffer kind (position, normal, etc.)\n   * @param offset defines offset in the buffer (0 by default)\n   * @param size defines the size in floats of attributes (position is 3 for instance)\n   * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\n   * @param instanced defines if the vertex buffer contains indexed data\n   * @param useBytes defines if the offset and stride are in bytes     *\n   * @param divisor sets an optional divisor for instances (1 by default)\n   * @returns the new vertex buffer\n   */\n  createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {\n    const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\n    const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;\n    // a lot of these parameters are ignored as they are overridden by the buffer\n    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === undefined ? this._instanced : instanced, byteOffset, size, undefined, undefined, true, this._divisor || divisor);\n  }\n  // Properties\n  /**\n   * Gets a boolean indicating if the Buffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n  isUpdatable() {\n    return this._updatable;\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n  getData() {\n    return this._data;\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n  getBuffer() {\n    return this._buffer;\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n  getStrideSize() {\n    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\n  }\n  // Methods\n  /**\n   * Store data into the buffer. Creates the buffer if not used already.\n   * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\n   * @param data defines the data to store\n   */\n  create(data = null) {\n    if (!data && this._buffer) {\n      return; // nothing to do\n    }\n\n    data = data || this._data;\n    if (!data) {\n      return;\n    }\n    if (!this._buffer) {\n      // create buffer\n      if (this._updatable) {\n        this._buffer = this._engine.createDynamicVertexBuffer(data, this._label);\n        this._data = data;\n      } else {\n        this._buffer = this._engine.createVertexBuffer(data, undefined, this._label);\n      }\n    } else if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data);\n      this._data = data;\n    }\n  }\n  /** @internal */\n  _rebuild() {\n    this._buffer = null;\n    this.create(this._data);\n  }\n  /**\n   * Update current buffer data\n   * @param data defines the data to store\n   */\n  update(data) {\n    this.create(data);\n  }\n  /**\n   * Updates the data directly.\n   * @param data the new data\n   * @param offset the new offset\n   * @param vertexCount the vertex count (optional)\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateDirectly(data, offset, vertexCount, useBytes = false) {\n    if (!this._buffer) {\n      return;\n    }\n    if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : undefined);\n      if (offset === 0 && vertexCount === undefined) {\n        // Keep the data if we easily can\n        this._data = data;\n      } else {\n        this._data = null;\n      }\n    }\n  }\n  /** @internal */\n  _increaseReferences() {\n    if (!this._buffer) {\n      return;\n    }\n    if (!this._isAlreadyOwned) {\n      this._isAlreadyOwned = true;\n      return;\n    }\n    this._buffer.references++;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    if (!this._buffer) {\n      return;\n    }\n    // The data buffer has an internal counter as this buffer can be used by several VertexBuffer objects\n    // This means that we only flag it as disposed when all references are released (when _releaseBuffer will return true)\n    if (this._engine._releaseBuffer(this._buffer)) {\n      this._isDisposed = true;\n      this._data = null;\n      this._buffer = null;\n    }\n  }\n}\n/**\n * Specialized buffer used to store vertex data\n */\nexport class VertexBuffer {\n  /**\n   * Gets a boolean indicating if the Buffer is disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Gets or sets the instance divisor when in instanced mode\n   */\n  get instanceDivisor() {\n    return this._instanceDivisor;\n  }\n  set instanceDivisor(value) {\n    const isInstanced = value != 0;\n    this._instanceDivisor = value;\n    if (isInstanced !== this._instanced) {\n      this._instanced = isInstanced;\n      this._computeHashCode();\n    }\n  }\n  /**\n   * Gets the number of vertices in the buffer\n   */\n  get totalVertices() {\n    const data = this.getData();\n    if (!data) {\n      return 0;\n    }\n    if (Array.isArray(data)) {\n      // data is a regular number[] with float values\n      return data.length / (this.byteStride / 4) - this.byteOffset / 4;\n    }\n    return (data.byteLength - this.byteOffset) / this.byteStride;\n  }\n  /** @internal */\n  constructor(engine, data, kind, updatableOrOptions, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {\n    var _a, _b, _c, _d, _e;\n    /** @internal */\n    this._isDisposed = false;\n    let updatable = false;\n    this.engine = engine;\n    if (typeof updatableOrOptions === \"object\" && updatableOrOptions !== null) {\n      updatable = (_a = updatableOrOptions.updatable) !== null && _a !== void 0 ? _a : false;\n      postponeInternalCreation = updatableOrOptions.postponeInternalCreation;\n      stride = updatableOrOptions.stride;\n      instanced = updatableOrOptions.instanced;\n      offset = updatableOrOptions.offset;\n      size = updatableOrOptions.size;\n      type = updatableOrOptions.type;\n      normalized = (_b = updatableOrOptions.normalized) !== null && _b !== void 0 ? _b : false;\n      useBytes = (_c = updatableOrOptions.useBytes) !== null && _c !== void 0 ? _c : false;\n      divisor = (_d = updatableOrOptions.divisor) !== null && _d !== void 0 ? _d : 1;\n      takeBufferOwnership = (_e = updatableOrOptions.takeBufferOwnership) !== null && _e !== void 0 ? _e : false;\n      this._label = updatableOrOptions.label;\n    } else {\n      updatable = !!updatableOrOptions;\n    }\n    if (data instanceof Buffer) {\n      this._buffer = data;\n      this._ownsBuffer = takeBufferOwnership;\n    } else {\n      this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor, this._label);\n      this._ownsBuffer = true;\n    }\n    this.uniqueId = VertexBuffer._Counter++;\n    this._kind = kind;\n    if (type === undefined) {\n      const vertexData = this.getData();\n      this.type = vertexData ? VertexBuffer.GetDataType(vertexData) : VertexBuffer.FLOAT;\n    } else {\n      this.type = type;\n    }\n    const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\n    if (useBytes) {\n      this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\n      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = offset || 0;\n    } else {\n      this._size = size || stride || VertexBuffer.DeduceStride(kind);\n      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = (offset || 0) * typeByteLength;\n    }\n    this.normalized = normalized;\n    this._instanced = instanced !== undefined ? instanced : false;\n    this._instanceDivisor = instanced ? divisor : 0;\n    this._alignBuffer();\n    this._computeHashCode();\n  }\n  _computeHashCode() {\n    // note: cast to any because the property is declared readonly\n    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + ( /* keep 5 bits free */\n    this.byteStride << 12);\n  }\n  /** @internal */\n  _rebuild() {\n    var _a;\n    (_a = this._buffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n  }\n  /**\n   * Returns the kind of the VertexBuffer (string)\n   * @returns a string\n   */\n  getKind() {\n    return this._kind;\n  }\n  // Properties\n  /**\n   * Gets a boolean indicating if the VertexBuffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n  isUpdatable() {\n    return this._buffer.isUpdatable();\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n  getData() {\n    return this._buffer.getData();\n  }\n  /**\n   * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param totalVertices number of vertices in the buffer to take into account\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  getFloatData(totalVertices, forceCopy) {\n    const data = this.getData();\n    if (!data) {\n      return null;\n    }\n    totalVertices = totalVertices !== null && totalVertices !== void 0 ? totalVertices : this.totalVertices;\n    return VertexBuffer.GetFloatData(data, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, totalVertices, forceCopy);\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n  getBuffer() {\n    return this._buffer.getBuffer();\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n  getStrideSize() {\n    return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the offset as a multiple of the type byte length.\n   * @returns the offset in bytes\n   * @deprecated Please use byteOffset instead.\n   */\n  getOffset() {\n    return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the number of components or the byte size per vertex attribute\n   * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\n   * @returns the number of components\n   */\n  getSize(sizeInBytes = false) {\n    return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;\n  }\n  /**\n   * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\n   * @returns true if this buffer is instanced\n   */\n  getIsInstanced() {\n    return this._instanced;\n  }\n  /**\n   * Returns the instancing divisor, zero for non-instanced (integer).\n   * @returns a number\n   */\n  getInstanceDivisor() {\n    return this._instanceDivisor;\n  }\n  // Methods\n  /**\n   * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\n   * @param data defines the data to store\n   */\n  create(data) {\n    this._buffer.create(data);\n    this._alignBuffer();\n  }\n  /**\n   * Updates the underlying buffer according to the passed numeric array or Float32Array.\n   * This function will create a new buffer if the current one is not updatable\n   * @param data defines the data to store\n   */\n  update(data) {\n    this._buffer.update(data);\n    this._alignBuffer();\n  }\n  /**\n   * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\n   * Returns the directly updated WebGLBuffer.\n   * @param data the new data\n   * @param offset the new offset\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateDirectly(data, offset, useBytes = false) {\n    this._buffer.updateDirectly(data, offset, undefined, useBytes);\n    this._alignBuffer();\n  }\n  /**\n   * Disposes the VertexBuffer and the underlying WebGLBuffer.\n   */\n  dispose() {\n    if (this._ownsBuffer) {\n      this._buffer.dispose();\n    }\n    this._isDisposed = true;\n  }\n  /**\n   * Enumerates each value of this vertex buffer as numbers.\n   * @param count the number of values to enumerate\n   * @param callback the callback function called for each value\n   */\n  forEach(count, callback) {\n    VertexBuffer.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\n  }\n  /** @internal */\n  _alignBuffer() {}\n  /**\n   * Deduces the stride given a kind.\n   * @param kind The kind string to deduce\n   * @returns The deduced stride\n   */\n  static DeduceStride(kind) {\n    switch (kind) {\n      case VertexBuffer.UVKind:\n      case VertexBuffer.UV2Kind:\n      case VertexBuffer.UV3Kind:\n      case VertexBuffer.UV4Kind:\n      case VertexBuffer.UV5Kind:\n      case VertexBuffer.UV6Kind:\n        return 2;\n      case VertexBuffer.NormalKind:\n      case VertexBuffer.PositionKind:\n        return 3;\n      case VertexBuffer.ColorKind:\n      case VertexBuffer.ColorInstanceKind:\n      case VertexBuffer.MatricesIndicesKind:\n      case VertexBuffer.MatricesIndicesExtraKind:\n      case VertexBuffer.MatricesWeightsKind:\n      case VertexBuffer.MatricesWeightsExtraKind:\n      case VertexBuffer.TangentKind:\n        return 4;\n      default:\n        throw new Error(\"Invalid kind '\" + kind + \"'\");\n    }\n  }\n  /**\n   * Gets the vertex buffer type of the given data array.\n   * @param data the data array\n   * @returns the vertex buffer type\n   */\n  static GetDataType(data) {\n    if (data instanceof Int8Array) {\n      return VertexBuffer.BYTE;\n    } else if (data instanceof Uint8Array) {\n      return VertexBuffer.UNSIGNED_BYTE;\n    } else if (data instanceof Int16Array) {\n      return VertexBuffer.SHORT;\n    } else if (data instanceof Uint16Array) {\n      return VertexBuffer.UNSIGNED_SHORT;\n    } else if (data instanceof Int32Array) {\n      return VertexBuffer.INT;\n    } else if (data instanceof Uint32Array) {\n      return VertexBuffer.UNSIGNED_INT;\n    } else {\n      return VertexBuffer.FLOAT;\n    }\n  }\n  /**\n   * Gets the byte length of the given type.\n   * @param type the type\n   * @returns the number of bytes\n   */\n  static GetTypeByteLength(type) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n      case VertexBuffer.UNSIGNED_BYTE:\n        return 1;\n      case VertexBuffer.SHORT:\n      case VertexBuffer.UNSIGNED_SHORT:\n        return 2;\n      case VertexBuffer.INT:\n      case VertexBuffer.UNSIGNED_INT:\n      case VertexBuffer.FLOAT:\n        return 4;\n      default:\n        throw new Error(`Invalid type '${type}'`);\n    }\n  }\n  /**\n   * Enumerates each value of the given parameters as numbers.\n   * @param data the data to enumerate\n   * @param byteOffset the byte offset of the data\n   * @param byteStride the byte stride of the data\n   * @param componentCount the number of components per element\n   * @param componentType the type of the component\n   * @param count the number of values to enumerate\n   * @param normalized whether the data is normalized\n   * @param callback the callback function called for each value\n   */\n  static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {\n    if (data instanceof Array) {\n      let offset = byteOffset / 4;\n      const stride = byteStride / 4;\n      for (let index = 0; index < count; index += componentCount) {\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          callback(data[offset + componentIndex], index + componentIndex);\n        }\n        offset += stride;\n      }\n    } else {\n      const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\n      const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\n      for (let index = 0; index < count; index += componentCount) {\n        let componentByteOffset = byteOffset;\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\n          callback(value, index + componentIndex);\n          componentByteOffset += componentByteLength;\n        }\n        byteOffset += byteStride;\n      }\n    }\n  }\n  static _GetFloatValue(dataView, type, byteOffset, normalized) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n        {\n          let value = dataView.getInt8(byteOffset);\n          if (normalized) {\n            value = Math.max(value / 127, -1);\n          }\n          return value;\n        }\n      case VertexBuffer.UNSIGNED_BYTE:\n        {\n          let value = dataView.getUint8(byteOffset);\n          if (normalized) {\n            value = value / 255;\n          }\n          return value;\n        }\n      case VertexBuffer.SHORT:\n        {\n          let value = dataView.getInt16(byteOffset, true);\n          if (normalized) {\n            value = Math.max(value / 32767, -1);\n          }\n          return value;\n        }\n      case VertexBuffer.UNSIGNED_SHORT:\n        {\n          let value = dataView.getUint16(byteOffset, true);\n          if (normalized) {\n            value = value / 65535;\n          }\n          return value;\n        }\n      case VertexBuffer.INT:\n        {\n          return dataView.getInt32(byteOffset, true);\n        }\n      case VertexBuffer.UNSIGNED_INT:\n        {\n          return dataView.getUint32(byteOffset, true);\n        }\n      case VertexBuffer.FLOAT:\n        {\n          return dataView.getFloat32(byteOffset, true);\n        }\n      default:\n        {\n          throw new Error(`Invalid component type ${type}`);\n        }\n    }\n  }\n  /**\n   * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\n   * @param data the input data array\n   * @param size the number of components\n   * @param type the component type\n   * @param byteOffset the byte offset of the data\n   * @param byteStride the byte stride of the data\n   * @param normalized whether the data is normalized\n   * @param totalVertices number of vertices in the buffer to take into account\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  static GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {\n    const tightlyPackedByteStride = size * VertexBuffer.GetTypeByteLength(type);\n    const count = totalVertices * size;\n    if (type !== VertexBuffer.FLOAT || byteStride !== tightlyPackedByteStride) {\n      const copy = new Float32Array(count);\n      VertexBuffer.ForEach(data, byteOffset, byteStride, size, type, count, normalized, (value, index) => copy[index] = value);\n      return copy;\n    }\n    if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {\n      if (data instanceof Array) {\n        const offset = byteOffset / 4;\n        return data.slice(offset, offset + count);\n      } else if (data instanceof ArrayBuffer) {\n        return new Float32Array(data, byteOffset, count);\n      } else {\n        let offset = data.byteOffset + byteOffset;\n        if (forceCopy) {\n          const result = new Float32Array(count);\n          const source = new Float32Array(data.buffer, offset, count);\n          result.set(source);\n          return result;\n        }\n        // Protect against bad data\n        const remainder = offset % 4;\n        if (remainder) {\n          offset = Math.max(0, offset - remainder);\n        }\n        return new Float32Array(data.buffer, offset, count);\n      }\n    }\n    if (forceCopy) {\n      return data.slice();\n    }\n    return data;\n  }\n}\nVertexBuffer._Counter = 0;\n/**\n * The byte type.\n */\nVertexBuffer.BYTE = 5120;\n/**\n * The unsigned byte type.\n */\nVertexBuffer.UNSIGNED_BYTE = 5121;\n/**\n * The short type.\n */\nVertexBuffer.SHORT = 5122;\n/**\n * The unsigned short type.\n */\nVertexBuffer.UNSIGNED_SHORT = 5123;\n/**\n * The integer type.\n */\nVertexBuffer.INT = 5124;\n/**\n * The unsigned integer type.\n */\nVertexBuffer.UNSIGNED_INT = 5125;\n/**\n * The float type.\n */\nVertexBuffer.FLOAT = 5126;\n// Enums\n/**\n * Positions\n */\nVertexBuffer.PositionKind = \"position\";\n/**\n * Normals\n */\nVertexBuffer.NormalKind = \"normal\";\n/**\n * Tangents\n */\nVertexBuffer.TangentKind = \"tangent\";\n/**\n * Texture coordinates\n */\nVertexBuffer.UVKind = \"uv\";\n/**\n * Texture coordinates 2\n */\nVertexBuffer.UV2Kind = \"uv2\";\n/**\n * Texture coordinates 3\n */\nVertexBuffer.UV3Kind = \"uv3\";\n/**\n * Texture coordinates 4\n */\nVertexBuffer.UV4Kind = \"uv4\";\n/**\n * Texture coordinates 5\n */\nVertexBuffer.UV5Kind = \"uv5\";\n/**\n * Texture coordinates 6\n */\nVertexBuffer.UV6Kind = \"uv6\";\n/**\n * Colors\n */\nVertexBuffer.ColorKind = \"color\";\n/**\n * Instance Colors\n */\nVertexBuffer.ColorInstanceKind = \"instanceColor\";\n/**\n * Matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesKind = \"matricesIndices\";\n/**\n * Matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsKind = \"matricesWeights\";\n/**\n * Additional matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesExtraKind = \"matricesIndicesExtra\";\n/**\n * Additional matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsExtraKind = \"matricesWeightsExtra\";","map":{"version":3,"names":["DataBuffer","Buffer","isDisposed","_isDisposed","constructor","engine","data","updatable","stride","postponeInternalCreation","instanced","useBytes","divisor","label","_isAlreadyOwned","getScene","_engine","getEngine","_updatable","_instanced","_divisor","_label","_data","_buffer","byteStride","Float32Array","BYTES_PER_ELEMENT","create","createVertexBuffer","kind","offset","size","byteOffset","VertexBuffer","undefined","isUpdatable","getData","getBuffer","getStrideSize","createDynamicVertexBuffer","updateDynamicVertexBuffer","_rebuild","update","updateDirectly","vertexCount","_increaseReferences","references","dispose","_releaseBuffer","instanceDivisor","_instanceDivisor","value","isInstanced","_computeHashCode","totalVertices","Array","isArray","length","byteLength","updatableOrOptions","type","normalized","takeBufferOwnership","_a","_b","_c","_d","_e","_ownsBuffer","uniqueId","_Counter","_kind","vertexData","GetDataType","FLOAT","typeByteLength","GetTypeByteLength","_size","DeduceStride","_alignBuffer","hashCode","getKind","getFloatData","forceCopy","GetFloatData","getOffset","getSize","sizeInBytes","getIsInstanced","getInstanceDivisor","forEach","count","callback","ForEach","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","NormalKind","PositionKind","ColorKind","ColorInstanceKind","MatricesIndicesKind","MatricesIndicesExtraKind","MatricesWeightsKind","MatricesWeightsExtraKind","TangentKind","Error","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","INT","Uint32Array","UNSIGNED_INT","componentCount","componentType","index","componentIndex","dataView","ArrayBuffer","DataView","buffer","componentByteLength","componentByteOffset","_GetFloatValue","getInt8","Math","max","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","tightlyPackedByteStride","copy","slice","result","source","set","remainder"],"sources":["../../../../dev/core/src/Buffers/buffer.ts"],"sourcesContent":["import type { Nullable, DataArray, FloatArray } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { DataBuffer } from \"./dataBuffer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\n\r\n/**\r\n * Class used to store data that will be store in GPU memory\r\n */\r\nexport class Buffer {\r\n    private _engine: ThinEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    /** @internal */\r\n    public _data: Nullable<DataArray>;\r\n    private _updatable: boolean;\r\n    private _instanced: boolean;\r\n    private _divisor: number;\r\n    private _isAlreadyOwned = false;\r\n    private _isDisposed = false;\r\n    private _label?: string;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this buffer\r\n     * @param updatable whether the data is updatable\r\n     * @param stride the stride (optional)\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param useBytes set to true if the stride in in bytes (optional)\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     */\r\n    constructor(\r\n        engine: ThinEngine,\r\n        data: DataArray | DataBuffer,\r\n        updatable: boolean,\r\n        stride = 0,\r\n        postponeInternalCreation = false,\r\n        instanced = false,\r\n        useBytes = false,\r\n        divisor?: number,\r\n        label?: string\r\n    ) {\r\n        if (engine && (engine as unknown as Mesh).getScene) {\r\n            // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\r\n            this._engine = (engine as unknown as Mesh).getScene().getEngine();\r\n        } else {\r\n            this._engine = engine;\r\n        }\r\n\r\n        this._updatable = updatable;\r\n        this._instanced = instanced;\r\n        this._divisor = divisor || 1;\r\n        this._label = label;\r\n\r\n        if (data instanceof DataBuffer) {\r\n            this._data = null;\r\n            this._buffer = data;\r\n        } else {\r\n            this._data = data;\r\n            this._buffer = null;\r\n        }\r\n\r\n        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n        if (!postponeInternalCreation) {\r\n            // by default\r\n            this.create();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new VertexBuffer based on the current buffer\r\n     * @param kind defines the vertex buffer kind (position, normal, etc.)\r\n     * @param offset defines offset in the buffer (0 by default)\r\n     * @param size defines the size in floats of attributes (position is 3 for instance)\r\n     * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\r\n     * @param instanced defines if the vertex buffer contains indexed data\r\n     * @param useBytes defines if the offset and stride are in bytes     *\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @returns the new vertex buffer\r\n     */\r\n    public createVertexBuffer(kind: string, offset: number, size: number, stride?: number, instanced?: boolean, useBytes = false, divisor?: number): VertexBuffer {\r\n        const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\r\n        const byteStride = stride ? (useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT) : this.byteStride;\r\n\r\n        // a lot of these parameters are ignored as they are overridden by the buffer\r\n        return new VertexBuffer(\r\n            this._engine,\r\n            this,\r\n            kind,\r\n            this._updatable,\r\n            true,\r\n            byteStride,\r\n            instanced === undefined ? this._instanced : instanced,\r\n            byteOffset,\r\n            size,\r\n            undefined,\r\n            undefined,\r\n            true,\r\n            this._divisor || divisor\r\n        );\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._updatable;\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. Creates the buffer if not used already.\r\n     * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data: Nullable<DataArray> = null): void {\r\n        if (!data && this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        data = data || this._data;\r\n\r\n        if (!data) {\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            // create buffer\r\n            if (this._updatable) {\r\n                this._buffer = this._engine.createDynamicVertexBuffer(data, this._label);\r\n                this._data = data;\r\n            } else {\r\n                this._buffer = this._engine.createVertexBuffer(data, undefined, this._label);\r\n            }\r\n        } else if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(this._buffer, data);\r\n            this._data = data;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._buffer = null;\r\n        this.create(this._data);\r\n    }\r\n\r\n    /**\r\n     * Update current buffer data\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this.create(data);\r\n    }\r\n\r\n    /**\r\n     * Updates the data directly.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param vertexCount the vertex count (optional)\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, vertexCount?: number, useBytes: boolean = false): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(\r\n                this._buffer,\r\n                data,\r\n                useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT,\r\n                vertexCount ? vertexCount * this.byteStride : undefined\r\n            );\r\n            if (offset === 0 && vertexCount === undefined) {\r\n                // Keep the data if we easily can\r\n                this._data = data;\r\n            } else {\r\n                this._data = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _increaseReferences() {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._isAlreadyOwned) {\r\n            this._isAlreadyOwned = true;\r\n            return;\r\n        }\r\n\r\n        this._buffer.references++;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        // The data buffer has an internal counter as this buffer can be used by several VertexBuffer objects\r\n        // This means that we only flag it as disposed when all references are released (when _releaseBuffer will return true)\r\n        if (this._engine._releaseBuffer(this._buffer)) {\r\n            this._isDisposed = true;\r\n            this._data = null;\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Options to be used when creating a vertex buffer\r\n */\r\nexport interface IVertexBufferOptions {\r\n    /**\r\n     * whether the data is updatable (default: false)\r\n     */\r\n    updatable?: boolean;\r\n    /**\r\n     * whether to postpone creating the internal WebGL buffer (default: false)\r\n     */\r\n    postponeInternalCreation?: boolean;\r\n    /**\r\n     * the stride (will be automatically computed from the kind parameter if not specified)\r\n     */\r\n    stride?: number;\r\n    /**\r\n     * whether the buffer is instanced (default: false)\r\n     */\r\n    instanced?: boolean;\r\n    /**\r\n     * the offset of the data (default: 0)\r\n     */\r\n    offset?: number;\r\n    /**\r\n     * the number of components (will be automatically computed from the kind parameter if not specified)\r\n     */\r\n    size?: number;\r\n    /**\r\n     * the type of the component (will be deduce from the data parameter if not specified)\r\n     */\r\n    type?: number;\r\n    /**\r\n     * whether the data contains normalized data (default: false)\r\n     */\r\n    normalized?: boolean;\r\n    /**\r\n     * set to true if stride and offset are in bytes (default: false)\r\n     */\r\n    useBytes?: boolean;\r\n    /**\r\n     * defines the instance divisor to use (default: 1, only used if instanced is true)\r\n     */\r\n    divisor?: number;\r\n    /**\r\n     * defines if the buffer should be released when the vertex buffer is disposed (default: false)\r\n     */\r\n    takeBufferOwnership?: boolean;\r\n    /**\r\n     * label to use for this vertex buffer (debugging purpose)\r\n     */\r\n    label?: string;\r\n}\r\n\r\n/**\r\n * Specialized buffer used to store vertex data\r\n */\r\nexport class VertexBuffer {\r\n    private static _Counter = 0;\r\n\r\n    /** @internal */\r\n    public _buffer: Buffer;\r\n    /** @internal */\r\n    public _validOffsetRange: boolean; // used internally by the engine\r\n    private _kind: string;\r\n    private _size: number;\r\n    /** @internal */\r\n    public _ownsBuffer: boolean;\r\n    private _instanced: boolean;\r\n    private _instanceDivisor: number;\r\n    /** @internal */\r\n    public _isDisposed = false;\r\n    /** @internal */\r\n    public _label?: string;\r\n\r\n    /**\r\n     * The byte type.\r\n     */\r\n    public static readonly BYTE = 5120;\r\n\r\n    /**\r\n     * The unsigned byte type.\r\n     */\r\n    public static readonly UNSIGNED_BYTE = 5121;\r\n\r\n    /**\r\n     * The short type.\r\n     */\r\n    public static readonly SHORT = 5122;\r\n\r\n    /**\r\n     * The unsigned short type.\r\n     */\r\n    public static readonly UNSIGNED_SHORT = 5123;\r\n\r\n    /**\r\n     * The integer type.\r\n     */\r\n    public static readonly INT = 5124;\r\n\r\n    /**\r\n     * The unsigned integer type.\r\n     */\r\n    public static readonly UNSIGNED_INT = 5125;\r\n\r\n    /**\r\n     * The float type.\r\n     */\r\n    public static readonly FLOAT = 5126;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the instance divisor when in instanced mode\r\n     */\r\n    public get instanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    public set instanceDivisor(value: number) {\r\n        const isInstanced = value != 0;\r\n        this._instanceDivisor = value;\r\n\r\n        if (isInstanced !== this._instanced) {\r\n            this._instanced = isInstanced;\r\n            this._computeHashCode();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Gets the byte offset.\r\n     */\r\n    public readonly byteOffset: number;\r\n\r\n    /**\r\n     * Gets whether integer data values should be normalized into a certain range when being casted to a float.\r\n     */\r\n    public readonly normalized: boolean;\r\n\r\n    /**\r\n     * Gets the data type of each component in the array.\r\n     */\r\n    public readonly type: number;\r\n\r\n    /**\r\n     * Gets the unique id of this vertex buffer\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Gets a hash code representing the format (type, normalized, size, instanced, stride) of this buffer\r\n     * All buffers with the same format will have the same hash code\r\n     */\r\n    public readonly hashCode: number;\r\n\r\n    /**\r\n     * Gets the engine associated with the buffer\r\n     */\r\n    public readonly engine: ThinEngine;\r\n\r\n    /**\r\n     * Gets the number of vertices in the buffer\r\n     */\r\n    public get totalVertices() {\r\n        const data = this.getData();\r\n        if (!data) {\r\n            return 0;\r\n        }\r\n\r\n        if (Array.isArray(data)) {\r\n            // data is a regular number[] with float values\r\n            return data.length / (this.byteStride / 4) - this.byteOffset / 4;\r\n        }\r\n\r\n        return (data.byteLength - this.byteOffset) / this.byteStride;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param updatable whether the data is updatable\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param stride the stride (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param offset the offset of the data (optional)\r\n     * @param size the number of components (optional)\r\n     * @param type the type of the component (optional)\r\n     * @param normalized whether the data contains normalized data (optional)\r\n     * @param useBytes set to true if stride and offset are in bytes (optional)\r\n     * @param divisor defines the instance divisor to use (1 by default)\r\n     * @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed\r\n     */\r\n    constructor(\r\n        engine: ThinEngine,\r\n        data: DataArray | Buffer | DataBuffer,\r\n        kind: string,\r\n        updatable: boolean,\r\n        postponeInternalCreation?: boolean,\r\n        stride?: number,\r\n        instanced?: boolean,\r\n        offset?: number,\r\n        size?: number,\r\n        type?: number,\r\n        normalized?: boolean,\r\n        useBytes?: boolean,\r\n        divisor?: number,\r\n        takeBufferOwnership?: boolean\r\n    );\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param options defines the rest of the options used to create the buffer\r\n     */\r\n    constructor(engine: ThinEngine, data: DataArray | Buffer | DataBuffer, kind: string, options?: IVertexBufferOptions);\r\n\r\n    /** @internal */\r\n    constructor(\r\n        engine: ThinEngine,\r\n        data: DataArray | Buffer | DataBuffer,\r\n        kind: string,\r\n        updatableOrOptions?: boolean | IVertexBufferOptions,\r\n        postponeInternalCreation?: boolean,\r\n        stride?: number,\r\n        instanced?: boolean,\r\n        offset?: number,\r\n        size?: number,\r\n        type?: number,\r\n        normalized = false,\r\n        useBytes = false,\r\n        divisor = 1,\r\n        takeBufferOwnership = false\r\n    ) {\r\n        let updatable = false;\r\n\r\n        this.engine = engine;\r\n\r\n        if (typeof updatableOrOptions === \"object\" && updatableOrOptions !== null) {\r\n            updatable = updatableOrOptions.updatable ?? false;\r\n            postponeInternalCreation = updatableOrOptions.postponeInternalCreation;\r\n            stride = updatableOrOptions.stride;\r\n            instanced = updatableOrOptions.instanced;\r\n            offset = updatableOrOptions.offset;\r\n            size = updatableOrOptions.size;\r\n            type = updatableOrOptions.type;\r\n            normalized = updatableOrOptions.normalized ?? false;\r\n            useBytes = updatableOrOptions.useBytes ?? false;\r\n            divisor = updatableOrOptions.divisor ?? 1;\r\n            takeBufferOwnership = updatableOrOptions.takeBufferOwnership ?? false;\r\n            this._label = updatableOrOptions.label;\r\n        } else {\r\n            updatable = !!updatableOrOptions;\r\n        }\r\n\r\n        if (data instanceof Buffer) {\r\n            this._buffer = data;\r\n            this._ownsBuffer = takeBufferOwnership;\r\n        } else {\r\n            this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor, this._label);\r\n            this._ownsBuffer = true;\r\n        }\r\n\r\n        this.uniqueId = VertexBuffer._Counter++;\r\n        this._kind = kind;\r\n\r\n        if (type === undefined) {\r\n            const vertexData = this.getData();\r\n            this.type = vertexData ? VertexBuffer.GetDataType(vertexData) : VertexBuffer.FLOAT;\r\n        } else {\r\n            this.type = type;\r\n        }\r\n\r\n        const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\r\n\r\n        if (useBytes) {\r\n            this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\r\n            this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = offset || 0;\r\n        } else {\r\n            this._size = size || stride || VertexBuffer.DeduceStride(kind);\r\n            this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = (offset || 0) * typeByteLength;\r\n        }\r\n\r\n        this.normalized = normalized;\r\n\r\n        this._instanced = instanced !== undefined ? instanced : false;\r\n        this._instanceDivisor = instanced ? divisor : 0;\r\n\r\n        this._alignBuffer();\r\n        this._computeHashCode();\r\n    }\r\n\r\n    private _computeHashCode(): void {\r\n        // note: cast to any because the property is declared readonly\r\n        (this.hashCode as any) =\r\n            ((this.type - 5120) << 0) +\r\n            ((this.normalized ? 1 : 0) << 3) +\r\n            (this._size << 4) +\r\n            ((this._instanced ? 1 : 0) << 6) +\r\n            /* keep 5 bits free */\r\n            (this.byteStride << 12);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._buffer?._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Returns the kind of the VertexBuffer (string)\r\n     * @returns a string\r\n     */\r\n    public getKind(): string {\r\n        return this._kind;\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the VertexBuffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._buffer.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._buffer.getData();\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param totalVertices number of vertices in the buffer to take into account\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getFloatData(totalVertices?: number, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const data = this.getData();\r\n        if (!data) {\r\n            return null;\r\n        }\r\n\r\n        totalVertices = totalVertices ?? this.totalVertices;\r\n\r\n        return VertexBuffer.GetFloatData(data, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, totalVertices, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer.getBuffer();\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset as a multiple of the type byte length.\r\n     * @returns the offset in bytes\r\n     * @deprecated Please use byteOffset instead.\r\n     */\r\n    public getOffset(): number {\r\n        return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of components or the byte size per vertex attribute\r\n     * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\r\n     * @returns the number of components\r\n     */\r\n    public getSize(sizeInBytes = false): number {\r\n        return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\r\n     * @returns true if this buffer is instanced\r\n     */\r\n    public getIsInstanced(): boolean {\r\n        return this._instanced;\r\n    }\r\n\r\n    /**\r\n     * Returns the instancing divisor, zero for non-instanced (integer).\r\n     * @returns a number\r\n     */\r\n    public getInstanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data?: DataArray): void {\r\n        this._buffer.create(data);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Updates the underlying buffer according to the passed numeric array or Float32Array.\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this._buffer.update(data);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\r\n     * Returns the directly updated WebGLBuffer.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        this._buffer.updateDirectly(data, offset, undefined, useBytes);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Disposes the VertexBuffer and the underlying WebGLBuffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._ownsBuffer) {\r\n            this._buffer.dispose();\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of this vertex buffer as numbers.\r\n     * @param count the number of values to enumerate\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public forEach(count: number, callback: (value: number, index: number) => void): void {\r\n        VertexBuffer.ForEach(this._buffer.getData()!, this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\r\n    }\r\n\r\n    /** @internal */\r\n    public _alignBuffer() {}\r\n\r\n    // Enums\r\n    /**\r\n     * Positions\r\n     */\r\n    public static readonly PositionKind = \"position\";\r\n    /**\r\n     * Normals\r\n     */\r\n    public static readonly NormalKind = \"normal\";\r\n    /**\r\n     * Tangents\r\n     */\r\n    public static readonly TangentKind = \"tangent\";\r\n    /**\r\n     * Texture coordinates\r\n     */\r\n    public static readonly UVKind = \"uv\";\r\n    /**\r\n     * Texture coordinates 2\r\n     */\r\n    public static readonly UV2Kind = \"uv2\";\r\n    /**\r\n     * Texture coordinates 3\r\n     */\r\n    public static readonly UV3Kind = \"uv3\";\r\n    /**\r\n     * Texture coordinates 4\r\n     */\r\n    public static readonly UV4Kind = \"uv4\";\r\n    /**\r\n     * Texture coordinates 5\r\n     */\r\n    public static readonly UV5Kind = \"uv5\";\r\n    /**\r\n     * Texture coordinates 6\r\n     */\r\n    public static readonly UV6Kind = \"uv6\";\r\n    /**\r\n     * Colors\r\n     */\r\n    public static readonly ColorKind = \"color\";\r\n    /**\r\n     * Instance Colors\r\n     */\r\n    public static readonly ColorInstanceKind = \"instanceColor\";\r\n    /**\r\n     * Matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesKind = \"matricesIndices\";\r\n    /**\r\n     * Matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsKind = \"matricesWeights\";\r\n    /**\r\n     * Additional matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesExtraKind = \"matricesIndicesExtra\";\r\n    /**\r\n     * Additional matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsExtraKind = \"matricesWeightsExtra\";\r\n\r\n    /**\r\n     * Deduces the stride given a kind.\r\n     * @param kind The kind string to deduce\r\n     * @returns The deduced stride\r\n     */\r\n    public static DeduceStride(kind: string): number {\r\n        switch (kind) {\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind:\r\n            case VertexBuffer.UV3Kind:\r\n            case VertexBuffer.UV4Kind:\r\n            case VertexBuffer.UV5Kind:\r\n            case VertexBuffer.UV6Kind:\r\n                return 2;\r\n            case VertexBuffer.NormalKind:\r\n            case VertexBuffer.PositionKind:\r\n                return 3;\r\n            case VertexBuffer.ColorKind:\r\n            case VertexBuffer.ColorInstanceKind:\r\n            case VertexBuffer.MatricesIndicesKind:\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n            case VertexBuffer.MatricesWeightsKind:\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n            case VertexBuffer.TangentKind:\r\n                return 4;\r\n            default:\r\n                throw new Error(\"Invalid kind '\" + kind + \"'\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffer type of the given data array.\r\n     * @param data the data array\r\n     * @returns the vertex buffer type\r\n     */\r\n    public static GetDataType(data: DataArray): number {\r\n        if (data instanceof Int8Array) {\r\n            return VertexBuffer.BYTE;\r\n        } else if (data instanceof Uint8Array) {\r\n            return VertexBuffer.UNSIGNED_BYTE;\r\n        } else if (data instanceof Int16Array) {\r\n            return VertexBuffer.SHORT;\r\n        } else if (data instanceof Uint16Array) {\r\n            return VertexBuffer.UNSIGNED_SHORT;\r\n        } else if (data instanceof Int32Array) {\r\n            return VertexBuffer.INT;\r\n        } else if (data instanceof Uint32Array) {\r\n            return VertexBuffer.UNSIGNED_INT;\r\n        } else {\r\n            return VertexBuffer.FLOAT;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte length of the given type.\r\n     * @param type the type\r\n     * @returns the number of bytes\r\n     */\r\n    public static GetTypeByteLength(type: number): number {\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                return 1;\r\n            case VertexBuffer.SHORT:\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                return 2;\r\n            case VertexBuffer.INT:\r\n            case VertexBuffer.UNSIGNED_INT:\r\n            case VertexBuffer.FLOAT:\r\n                return 4;\r\n            default:\r\n                throw new Error(`Invalid type '${type}'`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of the given parameters as numbers.\r\n     * @param data the data to enumerate\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param componentCount the number of components per element\r\n     * @param componentType the type of the component\r\n     * @param count the number of values to enumerate\r\n     * @param normalized whether the data is normalized\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public static ForEach(\r\n        data: DataArray,\r\n        byteOffset: number,\r\n        byteStride: number,\r\n        componentCount: number,\r\n        componentType: number,\r\n        count: number,\r\n        normalized: boolean,\r\n        callback: (value: number, index: number) => void\r\n    ): void {\r\n        if (data instanceof Array) {\r\n            let offset = byteOffset / 4;\r\n            const stride = byteStride / 4;\r\n            for (let index = 0; index < count; index += componentCount) {\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    callback(data[offset + componentIndex], index + componentIndex);\r\n                }\r\n                offset += stride;\r\n            }\r\n        } else {\r\n            const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n            const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\r\n            for (let index = 0; index < count; index += componentCount) {\r\n                let componentByteOffset = byteOffset;\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\r\n                    callback(value, index + componentIndex);\r\n                    componentByteOffset += componentByteLength;\r\n                }\r\n                byteOffset += byteStride;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean): number {\r\n        switch (type) {\r\n            case VertexBuffer.BYTE: {\r\n                let value = dataView.getInt8(byteOffset);\r\n                if (normalized) {\r\n                    value = Math.max(value / 127, -1);\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.UNSIGNED_BYTE: {\r\n                let value = dataView.getUint8(byteOffset);\r\n                if (normalized) {\r\n                    value = value / 255;\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.SHORT: {\r\n                let value = dataView.getInt16(byteOffset, true);\r\n                if (normalized) {\r\n                    value = Math.max(value / 32767, -1);\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.UNSIGNED_SHORT: {\r\n                let value = dataView.getUint16(byteOffset, true);\r\n                if (normalized) {\r\n                    value = value / 65535;\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.INT: {\r\n                return dataView.getInt32(byteOffset, true);\r\n            }\r\n            case VertexBuffer.UNSIGNED_INT: {\r\n                return dataView.getUint32(byteOffset, true);\r\n            }\r\n            case VertexBuffer.FLOAT: {\r\n                return dataView.getFloat32(byteOffset, true);\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid component type ${type}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\r\n     * @param data the input data array\r\n     * @param size the number of components\r\n     * @param type the component type\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param normalized whether the data is normalized\r\n     * @param totalVertices number of vertices in the buffer to take into account\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public static GetFloatData(\r\n        data: DataArray,\r\n        size: number,\r\n        type: number,\r\n        byteOffset: number,\r\n        byteStride: number,\r\n        normalized: boolean,\r\n        totalVertices: number,\r\n        forceCopy?: boolean\r\n    ): FloatArray {\r\n        const tightlyPackedByteStride = size * VertexBuffer.GetTypeByteLength(type);\r\n        const count = totalVertices * size;\r\n\r\n        if (type !== VertexBuffer.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n            const copy = new Float32Array(count);\r\n            VertexBuffer.ForEach(data, byteOffset, byteStride, size, type, count, normalized, (value, index) => (copy[index] = value));\r\n            return copy;\r\n        }\r\n\r\n        if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {\r\n            if (data instanceof Array) {\r\n                const offset = byteOffset / 4;\r\n                return data.slice(offset, offset + count);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                return new Float32Array(data, byteOffset, count);\r\n            } else {\r\n                let offset = data.byteOffset + byteOffset;\r\n                if (forceCopy) {\r\n                    const result = new Float32Array(count);\r\n                    const source = new Float32Array(data.buffer, offset, count);\r\n\r\n                    result.set(source);\r\n\r\n                    return result;\r\n                }\r\n\r\n                // Protect against bad data\r\n                const remainder = offset % 4;\r\n\r\n                if (remainder) {\r\n                    offset = Math.max(0, offset - remainder);\r\n                }\r\n\r\n                return new Float32Array(data.buffer, offset, count);\r\n            }\r\n        }\r\n\r\n        if (forceCopy) {\r\n            return data.slice();\r\n        }\r\n\r\n        return data;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}