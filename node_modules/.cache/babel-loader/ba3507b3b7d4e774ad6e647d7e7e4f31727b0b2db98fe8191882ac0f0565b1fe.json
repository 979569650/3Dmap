{"ast":null,"code":"import { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Options for the controller physics feature\n */\nexport class IWebXRControllerPhysicsOptions {}\n/**\n * Add physics impostor to your webxr controllers,\n * including naive calculation of their linear and angular velocity\n */\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\n  _createPhysicsImpostor(xrController) {\n    const impostorType = this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;\n    const impostorSize = this._options.physicsProperties.impostorSize || 0.1;\n    const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\n      diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n      diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n      diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n    });\n    impostorMesh.isVisible = this._debugMode;\n    impostorMesh.isPickable = false;\n    impostorMesh.rotationQuaternion = new Quaternion();\n    const controllerMesh = xrController.grip || xrController.pointer;\n    impostorMesh.position.copyFrom(controllerMesh.position);\n    impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n    const impostor = new PhysicsImpostor(impostorMesh, impostorType, Object.assign({\n      mass: 0\n    }, this._options.physicsProperties));\n    this._controllers[xrController.uniqueId] = {\n      xrController,\n      impostor,\n      impostorMesh\n    };\n  }\n  /**\n   * Construct a new Controller Physics Feature\n   * @param _xrSessionManager the corresponding xr session manager\n   * @param _options options to create this feature with\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\n        Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\n      }\n      // if no motion controller available, create impostors!\n      if (this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {\n        xrController.onMotionControllerInitObservable.addOnce(motionController => {\n          if (!motionController._doNotLoadControllerMesh) {\n            motionController.onModelLoadedObservable.addOnce(() => {\n              const impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, Object.assign({\n                mass: 0\n              }, this._options.physicsProperties));\n              const controllerMesh = xrController.grip || xrController.pointer;\n              this._controllers[xrController.uniqueId] = {\n                xrController,\n                impostor,\n                oldPos: controllerMesh.position.clone(),\n                oldRotation: controllerMesh.rotationQuaternion.clone()\n              };\n            });\n          } else {\n            // This controller isn't using a model, create impostors instead\n            this._createPhysicsImpostor(xrController);\n          }\n        });\n      } else {\n        this._createPhysicsImpostor(xrController);\n      }\n    };\n    this._controllers = {};\n    this._debugMode = false;\n    this._delta = 0;\n    this._lastTimestamp = 0;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVector = new Vector3();\n    if (!this._options.physicsProperties) {\n      this._options.physicsProperties = {};\n    }\n  }\n  /**\n   * @internal\n   * enable debugging - will show console outputs and the impostor mesh\n   */\n  _enablePhysicsDebug() {\n    this._debugMode = true;\n    Object.keys(this._controllers).forEach(controllerId => {\n      const controllerData = this._controllers[controllerId];\n      if (controllerData.impostorMesh) {\n        controllerData.impostorMesh.isVisible = true;\n      }\n    });\n  }\n  /**\n   * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\n   * @param xrController the controller to add\n   */\n  addController(xrController) {\n    this._attachController(xrController);\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    if (!this._options.xrInput) {\n      return true;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    if (this._options.enableHeadsetImpostor) {\n      const params = this._options.headsetImpostorParams || {\n        impostorType: PhysicsImpostor.SphereImpostor,\n        restitution: 0.8,\n        impostorSize: 0.3\n      };\n      const impostorSize = params.impostorSize || 0.3;\n      this._headsetMesh = CreateSphere(\"headset-mesh\", {\n        diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n        diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n        diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n      });\n      this._headsetMesh.rotationQuaternion = new Quaternion();\n      this._headsetMesh.isVisible = false;\n      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, Object.assign({\n        mass: 0\n      }, params));\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    if (this._headsetMesh) {\n      this._headsetMesh.dispose();\n    }\n    return true;\n  }\n  /**\n   * Get the headset impostor, if enabled\n   * @returns the impostor\n   */\n  getHeadsetImpostor() {\n    return this._headsetImpostor;\n  }\n  /**\n   * Get the physics impostor of a specific controller.\n   * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\n   * @param controller the controller or the controller id of which to get the impostor\n   * @returns the impostor or null\n   */\n  getImpostorForController(controller) {\n    const id = typeof controller === \"string\" ? controller : controller.uniqueId;\n    if (this._controllers[id]) {\n      return this._controllers[id].impostor;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Update the physics properties provided in the constructor\n   * @param newProperties the new properties object\n   * @param newProperties.impostorType\n   * @param newProperties.impostorSize\n   * @param newProperties.friction\n   * @param newProperties.restitution\n   */\n  setPhysicsProperties(newProperties) {\n    this._options.physicsProperties = Object.assign(Object.assign({}, this._options.physicsProperties), newProperties);\n  }\n  _onXRFrame(_xrFrame) {\n    var _a, _b;\n    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\n    this._lastTimestamp = this._xrSessionManager.currentTimestamp;\n    if (this._headsetMesh && this._headsetImpostor) {\n      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\n      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\n      if ((_a = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n        const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\n        this._tmpVector.set(lv.x, lv.y, lv.z);\n        this._headsetImpostor.setLinearVelocity(this._tmpVector);\n      }\n      if ((_b = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n        const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\n        this._tmpVector.set(av.x, av.y, av.z);\n        this._headsetImpostor.setAngularVelocity(this._tmpVector);\n      }\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      var _a, _b;\n      const controllerData = this._controllers[controllerId];\n      const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\n      const comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;\n      if ((_a = controllerData.xrController._lastXRPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n        const lv = controllerData.xrController._lastXRPose.linearVelocity;\n        this._tmpVector.set(lv.x, lv.y, lv.z);\n        controllerData.impostor.setLinearVelocity(this._tmpVector);\n      } else {\n        controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\n        this._tmpVector.scaleInPlace(1000 / this._delta);\n        controllerData.impostor.setLinearVelocity(this._tmpVector);\n      }\n      comparedPosition.copyFrom(controllerMesh.position);\n      if (this._debugMode) {\n        console.log(this._tmpVector, \"linear\");\n      }\n      const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;\n      if ((_b = controllerData.xrController._lastXRPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n        const av = controllerData.xrController._lastXRPose.angularVelocity;\n        this._tmpVector.set(av.x, av.y, av.z);\n        controllerData.impostor.setAngularVelocity(this._tmpVector);\n      } else {\n        if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {\n          // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\n          comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, this._tmpQuaternion);\n          const len = Math.sqrt(this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z);\n          this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\n          // define a better epsilon\n          if (len < 0.001) {\n            this._tmpVector.scaleInPlace(2);\n          } else {\n            const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\n            this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\n          }\n          controllerData.impostor.setAngularVelocity(this._tmpVector);\n        }\n      }\n      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n      if (this._debugMode) {\n        console.log(this._tmpVector, this._tmpQuaternion, \"angular\");\n      }\n    });\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.impostorMesh) {\n      controllerData.impostorMesh.dispose();\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n}\n/**\n * The module's name\n */\nWebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerPhysics.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerPhysics(xrSessionManager, options);\n}, WebXRControllerPhysics.Version, true);","map":{"version":3,"names":["WebXRAbstractFeature","Vector3","Quaternion","PhysicsImpostor","CreateSphere","WebXRFeatureName","WebXRFeaturesManager","Logger","IWebXRControllerPhysicsOptions","WebXRControllerPhysics","_createPhysicsImpostor","xrController","impostorType","_options","physicsProperties","SphereImpostor","impostorSize","impostorMesh","uniqueId","diameterX","width","diameterY","height","diameterZ","depth","isVisible","_debugMode","isPickable","rotationQuaternion","controllerMesh","grip","pointer","position","copyFrom","impostor","Object","assign","mass","_controllers","constructor","_xrSessionManager","_attachController","scene","isPhysicsEnabled","Warn","useControllerMesh","inputSource","gamepad","onMotionControllerInitObservable","addOnce","motionController","_doNotLoadControllerMesh","onModelLoadedObservable","rootMesh","MeshImpostor","oldPos","clone","oldRotation","_delta","_lastTimestamp","_tmpQuaternion","_tmpVector","_enablePhysicsDebug","keys","forEach","controllerId","controllerData","addController","attach","xrInput","controllers","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","enableHeadsetImpostor","params","headsetImpostorParams","restitution","_headsetMesh","_headsetImpostor","detach","dispose","getHeadsetImpostor","getImpostorForController","id","setPhysicsProperties","newProperties","_onXRFrame","_xrFrame","currentTimestamp","xrCamera","globalPosition","absoluteRotation","_a","_lastXRViewerPose","linearVelocity","lv","set","x","y","z","setLinearVelocity","_b","angularVelocity","av","setAngularVelocity","comparedPosition","_lastXRPose","subtractToRef","scaleInPlace","console","log","comparedQuaternion","equalsWithEpsilon","conjugateInPlace","multiplyToRef","len","Math","sqrt","angle","atan2","w","xrControllerUniqueId","Name","PHYSICS_CONTROLLERS","Version","AddWebXRFeature","xrSessionManager","options"],"sources":["../../../../../dev/core/src/XR/features/WebXRControllerPhysics.ts"],"sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options for the controller physics feature\r\n */\r\nexport class IWebXRControllerPhysicsOptions {\r\n    /**\r\n     * Should the headset get its own impostor\r\n     */\r\n    enableHeadsetImpostor?: boolean;\r\n    /**\r\n     * Optional parameters for the headset impostor\r\n     */\r\n    headsetImpostorParams?: {\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * The physics properties of the future impostors\r\n     */\r\n    physicsProperties?: {\r\n        /**\r\n         * If set to true, a mesh impostor will be created when the controller mesh was loaded\r\n         * Note that this requires a physics engine that supports mesh impostors!\r\n         */\r\n        useControllerMesh?: boolean;\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType?: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    public xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Add physics impostor to your webxr controllers,\r\n * including naive calculation of their linear and angular velocity\r\n */\r\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\r\n            Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\r\n        }\r\n        // if no motion controller available, create impostors!\r\n        if (this._options.physicsProperties!.useControllerMesh && xrController.inputSource.gamepad) {\r\n            xrController.onMotionControllerInitObservable.addOnce((motionController) => {\r\n                if (!motionController._doNotLoadControllerMesh) {\r\n                    motionController.onModelLoadedObservable.addOnce(() => {\r\n                        const impostor = new PhysicsImpostor(motionController.rootMesh!, PhysicsImpostor.MeshImpostor, {\r\n                            mass: 0,\r\n                            ...this._options.physicsProperties,\r\n                        });\r\n\r\n                        const controllerMesh = xrController.grip || xrController.pointer;\r\n                        this._controllers[xrController.uniqueId] = {\r\n                            xrController,\r\n                            impostor,\r\n                            oldPos: controllerMesh.position.clone(),\r\n                            oldRotation: controllerMesh.rotationQuaternion!.clone(),\r\n                        };\r\n                    });\r\n                } else {\r\n                    // This controller isn't using a model, create impostors instead\r\n                    this._createPhysicsImpostor(xrController);\r\n                }\r\n            });\r\n        } else {\r\n            this._createPhysicsImpostor(xrController);\r\n        }\r\n    };\r\n\r\n    private _createPhysicsImpostor(xrController: WebXRInputSource) {\r\n        const impostorType: number = this._options.physicsProperties!.impostorType || PhysicsImpostor.SphereImpostor;\r\n        const impostorSize: number | { width: number; height: number; depth: number } = this._options.physicsProperties!.impostorSize || 0.1;\r\n        const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\r\n            diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n            diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n            diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n        });\r\n        impostorMesh.isVisible = this._debugMode;\r\n        impostorMesh.isPickable = false;\r\n        impostorMesh.rotationQuaternion = new Quaternion();\r\n        const controllerMesh = xrController.grip || xrController.pointer;\r\n        impostorMesh.position.copyFrom(controllerMesh.position);\r\n        impostorMesh.rotationQuaternion!.copyFrom(controllerMesh.rotationQuaternion!);\r\n        const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\r\n            mass: 0,\r\n            ...this._options.physicsProperties,\r\n        });\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            impostor,\r\n            impostorMesh,\r\n        };\r\n    }\r\n\r\n    private _controllers: {\r\n        [id: string]: {\r\n            xrController: WebXRInputSource;\r\n            impostorMesh?: AbstractMesh;\r\n            impostor: PhysicsImpostor;\r\n            oldPos?: Vector3;\r\n            oldSpeed?: Vector3;\r\n            oldRotation?: Quaternion;\r\n        };\r\n    } = {};\r\n    private _debugMode = false;\r\n    private _delta: number = 0;\r\n    private _headsetImpostor?: PhysicsImpostor;\r\n    private _headsetMesh?: AbstractMesh;\r\n    private _lastTimestamp: number = 0;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVector: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Construct a new Controller Physics Feature\r\n     * @param _xrSessionManager the corresponding xr session manager\r\n     * @param _options options to create this feature with\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPhysicsOptions) {\r\n        super(_xrSessionManager);\r\n        if (!this._options.physicsProperties) {\r\n            this._options.physicsProperties = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * enable debugging - will show console outputs and the impostor mesh\r\n     */\r\n    public _enablePhysicsDebug() {\r\n        this._debugMode = true;\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            if (controllerData.impostorMesh) {\r\n                controllerData.impostorMesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\r\n     * @param xrController the controller to add\r\n     */\r\n    public addController(xrController: WebXRInputSource) {\r\n        this._attachController(xrController);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.xrInput) {\r\n            return true;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        if (this._options.enableHeadsetImpostor) {\r\n            const params = this._options.headsetImpostorParams || {\r\n                impostorType: PhysicsImpostor.SphereImpostor,\r\n                restitution: 0.8,\r\n                impostorSize: 0.3,\r\n            };\r\n            const impostorSize = params.impostorSize || 0.3;\r\n            this._headsetMesh = CreateSphere(\"headset-mesh\", {\r\n                diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n                diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n                diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n            });\r\n            this._headsetMesh.rotationQuaternion = new Quaternion();\r\n            this._headsetMesh.isVisible = false;\r\n            this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, { mass: 0, ...params });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        if (this._headsetMesh) {\r\n            this._headsetMesh.dispose();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the headset impostor, if enabled\r\n     * @returns the impostor\r\n     */\r\n    public getHeadsetImpostor() {\r\n        return this._headsetImpostor;\r\n    }\r\n\r\n    /**\r\n     * Get the physics impostor of a specific controller.\r\n     * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\r\n     * @param controller the controller or the controller id of which to get the impostor\r\n     * @returns the impostor or null\r\n     */\r\n    public getImpostorForController(controller: WebXRInputSource | string): Nullable<PhysicsImpostor> {\r\n        const id = typeof controller === \"string\" ? controller : controller.uniqueId;\r\n        if (this._controllers[id]) {\r\n            return this._controllers[id].impostor;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the physics properties provided in the constructor\r\n     * @param newProperties the new properties object\r\n     * @param newProperties.impostorType\r\n     * @param newProperties.impostorSize\r\n     * @param newProperties.friction\r\n     * @param newProperties.restitution\r\n     */\r\n    public setPhysicsProperties(newProperties: {\r\n        impostorType?: number;\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        friction?: number;\r\n        restitution?: number;\r\n    }) {\r\n        this._options.physicsProperties = {\r\n            ...this._options.physicsProperties,\r\n            ...newProperties,\r\n        };\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: any): void {\r\n        this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\r\n        this._lastTimestamp = this._xrSessionManager.currentTimestamp;\r\n        if (this._headsetMesh && this._headsetImpostor) {\r\n            this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\r\n            this._headsetMesh.rotationQuaternion!.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.linearVelocity) {\r\n                const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                this._headsetImpostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.angularVelocity) {\r\n                const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                this._headsetImpostor.setAngularVelocity(this._tmpVector);\r\n            }\r\n        }\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\r\n            const comparedPosition = controllerData.oldPos || controllerData.impostorMesh!.position;\r\n            if (controllerData.xrController._lastXRPose?.linearVelocity) {\r\n                const lv = controllerData.xrController._lastXRPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            } else {\r\n                controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(1000 / this._delta);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            comparedPosition.copyFrom(controllerMesh.position);\r\n            if (this._debugMode) {\r\n                console.log(this._tmpVector, \"linear\");\r\n            }\r\n\r\n            const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh!.rotationQuaternion!;\r\n            if (controllerData.xrController._lastXRPose?.angularVelocity) {\r\n                const av = controllerData.xrController._lastXRPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n            } else {\r\n                if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion!)) {\r\n                    // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\r\n                    comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion!, this._tmpQuaternion);\r\n                    const len = Math.sqrt(\r\n                        this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z\r\n                    );\r\n                    this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\r\n                    // define a better epsilon\r\n                    if (len < 0.001) {\r\n                        this._tmpVector.scaleInPlace(2);\r\n                    } else {\r\n                        const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\r\n                        this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\r\n                    }\r\n                    controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n                }\r\n            }\r\n            comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion!);\r\n            if (this._debugMode) {\r\n                console.log(this._tmpVector, this._tmpQuaternion, \"angular\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.impostorMesh) {\r\n            controllerData.impostorMesh.dispose();\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPhysics.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPhysics(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPhysics.Version,\r\n    true\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}