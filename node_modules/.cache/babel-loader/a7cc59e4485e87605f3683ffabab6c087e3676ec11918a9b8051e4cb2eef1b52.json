{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nAbstractScene.prototype.removeReflectionProbe = function (toRemove) {\n  if (!this.reflectionProbes) {\n    return -1;\n  }\n  const index = this.reflectionProbes.indexOf(toRemove);\n  if (index !== -1) {\n    this.reflectionProbes.splice(index, 1);\n  }\n  return index;\n};\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {\n  if (!this.reflectionProbes) {\n    this.reflectionProbes = [];\n  }\n  this.reflectionProbes.push(newReflectionProbe);\n};\n/**\n * Class used to generate realtime reflection / refraction cube textures\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\n */\nexport class ReflectionProbe {\n  /**\n   * Creates a new reflection probe\n   * @param name defines the name of the probe\n   * @param size defines the texture resolution (for each face)\n   * @param scene defines the hosting scene\n   * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\n   * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\n   * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\n   */\n  constructor( /** defines the name of the probe */\n  name, size, scene, generateMipMaps = true, useFloat = false, linearSpace = false) {\n    this.name = name;\n    this._viewMatrix = Matrix.Identity();\n    this._target = Vector3.Zero();\n    this._add = Vector3.Zero();\n    this._invertYAxis = false;\n    /** Gets or sets probe position (center of the cube map) */\n    this.position = Vector3.Zero();\n    /**\n     * Gets or sets an object used to store user defined information for the reflection probe.\n     */\n    this.metadata = null;\n    /** @internal */\n    this._parentContainer = null;\n    this._scene = scene;\n    if (scene.getEngine().supportsUniformBuffers) {\n      this._sceneUBOs = [];\n      for (let i = 0; i < 6; ++i) {\n        this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name \"${name}\") face #${i}`));\n      }\n    }\n    // Create the scene field if not exist.\n    if (!this._scene.reflectionProbes) {\n      this._scene.reflectionProbes = new Array();\n    }\n    this._scene.reflectionProbes.push(this);\n    let textureType = 0;\n    if (useFloat) {\n      const caps = this._scene.getEngine().getCaps();\n      if (caps.textureHalfFloatRender) {\n        textureType = 2;\n      } else if (caps.textureFloatRender) {\n        textureType = 1;\n      }\n    }\n    this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\n    this._renderTargetTexture.gammaSpace = !linearSpace;\n    this._renderTargetTexture.invertZ = scene.useRightHandedSystem;\n    const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n    this._renderTargetTexture.onBeforeRenderObservable.add(faceIndex => {\n      if (this._sceneUBOs) {\n        scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);\n        scene.getSceneUniformBuffer().unbindEffect();\n      }\n      switch (faceIndex) {\n        case 0:\n          this._add.copyFromFloats(1, 0, 0);\n          break;\n        case 1:\n          this._add.copyFromFloats(-1, 0, 0);\n          break;\n        case 2:\n          this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\n          break;\n        case 3:\n          this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\n          break;\n        case 4:\n          this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\n          break;\n        case 5:\n          this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\n          break;\n      }\n      if (this._attachedMesh) {\n        this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\n      }\n      this.position.addToRef(this._add, this._target);\n      const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\n      const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\n      lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);\n      if (scene.activeCamera) {\n        this._projectionMatrix = perspectiveFunction(Math.PI / 2, 1, useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ, useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ, this._scene.getEngine().isNDCHalfZRange);\n        scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\n        if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {\n          this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\n        }\n      }\n      scene._forcedViewPosition = this.position;\n    });\n    let currentApplyByPostProcess;\n    this._renderTargetTexture.onBeforeBindObservable.add(() => {\n      var _a, _b;\n      this._currentSceneUBO = scene.getSceneUniformBuffer();\n      (_b = (_a = scene.getEngine())._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `reflection probe generation for ${name}`, 1);\n      currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\n      if (linearSpace) {\n        scene.imageProcessingConfiguration.applyByPostProcess = true;\n      }\n    });\n    this._renderTargetTexture.onAfterUnbindObservable.add(() => {\n      var _a, _b;\n      scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\n      scene._forcedViewPosition = null;\n      if (this._sceneUBOs) {\n        scene.setSceneUniformBuffer(this._currentSceneUBO);\n      }\n      scene.updateTransformMatrix(true);\n      (_b = (_a = scene.getEngine())._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(_a, 1);\n    });\n  }\n  /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\n  get samples() {\n    return this._renderTargetTexture.samples;\n  }\n  set samples(value) {\n    this._renderTargetTexture.samples = value;\n  }\n  /** Gets or sets the refresh rate to use (on every frame by default) */\n  get refreshRate() {\n    return this._renderTargetTexture.refreshRate;\n  }\n  set refreshRate(value) {\n    this._renderTargetTexture.refreshRate = value;\n  }\n  /**\n   * Gets the hosting scene\n   * @returns a Scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /** Gets the internal CubeTexture used to render to */\n  get cubeTexture() {\n    return this._renderTargetTexture;\n  }\n  /** Gets or sets the list of meshes to render */\n  get renderList() {\n    return this._renderTargetTexture.renderList;\n  }\n  set renderList(value) {\n    this._renderTargetTexture.renderList = value;\n  }\n  /**\n   * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\n   * @param mesh defines the mesh to attach to\n   */\n  attachToMesh(mesh) {\n    this._attachedMesh = mesh;\n  }\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   */\n  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n    this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n  }\n  /**\n   * Clean all associated resources\n   */\n  dispose() {\n    const index = this._scene.reflectionProbes.indexOf(this);\n    if (index !== -1) {\n      // Remove from the scene if found\n      this._scene.reflectionProbes.splice(index, 1);\n    }\n    if (this._parentContainer) {\n      const index = this._parentContainer.reflectionProbes.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.reflectionProbes.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    if (this._renderTargetTexture) {\n      this._renderTargetTexture.dispose();\n      this._renderTargetTexture = null;\n    }\n    if (this._sceneUBOs) {\n      for (const ubo of this._sceneUBOs) {\n        ubo.dispose();\n      }\n      this._sceneUBOs = [];\n    }\n  }\n  /**\n   * Converts the reflection probe information to a readable string for debug purpose.\n   * @param fullDetails Supports for multiple levels of logging within scene loading\n   * @returns the human readable reflection probe info\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    if (fullDetails) {\n      ret += \", position: \" + this.position.toString();\n      if (this._attachedMesh) {\n        ret += \", attached mesh: \" + this._attachedMesh.name;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Get the class name of the refection probe.\n   * @returns \"ReflectionProbe\"\n   */\n  getClassName() {\n    return \"ReflectionProbe\";\n  }\n  /**\n   * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\n   * @returns The JSON representation of the texture\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\n    serializationObject.isReflectionProbe = true;\n    serializationObject.metadata = this.metadata;\n    return serializationObject;\n  }\n  /**\n   * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\n   * @param parsedReflectionProbe Define the JSON representation of the reflection probe\n   * @param scene Define the scene the parsed reflection probe should be instantiated in\n   * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\n   * @returns The parsed reflection probe if successful\n   */\n  static Parse(parsedReflectionProbe, scene, rootUrl) {\n    let reflectionProbe = null;\n    if (scene.reflectionProbes) {\n      for (let index = 0; index < scene.reflectionProbes.length; index++) {\n        const rp = scene.reflectionProbes[index];\n        if (rp.name === parsedReflectionProbe.name) {\n          reflectionProbe = rp;\n          break;\n        }\n      }\n    }\n    reflectionProbe = SerializationHelper.Parse(() => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps), parsedReflectionProbe, scene, rootUrl);\n    reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\n    if (parsedReflectionProbe._attachedMesh) {\n      reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\n    }\n    if (parsedReflectionProbe.metadata) {\n      reflectionProbe.metadata = parsedReflectionProbe.metadata;\n    }\n    return reflectionProbe;\n  }\n}\n__decorate([serializeAsMeshReference()], ReflectionProbe.prototype, \"_attachedMesh\", void 0);\n__decorate([serializeAsVector3()], ReflectionProbe.prototype, \"position\", void 0);","map":{"version":3,"names":["serializeAsMeshReference","serializeAsVector3","SerializationHelper","RenderTargetTexture","Matrix","Vector3","AbstractScene","prototype","removeReflectionProbe","toRemove","reflectionProbes","index","indexOf","splice","addReflectionProbe","newReflectionProbe","push","ReflectionProbe","constructor","name","size","scene","generateMipMaps","useFloat","linearSpace","_viewMatrix","Identity","_target","Zero","_add","_invertYAxis","position","metadata","_parentContainer","_scene","getEngine","supportsUniformBuffers","_sceneUBOs","i","createSceneUniformBuffer","Array","textureType","caps","getCaps","textureHalfFloatRender","textureFloatRender","_renderTargetTexture","gammaSpace","invertZ","useRightHandedSystem","useReverseDepthBuffer","onBeforeRenderObservable","add","faceIndex","setSceneUniformBuffer","getSceneUniformBuffer","unbindEffect","copyFromFloats","_attachedMesh","copyFrom","getAbsolutePosition","addToRef","lookAtFunction","LookAtRHToRef","LookAtLHToRef","perspectiveFunction","PerspectiveFovRH","PerspectiveFovLH","Up","activeCamera","_projectionMatrix","Math","PI","maxZ","minZ","isNDCHalfZRange","setTransformMatrix","isRigCamera","rigParent","_forcedViewPosition","currentApplyByPostProcess","onBeforeBindObservable","_currentSceneUBO","_b","_a","_debugPushGroup","call","imageProcessingConfiguration","applyByPostProcess","onAfterUnbindObservable","updateTransformMatrix","_debugPopGroup","samples","value","refreshRate","getScene","cubeTexture","renderList","attachToMesh","mesh","setRenderingAutoClearDepthStencil","renderingGroupId","autoClearDepthStencil","dispose","ubo","toString","fullDetails","ret","getClassName","serialize","serializationObject","Serialize","isReflectionProbe","Parse","parsedReflectionProbe","rootUrl","reflectionProbe","length","rp","renderTargetSize","_generateMipMaps","_waitingRenderList","getMeshById","__decorate"],"sources":["../../../../dev/core/src/Probes/reflectionProbe.ts"],"sourcesContent":["import { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of reflection probes added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\r\n         */\r\n        reflectionProbes: Array<ReflectionProbe>;\r\n\r\n        /**\r\n         * Removes the given reflection probe from this scene.\r\n         * @param toRemove The reflection probe to remove\r\n         * @returns The index of the removed reflection probe\r\n         */\r\n        removeReflectionProbe(toRemove: ReflectionProbe): number;\r\n\r\n        /**\r\n         * Adds the given reflection probe to this scene.\r\n         * @param newReflectionProbe The reflection probe to add\r\n         */\r\n        addReflectionProbe(newReflectionProbe: ReflectionProbe): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeReflectionProbe = function (toRemove: ReflectionProbe): number {\r\n    if (!this.reflectionProbes) {\r\n        return -1;\r\n    }\r\n\r\n    const index = this.reflectionProbes.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.reflectionProbes.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe: ReflectionProbe): void {\r\n    if (!this.reflectionProbes) {\r\n        this.reflectionProbes = [];\r\n    }\r\n\r\n    this.reflectionProbes.push(newReflectionProbe);\r\n};\r\n\r\n/**\r\n * Class used to generate realtime reflection / refraction cube textures\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\r\n */\r\nexport class ReflectionProbe {\r\n    private _scene: Scene;\r\n    private _renderTargetTexture: RenderTargetTexture;\r\n    private _projectionMatrix: Matrix;\r\n    private _viewMatrix = Matrix.Identity();\r\n    private _target = Vector3.Zero();\r\n    private _add = Vector3.Zero();\r\n    @serializeAsMeshReference()\r\n    private _attachedMesh: Nullable<AbstractMesh>;\r\n\r\n    private _invertYAxis = false;\r\n    private _sceneUBOs: UniformBuffer[];\r\n    private _currentSceneUBO: UniformBuffer;\r\n\r\n    /** Gets or sets probe position (center of the cube map) */\r\n    @serializeAsVector3()\r\n    public position = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the reflection probe.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Creates a new reflection probe\r\n     * @param name defines the name of the probe\r\n     * @param size defines the texture resolution (for each face)\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\r\n     * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\r\n     * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\r\n     */\r\n    constructor(\r\n        /** defines the name of the probe */\r\n        public name: string,\r\n        size: number,\r\n        scene: Scene,\r\n        generateMipMaps = true,\r\n        useFloat = false,\r\n        linearSpace = false\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        if (scene.getEngine().supportsUniformBuffers) {\r\n            this._sceneUBOs = [];\r\n            for (let i = 0; i < 6; ++i) {\r\n                this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name \"${name}\") face #${i}`));\r\n            }\r\n        }\r\n\r\n        // Create the scene field if not exist.\r\n        if (!this._scene.reflectionProbes) {\r\n            this._scene.reflectionProbes = new Array<ReflectionProbe>();\r\n        }\r\n        this._scene.reflectionProbes.push(this);\r\n\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (useFloat) {\r\n            const caps = this._scene.getEngine().getCaps();\r\n            if (caps.textureHalfFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        }\r\n        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\r\n        this._renderTargetTexture.gammaSpace = !linearSpace;\r\n        this._renderTargetTexture.invertZ = scene.useRightHandedSystem;\r\n\r\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\r\n\r\n        this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex: number) => {\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);\r\n                scene.getSceneUniformBuffer().unbindEffect();\r\n            }\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    this._add.copyFromFloats(1, 0, 0);\r\n                    break;\r\n                case 1:\r\n                    this._add.copyFromFloats(-1, 0, 0);\r\n                    break;\r\n                case 2:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\r\n                    break;\r\n                case 3:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\r\n                    break;\r\n                case 4:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\r\n                    break;\r\n                case 5:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\r\n                    break;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\r\n            }\r\n\r\n            this.position.addToRef(this._add, this._target);\r\n\r\n            const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\r\n            const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\r\n\r\n            lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);\r\n\r\n            if (scene.activeCamera) {\r\n                this._projectionMatrix = perspectiveFunction(\r\n                    Math.PI / 2,\r\n                    1,\r\n                    useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ,\r\n                    useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ,\r\n                    this._scene.getEngine().isNDCHalfZRange\r\n                );\r\n                scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\r\n                if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {\r\n                    this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\r\n                }\r\n            }\r\n            scene._forcedViewPosition = this.position;\r\n        });\r\n\r\n        let currentApplyByPostProcess: boolean;\r\n\r\n        this._renderTargetTexture.onBeforeBindObservable.add(() => {\r\n            this._currentSceneUBO = scene.getSceneUniformBuffer();\r\n            scene.getEngine()._debugPushGroup?.(`reflection probe generation for ${name}`, 1);\r\n            currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n            if (linearSpace) {\r\n                scene.imageProcessingConfiguration.applyByPostProcess = true;\r\n            }\r\n        });\r\n\r\n        this._renderTargetTexture.onAfterUnbindObservable.add(() => {\r\n            scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\r\n            scene._forcedViewPosition = null;\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._currentSceneUBO);\r\n            }\r\n            scene.updateTransformMatrix(true);\r\n            scene.getEngine()._debugPopGroup?.(1);\r\n        });\r\n    }\r\n\r\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\r\n    public get samples(): number {\r\n        return this._renderTargetTexture.samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        this._renderTargetTexture.samples = value;\r\n    }\r\n\r\n    /** Gets or sets the refresh rate to use (on every frame by default) */\r\n    public get refreshRate(): number {\r\n        return this._renderTargetTexture.refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._renderTargetTexture.refreshRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** Gets the internal CubeTexture used to render to */\r\n    public get cubeTexture(): RenderTargetTexture {\r\n        return this._renderTargetTexture;\r\n    }\r\n\r\n    /** Gets or sets the list of meshes to render */\r\n    public get renderList(): Nullable<AbstractMesh[]> {\r\n        return this._renderTargetTexture.renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<AbstractMesh[]>) {\r\n        this._renderTargetTexture.renderList = value;\r\n    }\r\n\r\n    /**\r\n     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\r\n     * @param mesh defines the mesh to attach to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>): void {\r\n        this._attachedMesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n    }\r\n\r\n    /**\r\n     * Clean all associated resources\r\n     */\r\n    public dispose() {\r\n        const index = this._scene.reflectionProbes.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this._scene.reflectionProbes.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.reflectionProbes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.reflectionProbes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._renderTargetTexture) {\r\n            this._renderTargetTexture.dispose();\r\n            (<any>this._renderTargetTexture) = null;\r\n        }\r\n\r\n        if (this._sceneUBOs) {\r\n            for (const ubo of this._sceneUBOs) {\r\n                ubo.dispose();\r\n            }\r\n            this._sceneUBOs = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the reflection probe information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable reflection probe info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n\r\n        if (fullDetails) {\r\n            ret += \", position: \" + this.position.toString();\r\n\r\n            if (this._attachedMesh) {\r\n                ret += \", attached mesh: \" + this._attachedMesh.name;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the refection probe.\r\n     * @returns \"ReflectionProbe\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ReflectionProbe\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\r\n        serializationObject.isReflectionProbe = true;\r\n        serializationObject.metadata = this.metadata;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\r\n     * @param parsedReflectionProbe Define the JSON representation of the reflection probe\r\n     * @param scene Define the scene the parsed reflection probe should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed reflection probe if successful\r\n     */\r\n    public static Parse(parsedReflectionProbe: any, scene: Scene, rootUrl: string): Nullable<ReflectionProbe> {\r\n        let reflectionProbe: Nullable<ReflectionProbe> = null;\r\n        if (scene.reflectionProbes) {\r\n            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const rp = scene.reflectionProbes[index];\r\n                if (rp.name === parsedReflectionProbe.name) {\r\n                    reflectionProbe = rp;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        reflectionProbe = SerializationHelper.Parse(\r\n            () => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps),\r\n            parsedReflectionProbe,\r\n            scene,\r\n            rootUrl\r\n        );\r\n        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\r\n\r\n        if (parsedReflectionProbe._attachedMesh) {\r\n            reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\r\n        }\r\n\r\n        if (parsedReflectionProbe.metadata) {\r\n            reflectionProbe.metadata = parsedReflectionProbe.metadata;\r\n        }\r\n\r\n        return reflectionProbe;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}