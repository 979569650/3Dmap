{"ast":null,"code":"import { Vector3, Quaternion, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"../Lights/directionalLight.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateHemisphere } from \"../Meshes/Builders/hemisphereBuilder.js\";\nimport { SpotLight } from \"../Lights/spotLight.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\n/**\n * Gizmo that enables viewing a light\n */\nexport class LightGizmo extends Gizmo {\n  /**\n   * Creates a LightGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {\n    super(gizmoLayer);\n    this._cachedPosition = new Vector3();\n    this._cachedForward = new Vector3(0, 0, 1);\n    this._pointerObserver = null;\n    /**\n     * Event that fires each time the gizmo is clicked\n     */\n    this.onClickedObservable = new Observable();\n    this._light = null;\n    this.attachedMesh = new AbstractMesh(\"\", this.gizmoLayer.utilityLayerScene);\n    this._attachedMeshParent = new TransformNode(\"parent\", this.gizmoLayer.utilityLayerScene);\n    this.attachedMesh.parent = this._attachedMeshParent;\n    this._material = new StandardMaterial(\"light\", this.gizmoLayer.utilityLayerScene);\n    this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!this._light) {\n        return;\n      }\n      this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n      if (this._isHovered && pointerInfo.event.button === 0) {\n        this.onClickedObservable.notifyObservers(this._light);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n  }\n  /**\n   * Override attachedNode because lightgizmo only support attached mesh\n   * It will return the attached mesh (if any) and setting an attached node will log\n   * a warning\n   */\n  get attachedNode() {\n    return this.attachedMesh;\n  }\n  set attachedNode(value) {\n    console.warn(\"Nodes cannot be attached to LightGizmo. Attach to a mesh instead.\");\n  }\n  /**\n   * The light that the gizmo is attached to\n   */\n  set light(light) {\n    this._light = light;\n    if (light) {\n      // Create the mesh for the given light type\n      if (this._lightMesh) {\n        this._lightMesh.dispose();\n      }\n      if (light instanceof HemisphericLight) {\n        this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else if (light instanceof DirectionalLight) {\n        this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else if (light instanceof SpotLight) {\n        this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else {\n        this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\n      }\n      this._lightMesh.getChildMeshes(false).forEach(m => {\n        m.material = this._material;\n      });\n      this._lightMesh.parent = this._rootMesh;\n      // Add lighting to the light gizmo\n      const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n      gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\n      this._lightMesh.rotationQuaternion = new Quaternion();\n      if (!this.attachedMesh.reservedDataStore) {\n        this.attachedMesh.reservedDataStore = {};\n      }\n      this.attachedMesh.reservedDataStore.lightGizmo = this;\n      if (light.parent) {\n        this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\n      }\n      // Get update position and direction if the light has it\n      if (light.position) {\n        this.attachedMesh.position.copyFrom(light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n      if (light.direction) {\n        this.attachedMesh.setDirection(light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n        const forward = this._getMeshForward();\n        this._cachedForward.copyFrom(forward);\n      }\n      this._update();\n    }\n  }\n  get light() {\n    return this._light;\n  }\n  /**\n   * Gets the material used to render the light gizmo\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * @internal\n   * returns mesh forward\n   */\n  _getMeshForward() {\n    let forward = this.attachedMesh.forward;\n    if (this.attachedMesh.getScene().useRightHandedSystem) {\n      forward.negateToRef(TmpVectors.Vector3[0]);\n      forward = TmpVectors.Vector3[0];\n    }\n    return forward;\n  }\n  /**\n   * @internal\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    super._update();\n    if (!this._light) {\n      return;\n    }\n    if (this._light.parent) {\n      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\n    }\n    // For light position and direction, a dirty flag is set to true in the setter\n    // It means setting values individually or copying values will not call setter and\n    // dirty flag will not be set to true. Hence creating a new Vector3.\n    if (this._light.position) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (!this.attachedMesh.position.equals(this._cachedPosition)) {\n        // update light to match gizmo\n        const position = this.attachedMesh.position;\n        this._light.position = new Vector3(position.x, position.y, position.z);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      } else {\n        // update gizmo to match light\n        this.attachedMesh.position.copyFrom(this._light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n    }\n    if (this._light.direction) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      const forward = this._getMeshForward();\n      if (Vector3.DistanceSquared(forward, this._cachedForward) > 0.0001) {\n        // update light to match gizmo\n        const direction = forward;\n        this._light.direction = new Vector3(direction.x, direction.y, direction.z);\n        this._cachedForward.copyFrom(forward);\n      } else if (Vector3.DistanceSquared(forward, this._light.direction) > 0.0001) {\n        // update gizmo to match light\n        this.attachedMesh.setDirection(this._light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedForward.copyFrom(forward);\n      }\n    }\n  }\n  /**\n   * Disposes of the light gizmo\n   */\n  dispose() {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this._material.dispose();\n    super.dispose();\n    this._attachedMeshParent.dispose();\n  }\n  static _CreateHemisphericLightMesh(scene) {\n    const root = new Mesh(\"hemisphereLight\", scene);\n    const hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    hemisphere.position.z = -0.15;\n    hemisphere.rotation.x = Math.PI / 2;\n    hemisphere.parent = root;\n    const lines = this._CreateLightLines(3, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreatePointLightMesh(scene) {\n    const root = new Mesh(\"pointLight\", scene);\n    const sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.rotation.x = Math.PI / 2;\n    sphere.parent = root;\n    const lines = this._CreateLightLines(5, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreateSpotLightMesh(scene) {\n    const root = new Mesh(\"spotLight\", scene);\n    const sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.parent = root;\n    const hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 2\n    }, scene);\n    hemisphere.parent = root;\n    hemisphere.rotation.x = -Math.PI / 2;\n    const lines = this._CreateLightLines(2, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreateDirectionalLightMesh(scene) {\n    const root = new Mesh(\"directionalLight\", scene);\n    const mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    const sphere = CreateSphere(root.name, {\n      diameter: 1.2,\n      segments: 10\n    }, scene);\n    sphere.parent = mesh;\n    const line = CreateCylinder(root.name, {\n      updatable: false,\n      height: 6,\n      diameterTop: 0.3,\n      diameterBottom: 0.3,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    line.parent = mesh;\n    let left = line.clone(root.name);\n    left.scaling.y = 0.5;\n    left.position.x += 1.25;\n    let right = line.clone(root.name);\n    right.scaling.y = 0.5;\n    right.position.x += -1.25;\n    const arrowHead = CreateCylinder(root.name, {\n      updatable: false,\n      height: 1,\n      diameterTop: 0,\n      diameterBottom: 0.6,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    arrowHead.position.y += 3;\n    arrowHead.parent = mesh;\n    left = arrowHead.clone(root.name);\n    left.position.y = 1.5;\n    left.position.x += 1.25;\n    right = arrowHead.clone(root.name);\n    right.position.y = 1.5;\n    right.position.x += -1.25;\n    mesh.scaling.scaleInPlace(LightGizmo._Scale);\n    mesh.rotation.z = Math.PI / 2;\n    mesh.rotation.y = Math.PI / 2;\n    return root;\n  }\n}\n// Static helper methods\nLightGizmo._Scale = 0.007;\n/**\n * Creates the lines for a light mesh\n * @param levels\n * @param scene\n */\nLightGizmo._CreateLightLines = (levels, scene) => {\n  const distFromSphere = 1.2;\n  const root = new Mesh(\"root\", scene);\n  root.rotation.x = Math.PI / 2;\n  // Create the top line, this will be cloned for all other lines\n  const linePivot = new Mesh(\"linePivot\", scene);\n  linePivot.parent = root;\n  const line = CreateCylinder(\"line\", {\n    updatable: false,\n    height: 2,\n    diameterTop: 0.2,\n    diameterBottom: 0.3,\n    tessellation: 6,\n    subdivisions: 1\n  }, scene);\n  line.position.y = line.scaling.y / 2 + distFromSphere;\n  line.parent = linePivot;\n  if (levels < 2) {\n    return linePivot;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"lineParentClone\");\n    l.rotation.z = Math.PI / 4;\n    l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n    l.getChildMeshes()[0].scaling.y = 0.5;\n    l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n    l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n  }\n  if (levels < 3) {\n    return root;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI / 2;\n    l.rotation.y = Math.PI / 2 * i;\n  }\n  if (levels < 4) {\n    return root;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI + Math.PI / 4;\n    l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n    l.getChildMeshes()[0].scaling.y = 0.5;\n    l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n    l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n  }\n  if (levels < 5) {\n    return root;\n  }\n  const l = linePivot.clone(\"linePivotClone\");\n  l.rotation.z = Math.PI;\n  return root;\n};","map":{"version":3,"names":["Vector3","Quaternion","TmpVectors","Color3","AbstractMesh","Mesh","Gizmo","UtilityLayerRenderer","StandardMaterial","HemisphericLight","DirectionalLight","CreateSphere","CreateHemisphere","SpotLight","TransformNode","PointerEventTypes","Observable","CreateCylinder","LightGizmo","constructor","gizmoLayer","DefaultUtilityLayer","_cachedPosition","_cachedForward","_pointerObserver","onClickedObservable","_light","attachedMesh","utilityLayerScene","_attachedMeshParent","parent","_material","diffuseColor","specularColor","onPointerObservable","add","pointerInfo","_isHovered","pickInfo","_rootMesh","getChildMeshes","indexOf","pickedMesh","event","button","notifyObservers","POINTERDOWN","attachedNode","value","console","warn","light","_lightMesh","dispose","_CreateHemisphericLightMesh","_CreateDirectionalLightMesh","_CreateSpotLightMesh","_CreatePointLightMesh","forEach","m","material","gizmoLight","_getSharedGizmoLight","includedOnlyMeshes","concat","rotationQuaternion","reservedDataStore","lightGizmo","freezeWorldMatrix","getWorldMatrix","position","copyFrom","computeWorldMatrix","direction","setDirection","forward","_getMeshForward","_update","getScene","useRightHandedSystem","negateToRef","equals","x","y","z","DistanceSquared","clear","remove","scene","root","hemisphere","name","segments","diameter","rotation","Math","PI","lines","_CreateLightLines","scaling","scaleInPlace","_Scale","sphere","mesh","line","updatable","height","diameterTop","diameterBottom","tessellation","subdivisions","left","clone","right","arrowHead","levels","distFromSphere","linePivot","i","l"],"sources":["../../../../dev/core/src/Gizmos/lightGizmo.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { Node } from \"../node\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { Scene } from \"../scene\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"../Lights/directionalLight\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateHemisphere } from \"../Meshes/Builders/hemisphereBuilder\";\r\nimport { SpotLight } from \"../Lights/spotLight\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\n\r\n/**\r\n * Interface for light gizmo\r\n */\r\nexport interface ILightGizmo extends IGizmo {\r\n    /** Event that fires each time the gizmo is clicked */\r\n    onClickedObservable: Observable<Light>;\r\n    /** The light that the gizmo is attached to */\r\n    light: Nullable<Light>;\r\n    /** The material used to render the light gizmo */\r\n    readonly material: StandardMaterial;\r\n}\r\n\r\n/**\r\n * Gizmo that enables viewing a light\r\n */\r\nexport class LightGizmo extends Gizmo implements ILightGizmo {\r\n    protected _lightMesh: Mesh;\r\n    protected _material: StandardMaterial;\r\n    protected _cachedPosition = new Vector3();\r\n    protected _cachedForward = new Vector3(0, 0, 1);\r\n    protected _attachedMeshParent: TransformNode;\r\n    protected _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n\r\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\r\n    public onClickedObservable = new Observable<Light>();\r\n\r\n    /**\r\n     * Creates a LightGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer) {\r\n        super(gizmoLayer);\r\n        this.attachedMesh = new AbstractMesh(\"\", this.gizmoLayer.utilityLayerScene);\r\n        this._attachedMeshParent = new TransformNode(\"parent\", this.gizmoLayer.utilityLayerScene);\r\n\r\n        this.attachedMesh.parent = this._attachedMeshParent;\r\n        this._material = new StandardMaterial(\"light\", this.gizmoLayer.utilityLayerScene);\r\n        this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n        this._material.specularColor = new Color3(0.1, 0.1, 0.1);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this._light) {\r\n                return;\r\n            }\r\n\r\n            this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(<Mesh>pointerInfo.pickInfo.pickedMesh) != -1);\r\n            if (this._isHovered && pointerInfo.event.button === 0) {\r\n                this.onClickedObservable.notifyObservers(this._light);\r\n            }\r\n        }, PointerEventTypes.POINTERDOWN);\r\n    }\r\n    protected _light: Nullable<Light> = null;\r\n\r\n    /**\r\n     * Override attachedNode because lightgizmo only support attached mesh\r\n     * It will return the attached mesh (if any) and setting an attached node will log\r\n     * a warning\r\n     */\r\n    public get attachedNode() {\r\n        return this.attachedMesh;\r\n    }\r\n    public set attachedNode(value: Nullable<Node>) {\r\n        console.warn(\"Nodes cannot be attached to LightGizmo. Attach to a mesh instead.\");\r\n    }\r\n\r\n    /**\r\n     * The light that the gizmo is attached to\r\n     */\r\n    public set light(light: Nullable<Light>) {\r\n        this._light = light;\r\n        if (light) {\r\n            // Create the mesh for the given light type\r\n            if (this._lightMesh) {\r\n                this._lightMesh.dispose();\r\n            }\r\n\r\n            if (light instanceof HemisphericLight) {\r\n                this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof DirectionalLight) {\r\n                this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof SpotLight) {\r\n                this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else {\r\n                this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            }\r\n            this._lightMesh.getChildMeshes(false).forEach((m) => {\r\n                m.material = this._material;\r\n            });\r\n            this._lightMesh.parent = this._rootMesh;\r\n\r\n            // Add lighting to the light gizmo\r\n            const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\r\n            gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\r\n\r\n            this._lightMesh.rotationQuaternion = new Quaternion();\r\n\r\n            if (!this.attachedMesh!.reservedDataStore) {\r\n                this.attachedMesh!.reservedDataStore = {};\r\n            }\r\n            this.attachedMesh!.reservedDataStore.lightGizmo = this;\r\n\r\n            if (light.parent) {\r\n                this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\r\n            }\r\n\r\n            // Get update position and direction if the light has it\r\n            if ((light as any).position) {\r\n                this.attachedMesh!.position.copyFrom((light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n            if ((light as any).direction) {\r\n                this.attachedMesh!.setDirection((light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                const forward = this._getMeshForward();\r\n                this._cachedForward.copyFrom(forward);\r\n            }\r\n\r\n            this._update();\r\n        }\r\n    }\r\n    public get light() {\r\n        return this._light;\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the light gizmo\r\n     */\r\n    public get material() {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * returns mesh forward\r\n     */\r\n    protected _getMeshForward(): Vector3 {\r\n        let forward = this.attachedMesh!.forward;\r\n        if (this.attachedMesh!.getScene().useRightHandedSystem) {\r\n            forward.negateToRef(TmpVectors.Vector3[0]);\r\n            forward = TmpVectors.Vector3[0];\r\n        }\r\n        return forward;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        super._update();\r\n        if (!this._light) {\r\n            return;\r\n        }\r\n\r\n        if (this._light.parent) {\r\n            this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\r\n        }\r\n\r\n        // For light position and direction, a dirty flag is set to true in the setter\r\n        // It means setting values individually or copying values will not call setter and\r\n        // dirty flag will not be set to true. Hence creating a new Vector3.\r\n        if ((this._light as any).position) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            if (!this.attachedMesh!.position.equals(this._cachedPosition)) {\r\n                // update light to match gizmo\r\n                const position = this.attachedMesh!.position;\r\n                (this._light as any).position = new Vector3(position.x, position.y, position.z);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            } else {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.position.copyFrom((this._light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n        }\r\n        if ((this._light as any).direction) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            const forward = this._getMeshForward();\r\n            if (Vector3.DistanceSquared(forward, this._cachedForward) > 0.0001) {\r\n                // update light to match gizmo\r\n                const direction = forward;\r\n                (this._light as any).direction = new Vector3(direction.x, direction.y, direction.z);\r\n                this._cachedForward.copyFrom(forward);\r\n            } else if (Vector3.DistanceSquared(forward, (this._light as any).direction) > 0.0001) {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.setDirection((this._light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedForward.copyFrom(forward);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Static helper methods\r\n    private static _Scale = 0.007;\r\n\r\n    /**\r\n     * Creates the lines for a light mesh\r\n     * @param levels\r\n     * @param scene\r\n     */\r\n    private static _CreateLightLines = (levels: number, scene: Scene) => {\r\n        const distFromSphere = 1.2;\r\n\r\n        const root = new Mesh(\"root\", scene);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        // Create the top line, this will be cloned for all other lines\r\n        const linePivot = new Mesh(\"linePivot\", scene);\r\n        linePivot.parent = root;\r\n        const line = CreateCylinder(\r\n            \"line\",\r\n            {\r\n                updatable: false,\r\n                height: 2,\r\n                diameterTop: 0.2,\r\n                diameterBottom: 0.3,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        line.position.y = line.scaling.y / 2 + distFromSphere;\r\n        line.parent = linePivot;\r\n\r\n        if (levels < 2) {\r\n            return linePivot;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"lineParentClone\")!;\r\n            l.rotation.z = Math.PI / 4;\r\n            l.rotation.y = Math.PI / 2 + (Math.PI / 2) * i;\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 3) {\r\n            return root;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI / 2;\r\n            l.rotation.y = (Math.PI / 2) * i;\r\n        }\r\n\r\n        if (levels < 4) {\r\n            return root;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI + Math.PI / 4;\r\n            l.rotation.y = Math.PI / 2 + (Math.PI / 2) * i;\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 5) {\r\n            return root;\r\n        }\r\n        const l = linePivot.clone(\"linePivotClone\");\r\n        l.rotation.z = Math.PI;\r\n\r\n        return root;\r\n    };\r\n\r\n    /**\r\n     * Disposes of the light gizmo\r\n     */\r\n    public dispose() {\r\n        this.onClickedObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this._material.dispose();\r\n        super.dispose();\r\n        this._attachedMeshParent.dispose();\r\n    }\r\n\r\n    private static _CreateHemisphericLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"hemisphereLight\", scene);\r\n        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        hemisphere.position.z = -0.15;\r\n        hemisphere.rotation.x = Math.PI / 2;\r\n        hemisphere.parent = root;\r\n\r\n        const lines = this._CreateLightLines(3, scene);\r\n        lines.parent = root;\r\n\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreatePointLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"pointLight\", scene);\r\n        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.rotation.x = Math.PI / 2;\r\n        sphere.parent = root;\r\n\r\n        const lines = this._CreateLightLines(5, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateSpotLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"spotLight\", scene);\r\n        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.parent = root;\r\n\r\n        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);\r\n        hemisphere.parent = root;\r\n        hemisphere.rotation.x = -Math.PI / 2;\r\n\r\n        const lines = this._CreateLightLines(2, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateDirectionalLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"directionalLight\", scene);\r\n\r\n        const mesh = new Mesh(root.name, scene);\r\n        mesh.parent = root;\r\n        const sphere = CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);\r\n        sphere.parent = mesh;\r\n\r\n        const line = CreateCylinder(\r\n            root.name,\r\n            {\r\n                updatable: false,\r\n                height: 6,\r\n                diameterTop: 0.3,\r\n                diameterBottom: 0.3,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        line.parent = mesh;\r\n\r\n        let left = line.clone(root.name)!;\r\n        left.scaling.y = 0.5;\r\n        left.position.x += 1.25;\r\n\r\n        let right = line.clone(root.name)!;\r\n        right.scaling.y = 0.5;\r\n        right.position.x += -1.25;\r\n\r\n        const arrowHead = CreateCylinder(\r\n            root.name,\r\n            {\r\n                updatable: false,\r\n                height: 1,\r\n                diameterTop: 0,\r\n                diameterBottom: 0.6,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        arrowHead.position.y += 3;\r\n        arrowHead.parent = mesh;\r\n\r\n        left = arrowHead.clone(root.name);\r\n        left.position.y = 1.5;\r\n        left.position.x += 1.25;\r\n\r\n        right = arrowHead.clone(root.name);\r\n        right.position.y = 1.5;\r\n        right.position.x += -1.25;\r\n\r\n        mesh.scaling.scaleInPlace(LightGizmo._Scale);\r\n        mesh.rotation.z = Math.PI / 2;\r\n        mesh.rotation.y = Math.PI / 2;\r\n        return root;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}