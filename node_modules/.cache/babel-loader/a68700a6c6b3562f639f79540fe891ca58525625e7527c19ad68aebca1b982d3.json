{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport \"../Engines/Extensions/engine.uniformBuffer.js\";\n/**\n * Uniform buffer objects.\n *\n * Handles blocks of uniform on the GPU.\n *\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\n *\n * For more information, please refer to :\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\n */\nexport class UniformBuffer {\n  /**\n   * Instantiates a new Uniform buffer objects.\n   *\n   * Handles blocks of uniform on the GPU.\n   *\n   * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\n   *\n   * For more information, please refer to :\n   * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\n   * @param engine Define the engine the buffer is associated with\n   * @param data Define the data contained in the buffer\n   * @param dynamic Define if the buffer is updatable\n   * @param name to assign to the buffer (debugging purpose)\n   * @param forceNoUniformBuffer define that this object must not rely on UBO objects\n   */\n  constructor(engine, data, dynamic, name, forceNoUniformBuffer = false) {\n    // Matrix cache\n    this._valueCache = {};\n    this._engine = engine;\n    this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\n    this._dynamic = dynamic;\n    this._name = name !== null && name !== void 0 ? name : \"no-name\";\n    this._data = data || [];\n    this._uniformLocations = {};\n    this._uniformSizes = {};\n    this._uniformArraySizes = {};\n    this._uniformLocationPointer = 0;\n    this._needSync = false;\n    if (this._engine._features.trackUbosInFrame) {\n      this._buffers = [];\n      this._bufferIndex = -1;\n      this._createBufferOnWrite = false;\n      this._currentFrameId = 0;\n    }\n    if (this._noUBO) {\n      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\n      this.updateFloat = this._updateFloatForEffect;\n      this.updateFloat2 = this._updateFloat2ForEffect;\n      this.updateFloat3 = this._updateFloat3ForEffect;\n      this.updateFloat4 = this._updateFloat4ForEffect;\n      this.updateFloatArray = this._updateFloatArrayForEffect;\n      this.updateArray = this._updateArrayForEffect;\n      this.updateIntArray = this._updateIntArrayForEffect;\n      this.updateUIntArray = this._updateUIntArrayForEffect;\n      this.updateMatrix = this._updateMatrixForEffect;\n      this.updateMatrices = this._updateMatricesForEffect;\n      this.updateVector3 = this._updateVector3ForEffect;\n      this.updateVector4 = this._updateVector4ForEffect;\n      this.updateColor3 = this._updateColor3ForEffect;\n      this.updateColor4 = this._updateColor4ForEffect;\n      this.updateDirectColor4 = this._updateDirectColor4ForEffect;\n      this.updateInt = this._updateIntForEffect;\n      this.updateInt2 = this._updateInt2ForEffect;\n      this.updateInt3 = this._updateInt3ForEffect;\n      this.updateInt4 = this._updateInt4ForEffect;\n      this.updateUInt = this._updateUIntForEffect;\n      this.updateUInt2 = this._updateUInt2ForEffect;\n      this.updateUInt3 = this._updateUInt3ForEffect;\n      this.updateUInt4 = this._updateUInt4ForEffect;\n    } else {\n      this._engine._uniformBuffers.push(this);\n      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\n      this.updateFloat = this._updateFloatForUniform;\n      this.updateFloat2 = this._updateFloat2ForUniform;\n      this.updateFloat3 = this._updateFloat3ForUniform;\n      this.updateFloat4 = this._updateFloat4ForUniform;\n      this.updateFloatArray = this._updateFloatArrayForUniform;\n      this.updateArray = this._updateArrayForUniform;\n      this.updateIntArray = this._updateIntArrayForUniform;\n      this.updateUIntArray = this._updateUIntArrayForUniform;\n      this.updateMatrix = this._updateMatrixForUniform;\n      this.updateMatrices = this._updateMatricesForUniform;\n      this.updateVector3 = this._updateVector3ForUniform;\n      this.updateVector4 = this._updateVector4ForUniform;\n      this.updateColor3 = this._updateColor3ForUniform;\n      this.updateColor4 = this._updateColor4ForUniform;\n      this.updateDirectColor4 = this._updateDirectColor4ForUniform;\n      this.updateInt = this._updateIntForUniform;\n      this.updateInt2 = this._updateInt2ForUniform;\n      this.updateInt3 = this._updateInt3ForUniform;\n      this.updateInt4 = this._updateInt4ForUniform;\n      this.updateUInt = this._updateUIntForUniform;\n      this.updateUInt2 = this._updateUInt2ForUniform;\n      this.updateUInt3 = this._updateUInt3ForUniform;\n      this.updateUInt4 = this._updateUInt4ForUniform;\n    }\n  }\n  /**\n   * Indicates if the buffer is using the WebGL2 UBO implementation,\n   * or just falling back on setUniformXXX calls.\n   */\n  get useUbo() {\n    return !this._noUBO;\n  }\n  /**\n   * Indicates if the WebGL underlying uniform buffer is in sync\n   * with the javascript cache data.\n   */\n  get isSync() {\n    return !this._needSync;\n  }\n  /**\n   * Indicates if the WebGL underlying uniform buffer is dynamic.\n   * Also, a dynamic UniformBuffer will disable cache verification and always\n   * update the underlying WebGL uniform buffer to the GPU.\n   * @returns if Dynamic, otherwise false\n   */\n  isDynamic() {\n    return this._dynamic !== undefined;\n  }\n  /**\n   * The data cache on JS side.\n   * @returns the underlying data as a float array\n   */\n  getData() {\n    return this._bufferData;\n  }\n  /**\n   * The underlying WebGL Uniform buffer.\n   * @returns the webgl buffer\n   */\n  getBuffer() {\n    return this._buffer;\n  }\n  /**\n   * std140 layout specifies how to align data within an UBO structure.\n   * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\n   * for specs.\n   * @param size\n   */\n  _fillAlignment(size) {\n    // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\n    // and 4x4 matrices\n    // TODO : change if other types are used\n    let alignment;\n    if (size <= 2) {\n      alignment = size;\n    } else {\n      alignment = 4;\n    }\n    if (this._uniformLocationPointer % alignment !== 0) {\n      const oldPointer = this._uniformLocationPointer;\n      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;\n      const diff = this._uniformLocationPointer - oldPointer;\n      for (let i = 0; i < diff; i++) {\n        this._data.push(0);\n      }\n    }\n  }\n  /**\n   * Adds an uniform in the buffer.\n   * Warning : the subsequents calls of this function must be in the same order as declared in the shader\n   * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\n   * meaning size=1,2,3,4 or 16. It does not handle struct types.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param size Data size, or data directly.\n   * @param arraySize The number of elements in the array, 0 if not an array.\n   */\n  addUniform(name, size, arraySize = 0) {\n    if (this._noUBO) {\n      return;\n    }\n    if (this._uniformLocations[name] !== undefined) {\n      // Already existing uniform\n      return;\n    }\n    // This function must be called in the order of the shader layout !\n    // size can be the size of the uniform, or data directly\n    let data;\n    // std140 FTW...\n    if (arraySize > 0) {\n      if (size instanceof Array) {\n        throw \"addUniform should not be use with Array in UBO: \" + name;\n      }\n      this._fillAlignment(4);\n      this._uniformArraySizes[name] = {\n        strideSize: size,\n        arraySize\n      };\n      if (size == 16) {\n        size = size * arraySize;\n      } else {\n        const perElementPadding = 4 - size;\n        const totalPadding = perElementPadding * arraySize;\n        size = size * arraySize + totalPadding;\n      }\n      data = [];\n      // Fill with zeros\n      for (let i = 0; i < size; i++) {\n        data.push(0);\n      }\n    } else {\n      if (size instanceof Array) {\n        data = size;\n        size = data.length;\n      } else {\n        size = size;\n        data = [];\n        // Fill with zeros\n        for (let i = 0; i < size; i++) {\n          data.push(0);\n        }\n      }\n      this._fillAlignment(size);\n    }\n    this._uniformSizes[name] = size;\n    this._uniformLocations[name] = this._uniformLocationPointer;\n    this._uniformLocationPointer += size;\n    for (let i = 0; i < size; i++) {\n      this._data.push(data[i]);\n    }\n    this._needSync = true;\n  }\n  /**\n   * Adds a Matrix 4x4 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param mat A 4x4 matrix.\n   */\n  addMatrix(name, mat) {\n    this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\n  }\n  /**\n   * Adds a vec2 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param x Define the x component value of the vec2\n   * @param y Define the y component value of the vec2\n   */\n  addFloat2(name, x, y) {\n    const temp = [x, y];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param x Define the x component value of the vec3\n   * @param y Define the y component value of the vec3\n   * @param z Define the z component value of the vec3\n   */\n  addFloat3(name, x, y, z) {\n    const temp = [x, y, z];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param color Define the vec3 from a Color\n   */\n  addColor3(name, color) {\n    const temp = [color.r, color.g, color.b];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec4 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param color Define the rgb components from a Color\n   * @param alpha Define the a component of the vec4\n   */\n  addColor4(name, color, alpha) {\n    const temp = [color.r, color.g, color.b, alpha];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param vector Define the vec3 components from a Vector\n   */\n  addVector3(name, vector) {\n    const temp = [vector.x, vector.y, vector.z];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a Matrix 3x3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   */\n  addMatrix3x3(name) {\n    this.addUniform(name, 12);\n  }\n  /**\n   * Adds a Matrix 2x2 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   */\n  addMatrix2x2(name) {\n    this.addUniform(name, 8);\n  }\n  /**\n   * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\n   */\n  create() {\n    if (this._noUBO) {\n      return;\n    }\n    if (this._buffer) {\n      return; // nothing to do\n    }\n    // See spec, alignment must be filled as a vec4\n    this._fillAlignment(4);\n    this._bufferData = new Float32Array(this._data);\n    this._rebuild();\n    this._needSync = true;\n  }\n  _getNames() {\n    const names = [];\n    for (const name in this._uniformLocations) {\n      names.push(name);\n    }\n    return names.join(\",\");\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._noUBO || !this._bufferData) {\n      return;\n    }\n    if (this._dynamic) {\n      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\n    } else {\n      this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\n    }\n    if (this._engine._features.trackUbosInFrame) {\n      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\n      this._bufferIndex = this._buffers.length - 1;\n      this._createBufferOnWrite = false;\n    }\n  }\n  /** @internal */\n  get _numBuffers() {\n    return this._buffers.length;\n  }\n  /** @internal */\n  get _indexBuffer() {\n    return this._bufferIndex;\n  }\n  /** Gets the name of this buffer */\n  get name() {\n    return this._name;\n  }\n  /** Gets the current effect */\n  get currentEffect() {\n    return this._currentEffect;\n  }\n  _buffersEqual(buf1, buf2) {\n    for (let i = 0; i < buf1.length; ++i) {\n      if (buf1[i] !== buf2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _copyBuffer(src, dst) {\n    for (let i = 0; i < src.length; ++i) {\n      dst[i] = src[i];\n    }\n  }\n  /**\n   * Updates the WebGL Uniform Buffer on the GPU.\n   * If the `dynamic` flag is set to true, no cache comparison is done.\n   * Otherwise, the buffer will be updated only if the cache differs.\n   */\n  update() {\n    if (this._noUBO) {\n      return;\n    }\n    this.bindUniformBuffer();\n    if (!this._buffer) {\n      this.create();\n      return;\n    }\n    if (!this._dynamic && !this._needSync) {\n      this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n      return;\n    }\n    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\n      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {\n        this._needSync = false;\n        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n        return;\n      } else {\n        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);\n      }\n    }\n    this._engine.updateUniformBuffer(this._buffer, this._bufferData);\n    if (this._engine._features._collectUbosUpdatedInFrame) {\n      if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\n        UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\n      }\n      UniformBuffer._UpdatedUbosInFrame[this._name]++;\n    }\n    this._needSync = false;\n    this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n  }\n  _createNewBuffer() {\n    if (this._bufferIndex + 1 < this._buffers.length) {\n      this._bufferIndex++;\n      this._buffer = this._buffers[this._bufferIndex][0];\n      this._createBufferOnWrite = false;\n      this._needSync = true;\n    } else {\n      this._rebuild();\n    }\n  }\n  _checkNewFrame() {\n    if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {\n      this._currentFrameId = this._engine.frameId;\n      this._createBufferOnWrite = false;\n      if (this._buffers && this._buffers.length > 0) {\n        this._needSync = this._bufferIndex !== 0;\n        this._bufferIndex = 0;\n        this._buffer = this._buffers[this._bufferIndex][0];\n      } else {\n        this._bufferIndex = -1;\n      }\n    }\n  }\n  /**\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   * @param size Define the size of the data.\n   */\n  updateUniform(uniformName, data, size) {\n    this._checkNewFrame();\n    let location = this._uniformLocations[uniformName];\n    if (location === undefined) {\n      if (this._buffer) {\n        // Cannot add an uniform if the buffer is already created\n        Logger.Error(\"Cannot add an uniform after UBO has been created.\");\n        return;\n      }\n      this.addUniform(uniformName, size);\n      location = this._uniformLocations[uniformName];\n    }\n    if (!this._buffer) {\n      this.create();\n    }\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      let changed = false;\n      for (let i = 0; i < size; i++) {\n        // We are checking the matrix cache before calling updateUniform so we do not need to check it here\n        // Hence the test for size === 16 to simply commit the matrix values\n        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location + i] !== Math.fround(data[i])) {\n          changed = true;\n          if (this._createBufferOnWrite) {\n            this._createNewBuffer();\n          }\n          this._bufferData[location + i] = data[i];\n        }\n      }\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (let i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  }\n  /**\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   * @param size Define the size of the data.\n   */\n  updateUniformArray(uniformName, data, size) {\n    this._checkNewFrame();\n    const location = this._uniformLocations[uniformName];\n    if (location === undefined) {\n      Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.\");\n      return;\n    }\n    if (!this._buffer) {\n      this.create();\n    }\n    const arraySizes = this._uniformArraySizes[uniformName];\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      let changed = false;\n      let countToFour = 0;\n      let baseStride = 0;\n      for (let i = 0; i < size; i++) {\n        if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\n          changed = true;\n          if (this._createBufferOnWrite) {\n            this._createNewBuffer();\n          }\n          this._bufferData[location + baseStride * 4 + countToFour] = data[i];\n        }\n        countToFour++;\n        if (countToFour === arraySizes.strideSize) {\n          for (; countToFour < 4; countToFour++) {\n            this._bufferData[location + baseStride * 4 + countToFour] = 0;\n          }\n          countToFour = 0;\n          baseStride++;\n        }\n      }\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (let i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  }\n  _cacheMatrix(name, matrix) {\n    this._checkNewFrame();\n    const cache = this._valueCache[name];\n    const flag = matrix.updateFlag;\n    if (cache !== undefined && cache === flag) {\n      return false;\n    }\n    this._valueCache[name] = flag;\n    return true;\n  }\n  // Update methods\n  _updateMatrix3x3ForUniform(name, matrix) {\n    // To match std140, matrix must be realigned\n    for (let i = 0; i < 3; i++) {\n      UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\n      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\n      UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\n      UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\n    }\n    this.updateUniform(name, UniformBuffer._TempBuffer, 12);\n  }\n  _updateMatrix3x3ForEffect(name, matrix) {\n    this._currentEffect.setMatrix3x3(name, matrix);\n  }\n  _updateMatrix2x2ForEffect(name, matrix) {\n    this._currentEffect.setMatrix2x2(name, matrix);\n  }\n  _updateMatrix2x2ForUniform(name, matrix) {\n    // To match std140, matrix must be realigned\n    for (let i = 0; i < 2; i++) {\n      UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\n      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\n      UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\n      UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\n    }\n    this.updateUniform(name, UniformBuffer._TempBuffer, 8);\n  }\n  _updateFloatForEffect(name, x) {\n    this._currentEffect.setFloat(name, x);\n  }\n  _updateFloatForUniform(name, x) {\n    UniformBuffer._TempBuffer[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  }\n  _updateFloat2ForEffect(name, x, y, suffix = \"\") {\n    this._currentEffect.setFloat2(name + suffix, x, y);\n  }\n  _updateFloat2ForUniform(name, x, y) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  }\n  _updateFloat3ForEffect(name, x, y, z, suffix = \"\") {\n    this._currentEffect.setFloat3(name + suffix, x, y, z);\n  }\n  _updateFloat3ForUniform(name, x, y, z) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    UniformBuffer._TempBuffer[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateFloat4ForEffect(name, x, y, z, w, suffix = \"\") {\n    this._currentEffect.setFloat4(name + suffix, x, y, z, w);\n  }\n  _updateFloat4ForUniform(name, x, y, z, w) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    UniformBuffer._TempBuffer[2] = z;\n    UniformBuffer._TempBuffer[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateFloatArrayForEffect(name, array) {\n    this._currentEffect.setFloatArray(name, array);\n  }\n  _updateFloatArrayForUniform(name, array) {\n    this.updateUniformArray(name, array, array.length);\n  }\n  _updateArrayForEffect(name, array) {\n    this._currentEffect.setArray(name, array);\n  }\n  _updateArrayForUniform(name, array) {\n    this.updateUniformArray(name, array, array.length);\n  }\n  _updateIntArrayForEffect(name, array) {\n    this._currentEffect.setIntArray(name, array);\n  }\n  _updateIntArrayForUniform(name, array) {\n    UniformBuffer._TempBufferInt32View.set(array);\n    this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\n  }\n  _updateUIntArrayForEffect(name, array) {\n    this._currentEffect.setUIntArray(name, array);\n  }\n  _updateUIntArrayForUniform(name, array) {\n    UniformBuffer._TempBufferUInt32View.set(array);\n    this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\n  }\n  _updateMatrixForEffect(name, mat) {\n    this._currentEffect.setMatrix(name, mat);\n  }\n  _updateMatrixForUniform(name, mat) {\n    if (this._cacheMatrix(name, mat)) {\n      this.updateUniform(name, mat.toArray(), 16);\n    }\n  }\n  _updateMatricesForEffect(name, mat) {\n    this._currentEffect.setMatrices(name, mat);\n  }\n  _updateMatricesForUniform(name, mat) {\n    this.updateUniform(name, mat, mat.length);\n  }\n  _updateVector3ForEffect(name, vector) {\n    this._currentEffect.setVector3(name, vector);\n  }\n  _updateVector3ForUniform(name, vector) {\n    UniformBuffer._TempBuffer[0] = vector.x;\n    UniformBuffer._TempBuffer[1] = vector.y;\n    UniformBuffer._TempBuffer[2] = vector.z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateVector4ForEffect(name, vector) {\n    this._currentEffect.setVector4(name, vector);\n  }\n  _updateVector4ForUniform(name, vector) {\n    UniformBuffer._TempBuffer[0] = vector.x;\n    UniformBuffer._TempBuffer[1] = vector.y;\n    UniformBuffer._TempBuffer[2] = vector.z;\n    UniformBuffer._TempBuffer[3] = vector.w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateColor3ForEffect(name, color, suffix = \"\") {\n    this._currentEffect.setColor3(name + suffix, color);\n  }\n  _updateColor3ForUniform(name, color) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateColor4ForEffect(name, color, alpha, suffix = \"\") {\n    this._currentEffect.setColor4(name + suffix, color, alpha);\n  }\n  _updateDirectColor4ForEffect(name, color, suffix = \"\") {\n    this._currentEffect.setDirectColor4(name + suffix, color);\n  }\n  _updateColor4ForUniform(name, color, alpha) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    UniformBuffer._TempBuffer[3] = alpha;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateDirectColor4ForUniform(name, color) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    UniformBuffer._TempBuffer[3] = color.a;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateIntForEffect(name, x, suffix = \"\") {\n    this._currentEffect.setInt(name + suffix, x);\n  }\n  _updateIntForUniform(name, x) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  }\n  _updateInt2ForEffect(name, x, y, suffix = \"\") {\n    this._currentEffect.setInt2(name + suffix, x, y);\n  }\n  _updateInt2ForUniform(name, x, y) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  }\n  _updateInt3ForEffect(name, x, y, z, suffix = \"\") {\n    this._currentEffect.setInt3(name + suffix, x, y, z);\n  }\n  _updateInt3ForUniform(name, x, y, z) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    UniformBuffer._TempBufferInt32View[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateInt4ForEffect(name, x, y, z, w, suffix = \"\") {\n    this._currentEffect.setInt4(name + suffix, x, y, z, w);\n  }\n  _updateInt4ForUniform(name, x, y, z, w) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    UniformBuffer._TempBufferInt32View[2] = z;\n    UniformBuffer._TempBufferInt32View[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateUIntForEffect(name, x, suffix = \"\") {\n    this._currentEffect.setUInt(name + suffix, x);\n  }\n  _updateUIntForUniform(name, x) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  }\n  _updateUInt2ForEffect(name, x, y, suffix = \"\") {\n    this._currentEffect.setUInt2(name + suffix, x, y);\n  }\n  _updateUInt2ForUniform(name, x, y) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    UniformBuffer._TempBufferUInt32View[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  }\n  _updateUInt3ForEffect(name, x, y, z, suffix = \"\") {\n    this._currentEffect.setUInt3(name + suffix, x, y, z);\n  }\n  _updateUInt3ForUniform(name, x, y, z) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    UniformBuffer._TempBufferUInt32View[1] = y;\n    UniformBuffer._TempBufferUInt32View[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateUInt4ForEffect(name, x, y, z, w, suffix = \"\") {\n    this._currentEffect.setUInt4(name + suffix, x, y, z, w);\n  }\n  _updateUInt4ForUniform(name, x, y, z, w) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    UniformBuffer._TempBufferUInt32View[1] = y;\n    UniformBuffer._TempBufferUInt32View[2] = z;\n    UniformBuffer._TempBufferUInt32View[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  /**\n   * Sets a sampler uniform on the effect.\n   * @param name Define the name of the sampler.\n   * @param texture Define the texture to set in the sampler\n   */\n  setTexture(name, texture) {\n    this._currentEffect.setTexture(name, texture);\n  }\n  /**\n   * Sets a sampler uniform on the effect.\n   * @param name Define the name of the sampler.\n   * @param texture Define the (internal) texture to set in the sampler\n   */\n  bindTexture(name, texture) {\n    this._currentEffect._bindTexture(name, texture);\n  }\n  /**\n   * Directly updates the value of the uniform in the cache AND on the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   */\n  updateUniformDirectly(uniformName, data) {\n    this.updateUniform(uniformName, data, data.length);\n    this.update();\n  }\n  /**\n   * Associates an effect to this uniform buffer\n   * @param effect Define the effect to associate the buffer to\n   * @param name Name of the uniform block in the shader.\n   */\n  bindToEffect(effect, name) {\n    this._currentEffect = effect;\n    this._currentEffectName = name;\n  }\n  /**\n   * Binds the current (GPU) buffer to the effect\n   */\n  bindUniformBuffer() {\n    if (!this._noUBO && this._buffer && this._currentEffect) {\n      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\n    }\n  }\n  /**\n   * Dissociates the current effect from this uniform buffer\n   */\n  unbindEffect() {\n    this._currentEffect = undefined;\n    this._currentEffectName = undefined;\n  }\n  /**\n   * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\n   * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\n   * @param dataBuffer buffer to look for\n   * @returns true if the buffer has been found and the class internal state points to it, else false\n   */\n  setDataBuffer(dataBuffer) {\n    if (!this._buffers) {\n      return this._buffer === dataBuffer;\n    }\n    for (let b = 0; b < this._buffers.length; ++b) {\n      const buffer = this._buffers[b];\n      if (buffer[0] === dataBuffer) {\n        this._bufferIndex = b;\n        this._buffer = dataBuffer;\n        this._createBufferOnWrite = false;\n        this._currentEffect = undefined;\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Disposes the uniform buffer.\n   */\n  dispose() {\n    if (this._noUBO) {\n      return;\n    }\n    const uniformBuffers = this._engine._uniformBuffers;\n    const index = uniformBuffers.indexOf(this);\n    if (index !== -1) {\n      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\n      uniformBuffers.pop();\n    }\n    if (this._engine._features.trackUbosInFrame && this._buffers) {\n      for (let i = 0; i < this._buffers.length; ++i) {\n        const buffer = this._buffers[i][0];\n        this._engine._releaseBuffer(buffer);\n      }\n    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\n      this._buffer = null;\n    }\n  }\n}\n/** @internal */\nUniformBuffer._UpdatedUbosInFrame = {};\n// Pool for avoiding memory leaks\nUniformBuffer._MAX_UNIFORM_SIZE = 256;\nUniformBuffer._TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\nUniformBuffer._TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);\nUniformBuffer._TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);","map":{"version":3,"names":["Logger","Tools","UniformBuffer","constructor","engine","data","dynamic","name","forceNoUniformBuffer","_valueCache","_engine","_noUBO","supportsUniformBuffers","_dynamic","_name","_data","_uniformLocations","_uniformSizes","_uniformArraySizes","_uniformLocationPointer","_needSync","_features","trackUbosInFrame","_buffers","_bufferIndex","_createBufferOnWrite","_currentFrameId","updateMatrix3x3","_updateMatrix3x3ForEffect","updateMatrix2x2","_updateMatrix2x2ForEffect","updateFloat","_updateFloatForEffect","updateFloat2","_updateFloat2ForEffect","updateFloat3","_updateFloat3ForEffect","updateFloat4","_updateFloat4ForEffect","updateFloatArray","_updateFloatArrayForEffect","updateArray","_updateArrayForEffect","updateIntArray","_updateIntArrayForEffect","updateUIntArray","_updateUIntArrayForEffect","updateMatrix","_updateMatrixForEffect","updateMatrices","_updateMatricesForEffect","updateVector3","_updateVector3ForEffect","updateVector4","_updateVector4ForEffect","updateColor3","_updateColor3ForEffect","updateColor4","_updateColor4ForEffect","updateDirectColor4","_updateDirectColor4ForEffect","updateInt","_updateIntForEffect","updateInt2","_updateInt2ForEffect","updateInt3","_updateInt3ForEffect","updateInt4","_updateInt4ForEffect","updateUInt","_updateUIntForEffect","updateUInt2","_updateUInt2ForEffect","updateUInt3","_updateUInt3ForEffect","updateUInt4","_updateUInt4ForEffect","_uniformBuffers","push","_updateMatrix3x3ForUniform","_updateMatrix2x2ForUniform","_updateFloatForUniform","_updateFloat2ForUniform","_updateFloat3ForUniform","_updateFloat4ForUniform","_updateFloatArrayForUniform","_updateArrayForUniform","_updateIntArrayForUniform","_updateUIntArrayForUniform","_updateMatrixForUniform","_updateMatricesForUniform","_updateVector3ForUniform","_updateVector4ForUniform","_updateColor3ForUniform","_updateColor4ForUniform","_updateDirectColor4ForUniform","_updateIntForUniform","_updateInt2ForUniform","_updateInt3ForUniform","_updateInt4ForUniform","_updateUIntForUniform","_updateUInt2ForUniform","_updateUInt3ForUniform","_updateUInt4ForUniform","useUbo","isSync","isDynamic","undefined","getData","_bufferData","getBuffer","_buffer","_fillAlignment","size","alignment","oldPointer","diff","i","addUniform","arraySize","Array","strideSize","perElementPadding","totalPadding","length","addMatrix","mat","prototype","slice","call","toArray","addFloat2","x","y","temp","addFloat3","z","addColor3","color","r","g","b","addColor4","alpha","addVector3","vector","addMatrix3x3","addMatrix2x2","create","Float32Array","_rebuild","_getNames","names","join","createDynamicUniformBuffer","createUniformBuffer","checkUbosContentBeforeUpload","_numBuffers","_indexBuffer","currentEffect","_currentEffect","_buffersEqual","buf1","buf2","_copyBuffer","src","dst","update","bindUniformBuffer","updateUniformBuffer","_collectUbosUpdatedInFrame","_UpdatedUbosInFrame","_createNewBuffer","_checkNewFrame","frameId","updateUniform","uniformName","location","Error","changed","uniformBufferHardCheckMatrix","Math","fround","updateUniformArray","arraySizes","countToFour","baseStride","FloatRound","_cacheMatrix","matrix","cache","flag","updateFlag","_TempBuffer","setMatrix3x3","setMatrix2x2","setFloat","suffix","setFloat2","setFloat3","w","setFloat4","array","setFloatArray","setArray","setIntArray","_TempBufferInt32View","set","setUIntArray","_TempBufferUInt32View","setMatrix","setMatrices","setVector3","setVector4","setColor3","setColor4","setDirectColor4","a","setInt","setInt2","setInt3","setInt4","setUInt","setUInt2","setUInt3","setUInt4","setTexture","texture","bindTexture","_bindTexture","updateUniformDirectly","bindToEffect","effect","_currentEffectName","unbindEffect","setDataBuffer","dataBuffer","buffer","dispose","uniformBuffers","index","indexOf","pop","_releaseBuffer","_MAX_UNIFORM_SIZE","Int32Array","Uint32Array"],"sources":["../../../../dev/core/src/Materials/uniformBuffer.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { IMatrixLike, IVector3Like, IVector4Like, IColor3Like, IColor4Like } from \"../Maths/math.like\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { InternalTexture } from \"./Textures/internalTexture\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport \"../Engines/Extensions/engine.uniformBuffer\";\r\n\r\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\r\nexport class UniformBuffer {\r\n    /** @internal */\r\n    public static _UpdatedUbosInFrame: { [name: string]: number } = {};\r\n\r\n    private _engine: ThinEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    private _buffers: Array<[DataBuffer, Float32Array | undefined]>;\r\n    private _bufferIndex: number;\r\n    private _createBufferOnWrite: boolean;\r\n    private _data: number[];\r\n    private _bufferData: Float32Array;\r\n    private _dynamic?: boolean;\r\n    private _uniformLocations: { [key: string]: number };\r\n    private _uniformSizes: { [key: string]: number };\r\n    private _uniformArraySizes: { [key: string]: { strideSize: number; arraySize: number } };\r\n    private _uniformLocationPointer: number;\r\n    private _needSync: boolean;\r\n    private _noUBO: boolean;\r\n    private _currentEffect: Effect;\r\n    private _currentEffectName: string;\r\n    private _name: string;\r\n    private _currentFrameId: number;\r\n\r\n    // Pool for avoiding memory leaks\r\n    private static _MAX_UNIFORM_SIZE = 256;\r\n    private static _TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\r\n    private static _TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);\r\n    private static _TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);\r\n\r\n    /**\r\n     * Lambda to Update a 3x3 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix3x3: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 2x2 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix2x2: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a single float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat: (name: string, x: number) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloatArray: (name: string, array: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateArray: (name: string, array: number[]) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateIntArray: (name: string, array: Int32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUIntArray: (name: string, array: Uint32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix: (name: string, mat: IMatrixLike) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrices: (name: string, mat: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector3: (name: string, vector: IVector3Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector4: (name: string, vector: IVector4Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor3: (name: string, color: IColor3Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor4: (name: string, color: IColor3Like, alpha: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateDirectColor4: (name: string, color: IColor4Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a unsigned int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Instantiates a new Uniform buffer objects.\r\n     *\r\n     * Handles blocks of uniform on the GPU.\r\n     *\r\n     * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n     *\r\n     * For more information, please refer to :\r\n     * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n     * @param engine Define the engine the buffer is associated with\r\n     * @param data Define the data contained in the buffer\r\n     * @param dynamic Define if the buffer is updatable\r\n     * @param name to assign to the buffer (debugging purpose)\r\n     * @param forceNoUniformBuffer define that this object must not rely on UBO objects\r\n     */\r\n    constructor(engine: ThinEngine, data?: number[], dynamic?: boolean, name?: string, forceNoUniformBuffer = false) {\r\n        this._engine = engine;\r\n        this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\r\n        this._dynamic = dynamic;\r\n        this._name = name ?? \"no-name\";\r\n\r\n        this._data = data || [];\r\n\r\n        this._uniformLocations = {};\r\n        this._uniformSizes = {};\r\n        this._uniformArraySizes = {};\r\n        this._uniformLocationPointer = 0;\r\n        this._needSync = false;\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers = [];\r\n            this._bufferIndex = -1;\r\n            this._createBufferOnWrite = false;\r\n            this._currentFrameId = 0;\r\n        }\r\n\r\n        if (this._noUBO) {\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\r\n            this.updateFloat = this._updateFloatForEffect;\r\n            this.updateFloat2 = this._updateFloat2ForEffect;\r\n            this.updateFloat3 = this._updateFloat3ForEffect;\r\n            this.updateFloat4 = this._updateFloat4ForEffect;\r\n            this.updateFloatArray = this._updateFloatArrayForEffect;\r\n            this.updateArray = this._updateArrayForEffect;\r\n            this.updateIntArray = this._updateIntArrayForEffect;\r\n            this.updateUIntArray = this._updateUIntArrayForEffect;\r\n            this.updateMatrix = this._updateMatrixForEffect;\r\n            this.updateMatrices = this._updateMatricesForEffect;\r\n            this.updateVector3 = this._updateVector3ForEffect;\r\n            this.updateVector4 = this._updateVector4ForEffect;\r\n            this.updateColor3 = this._updateColor3ForEffect;\r\n            this.updateColor4 = this._updateColor4ForEffect;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForEffect;\r\n            this.updateInt = this._updateIntForEffect;\r\n            this.updateInt2 = this._updateInt2ForEffect;\r\n            this.updateInt3 = this._updateInt3ForEffect;\r\n            this.updateInt4 = this._updateInt4ForEffect;\r\n            this.updateUInt = this._updateUIntForEffect;\r\n            this.updateUInt2 = this._updateUInt2ForEffect;\r\n            this.updateUInt3 = this._updateUInt3ForEffect;\r\n            this.updateUInt4 = this._updateUInt4ForEffect;\r\n        } else {\r\n            this._engine._uniformBuffers.push(this);\r\n\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\r\n            this.updateFloat = this._updateFloatForUniform;\r\n            this.updateFloat2 = this._updateFloat2ForUniform;\r\n            this.updateFloat3 = this._updateFloat3ForUniform;\r\n            this.updateFloat4 = this._updateFloat4ForUniform;\r\n            this.updateFloatArray = this._updateFloatArrayForUniform;\r\n            this.updateArray = this._updateArrayForUniform;\r\n            this.updateIntArray = this._updateIntArrayForUniform;\r\n            this.updateUIntArray = this._updateUIntArrayForUniform;\r\n            this.updateMatrix = this._updateMatrixForUniform;\r\n            this.updateMatrices = this._updateMatricesForUniform;\r\n            this.updateVector3 = this._updateVector3ForUniform;\r\n            this.updateVector4 = this._updateVector4ForUniform;\r\n            this.updateColor3 = this._updateColor3ForUniform;\r\n            this.updateColor4 = this._updateColor4ForUniform;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForUniform;\r\n            this.updateInt = this._updateIntForUniform;\r\n            this.updateInt2 = this._updateInt2ForUniform;\r\n            this.updateInt3 = this._updateInt3ForUniform;\r\n            this.updateInt4 = this._updateInt4ForUniform;\r\n            this.updateUInt = this._updateUIntForUniform;\r\n            this.updateUInt2 = this._updateUInt2ForUniform;\r\n            this.updateUInt3 = this._updateUInt3ForUniform;\r\n            this.updateUInt4 = this._updateUInt4ForUniform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\r\n    public get useUbo(): boolean {\r\n        return !this._noUBO;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\r\n    public get isSync(): boolean {\r\n        return !this._needSync;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n     * Also, a dynamic UniformBuffer will disable cache verification and always\r\n     * update the underlying WebGL uniform buffer to the GPU.\r\n     * @returns if Dynamic, otherwise false\r\n     */\r\n    public isDynamic(): boolean {\r\n        return this._dynamic !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The data cache on JS side.\r\n     * @returns the underlying data as a float array\r\n     */\r\n    public getData(): Float32Array {\r\n        return this._bufferData;\r\n    }\r\n\r\n    /**\r\n     * The underlying WebGL Uniform buffer.\r\n     * @returns the webgl buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * std140 layout specifies how to align data within an UBO structure.\r\n     * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n     * for specs.\r\n     * @param size\r\n     */\r\n    private _fillAlignment(size: number) {\r\n        // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\r\n        // and 4x4 matrices\r\n        // TODO : change if other types are used\r\n\r\n        let alignment;\r\n        if (size <= 2) {\r\n            alignment = size;\r\n        } else {\r\n            alignment = 4;\r\n        }\r\n\r\n        if (this._uniformLocationPointer % alignment !== 0) {\r\n            const oldPointer = this._uniformLocationPointer;\r\n            this._uniformLocationPointer += alignment - (this._uniformLocationPointer % alignment);\r\n            const diff = this._uniformLocationPointer - oldPointer;\r\n\r\n            for (let i = 0; i < diff; i++) {\r\n                this._data.push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an uniform in the buffer.\r\n     * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n     * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\r\n     * meaning size=1,2,3,4 or 16. It does not handle struct types.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param size Data size, or data directly.\r\n     * @param arraySize The number of elements in the array, 0 if not an array.\r\n     */\r\n    public addUniform(name: string, size: number | number[], arraySize = 0) {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        if (this._uniformLocations[name] !== undefined) {\r\n            // Already existing uniform\r\n            return;\r\n        }\r\n        // This function must be called in the order of the shader layout !\r\n        // size can be the size of the uniform, or data directly\r\n        let data;\r\n\r\n        // std140 FTW...\r\n        if (arraySize > 0) {\r\n            if (size instanceof Array) {\r\n                throw \"addUniform should not be use with Array in UBO: \" + name;\r\n            }\r\n\r\n            this._fillAlignment(4);\r\n\r\n            this._uniformArraySizes[name] = { strideSize: size, arraySize };\r\n            if (size == 16) {\r\n                size = size * arraySize;\r\n            } else {\r\n                const perElementPadding = 4 - size;\r\n                const totalPadding = perElementPadding * arraySize;\r\n                size = size * arraySize + totalPadding;\r\n            }\r\n\r\n            data = [];\r\n            // Fill with zeros\r\n            for (let i = 0; i < size; i++) {\r\n                data.push(0);\r\n            }\r\n        } else {\r\n            if (size instanceof Array) {\r\n                data = size;\r\n                size = data.length;\r\n            } else {\r\n                size = <number>size;\r\n                data = [];\r\n\r\n                // Fill with zeros\r\n                for (let i = 0; i < size; i++) {\r\n                    data.push(0);\r\n                }\r\n            }\r\n            this._fillAlignment(<number>size);\r\n        }\r\n\r\n        this._uniformSizes[name] = <number>size;\r\n        this._uniformLocations[name] = this._uniformLocationPointer;\r\n        this._uniformLocationPointer += <number>size;\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            this._data.push(data[i]);\r\n        }\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 4x4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param mat A 4x4 matrix.\r\n     */\r\n    public addMatrix(name: string, mat: IMatrixLike) {\r\n        this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\r\n    }\r\n\r\n    /**\r\n     * Adds a vec2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec2\r\n     * @param y Define the y component value of the vec2\r\n     */\r\n    public addFloat2(name: string, x: number, y: number) {\r\n        const temp = [x, y];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec3\r\n     * @param y Define the y component value of the vec3\r\n     * @param z Define the z component value of the vec3\r\n     */\r\n    public addFloat3(name: string, x: number, y: number, z: number) {\r\n        const temp = [x, y, z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the vec3 from a Color\r\n     */\r\n    public addColor3(name: string, color: IColor3Like) {\r\n        const temp = [color.r, color.g, color.b];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the rgb components from a Color\r\n     * @param alpha Define the a component of the vec4\r\n     */\r\n    public addColor4(name: string, color: IColor3Like, alpha: number) {\r\n        const temp = [color.r, color.g, color.b, alpha];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param vector Define the vec3 components from a Vector\r\n     */\r\n    public addVector3(name: string, vector: IVector3Like) {\r\n        const temp = [vector.x, vector.y, vector.z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 3x3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix3x3(name: string) {\r\n        this.addUniform(name, 12);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 2x2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix2x2(name: string) {\r\n        this.addUniform(name, 8);\r\n    }\r\n\r\n    /**\r\n     * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n     */\r\n    public create(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n        if (this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        // See spec, alignment must be filled as a vec4\r\n        this._fillAlignment(4);\r\n        this._bufferData = new Float32Array(this._data);\r\n\r\n        this._rebuild();\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    private _getNames() {\r\n        const names = [];\r\n        for (const name in this._uniformLocations) {\r\n            names.push(name);\r\n        }\r\n        return names.join(\",\");\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._noUBO || !this._bufferData) {\r\n            return;\r\n        }\r\n\r\n        if (this._dynamic) {\r\n            this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\r\n        } else {\r\n            this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\r\n            this._bufferIndex = this._buffers.length - 1;\r\n            this._createBufferOnWrite = false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _numBuffers(): number {\r\n        return this._buffers.length;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _indexBuffer(): number {\r\n        return this._bufferIndex;\r\n    }\r\n\r\n    /** Gets the name of this buffer */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /** Gets the current effect */\r\n    public get currentEffect(): Nullable<Effect> {\r\n        return this._currentEffect;\r\n    }\r\n\r\n    private _buffersEqual(buf1: Float32Array, buf2: Float32Array): boolean {\r\n        for (let i = 0; i < buf1.length; ++i) {\r\n            if (buf1[i] !== buf2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _copyBuffer(src: Float32Array, dst: Float32Array): void {\r\n        for (let i = 0; i < src.length; ++i) {\r\n            dst[i] = src[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the WebGL Uniform Buffer on the GPU.\r\n     * If the `dynamic` flag is set to true, no cache comparison is done.\r\n     * Otherwise, the buffer will be updated only if the cache differs.\r\n     */\r\n    public update(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        this.bindUniformBuffer();\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n            return;\r\n        }\r\n\r\n        if (!this._dynamic && !this._needSync) {\r\n            this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n            return;\r\n        }\r\n\r\n        if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\r\n            if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1]!)) {\r\n                this._needSync = false;\r\n                this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n                return;\r\n            } else {\r\n                this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]!);\r\n            }\r\n        }\r\n\r\n        this._engine.updateUniformBuffer(this._buffer, this._bufferData);\r\n\r\n        if (this._engine._features._collectUbosUpdatedInFrame) {\r\n            if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\r\n                UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame[this._name]++;\r\n        }\r\n\r\n        this._needSync = false;\r\n        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n    }\r\n\r\n    private _createNewBuffer() {\r\n        if (this._bufferIndex + 1 < this._buffers.length) {\r\n            this._bufferIndex++;\r\n            this._buffer = this._buffers[this._bufferIndex][0];\r\n            this._createBufferOnWrite = false;\r\n            this._needSync = true;\r\n        } else {\r\n            this._rebuild();\r\n        }\r\n    }\r\n\r\n    private _checkNewFrame(): void {\r\n        if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {\r\n            this._currentFrameId = this._engine.frameId;\r\n            this._createBufferOnWrite = false;\r\n            if (this._buffers && this._buffers.length > 0) {\r\n                this._needSync = this._bufferIndex !== 0;\r\n                this._bufferIndex = 0;\r\n                this._buffer = this._buffers[this._bufferIndex][0];\r\n            } else {\r\n                this._bufferIndex = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniform(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        let location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            if (this._buffer) {\r\n                // Cannot add an uniform if the buffer is already created\r\n                Logger.Error(\"Cannot add an uniform after UBO has been created.\");\r\n                return;\r\n            }\r\n            this.addUniform(uniformName, size);\r\n            location = this._uniformLocations[uniformName];\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n\r\n            for (let i = 0; i < size; i++) {\r\n                // We are checking the matrix cache before calling updateUniform so we do not need to check it here\r\n                // Hence the test for size === 16 to simply commit the matrix values\r\n                if ((size === 16 && !this._engine._features.uniformBufferHardCheckMatrix) || this._bufferData[location + i] !== Math.fround(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + i] = data[i];\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniformArray(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        const location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.\");\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        const arraySizes = this._uniformArraySizes[uniformName];\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n            let countToFour = 0;\r\n            let baseStride = 0;\r\n            for (let i = 0; i < size; i++) {\r\n                if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + baseStride * 4 + countToFour] = data[i];\r\n                }\r\n                countToFour++;\r\n                if (countToFour === arraySizes.strideSize) {\r\n                    for (; countToFour < 4; countToFour++) {\r\n                        this._bufferData[location + baseStride * 4 + countToFour] = 0;\r\n                    }\r\n                    countToFour = 0;\r\n                    baseStride++;\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Matrix cache\r\n    private _valueCache: { [key: string]: number } = {};\r\n    private _cacheMatrix(name: string, matrix: IMatrixLike): boolean {\r\n        this._checkNewFrame();\r\n\r\n        const cache = this._valueCache[name];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[name] = flag;\r\n        return true;\r\n    }\r\n\r\n    // Update methods\r\n\r\n    private _updateMatrix3x3ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 3; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 12);\r\n    }\r\n\r\n    private _updateMatrix3x3ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix3x3(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix2x2(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 2; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 8);\r\n    }\r\n\r\n    private _updateFloatForEffect(name: string, x: number) {\r\n        this._currentEffect.setFloat(name, x);\r\n    }\r\n\r\n    private _updateFloatForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateFloat2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setFloat2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateFloat2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateFloat3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setFloat3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateFloat3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateFloat4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setFloat4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateFloat4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        UniformBuffer._TempBuffer[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateFloatArrayForEffect(name: string, array: Float32Array) {\r\n        this._currentEffect.setFloatArray(name, array);\r\n    }\r\n\r\n    private _updateFloatArrayForUniform(name: string, array: Float32Array) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateArrayForEffect(name: string, array: number[]) {\r\n        this._currentEffect.setArray(name, array);\r\n    }\r\n\r\n    private _updateArrayForUniform(name: string, array: number[]) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateIntArrayForEffect(name: string, array: Int32Array) {\r\n        this._currentEffect.setIntArray(name, array);\r\n    }\r\n\r\n    private _updateIntArrayForUniform(name: string, array: Int32Array) {\r\n        UniformBuffer._TempBufferInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateUIntArrayForEffect(name: string, array: Uint32Array) {\r\n        this._currentEffect.setUIntArray(name, array);\r\n    }\r\n\r\n    private _updateUIntArrayForUniform(name: string, array: Uint32Array) {\r\n        UniformBuffer._TempBufferUInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateMatrixForEffect(name: string, mat: IMatrixLike) {\r\n        this._currentEffect.setMatrix(name, mat);\r\n    }\r\n\r\n    private _updateMatrixForUniform(name: string, mat: IMatrixLike) {\r\n        if (this._cacheMatrix(name, mat)) {\r\n            this.updateUniform(name, <any>mat.toArray(), 16);\r\n        }\r\n    }\r\n\r\n    private _updateMatricesForEffect(name: string, mat: Float32Array) {\r\n        this._currentEffect.setMatrices(name, mat);\r\n    }\r\n\r\n    private _updateMatricesForUniform(name: string, mat: Float32Array) {\r\n        this.updateUniform(name, mat, mat.length);\r\n    }\r\n\r\n    private _updateVector3ForEffect(name: string, vector: IVector3Like) {\r\n        this._currentEffect.setVector3(name, vector);\r\n    }\r\n\r\n    private _updateVector3ForUniform(name: string, vector: IVector3Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateVector4ForEffect(name: string, vector: IVector4Like) {\r\n        this._currentEffect.setVector4(name, vector);\r\n    }\r\n\r\n    private _updateVector4ForUniform(name: string, vector: IVector4Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        UniformBuffer._TempBuffer[3] = vector.w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateColor3ForEffect(name: string, color: IColor3Like, suffix = \"\") {\r\n        this._currentEffect.setColor3(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor3ForUniform(name: string, color: IColor3Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateColor4ForEffect(name: string, color: IColor3Like, alpha: number, suffix = \"\") {\r\n        this._currentEffect.setColor4(name + suffix, color, alpha);\r\n    }\r\n\r\n    private _updateDirectColor4ForEffect(name: string, color: IColor4Like, suffix = \"\") {\r\n        this._currentEffect.setDirectColor4(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor4ForUniform(name: string, color: IColor3Like, alpha: number) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = alpha;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateDirectColor4ForUniform(name: string, color: IColor4Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = color.a;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        UniformBuffer._TempBufferInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateUIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setUInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateUIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateUInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setUInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateUInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateUInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setUInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateUInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateUInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setUInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateUInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        UniformBuffer._TempBufferUInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the texture to set in the sampler\r\n     */\r\n    public setTexture(name: string, texture: Nullable<ThinTexture>) {\r\n        this._currentEffect.setTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the (internal) texture to set in the sampler\r\n     */\r\n    public bindTexture(name: string, texture: Nullable<InternalTexture>) {\r\n        this._currentEffect._bindTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Directly updates the value of the uniform in the cache AND on the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     */\r\n    public updateUniformDirectly(uniformName: string, data: FloatArray) {\r\n        this.updateUniform(uniformName, data, data.length);\r\n\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Associates an effect to this uniform buffer\r\n     * @param effect Define the effect to associate the buffer to\r\n     * @param name Name of the uniform block in the shader.\r\n     */\r\n    public bindToEffect(effect: Effect, name: string): void {\r\n        this._currentEffect = effect;\r\n        this._currentEffectName = name;\r\n    }\r\n\r\n    /**\r\n     * Binds the current (GPU) buffer to the effect\r\n     */\r\n    public bindUniformBuffer(): void {\r\n        if (!this._noUBO && this._buffer && this._currentEffect) {\r\n            this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dissociates the current effect from this uniform buffer\r\n     */\r\n    public unbindEffect(): void {\r\n        this._currentEffect = undefined as any;\r\n        this._currentEffectName = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\r\n     * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\r\n     * @param dataBuffer buffer to look for\r\n     * @returns true if the buffer has been found and the class internal state points to it, else false\r\n     */\r\n    public setDataBuffer(dataBuffer: DataBuffer): boolean {\r\n        if (!this._buffers) {\r\n            return this._buffer === dataBuffer;\r\n        }\r\n\r\n        for (let b = 0; b < this._buffers.length; ++b) {\r\n            const buffer = this._buffers[b];\r\n            if (buffer[0] === dataBuffer) {\r\n                this._bufferIndex = b;\r\n                this._buffer = dataBuffer;\r\n                this._createBufferOnWrite = false;\r\n                this._currentEffect = undefined as any;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the uniform buffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        const uniformBuffers = this._engine._uniformBuffers;\r\n        const index = uniformBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\r\n            uniformBuffers.pop();\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame && this._buffers) {\r\n            for (let i = 0; i < this._buffers.length; ++i) {\r\n                const buffer = this._buffers[i][0];\r\n                this._engine._releaseBuffer(buffer!);\r\n            }\r\n        } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}