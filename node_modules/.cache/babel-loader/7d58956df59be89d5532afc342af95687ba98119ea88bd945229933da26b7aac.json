{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n * Defines a subdivision inside a mesh\n */\nexport class SubMesh {\n  /**\n   * Gets material defines used by the effect associated to the sub mesh\n   */\n  get materialDefines() {\n    var _a;\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;\n  }\n  /**\n   * Sets material defines used by the effect associated to the sub mesh\n   */\n  set materialDefines(defines) {\n    var _a;\n    const drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n    drawWrapper.defines = defines;\n  }\n  /**\n   * @internal\n   */\n  _getDrawWrapper(passId, createIfNotExisting = false) {\n    passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;\n    let drawWrapper = this._drawWrappers[passId];\n    if (!drawWrapper && createIfNotExisting) {\n      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\n    }\n    return drawWrapper;\n  }\n  /**\n   * @internal\n   */\n  _removeDrawWrapper(passId, disposeWrapper = true) {\n    var _a;\n    if (disposeWrapper) {\n      (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    this._drawWrappers[passId] = undefined;\n  }\n  /**\n   * Gets associated (main) effect (possibly the effect override if defined)\n   */\n  get effect() {\n    var _a, _b;\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;\n  }\n  /** @internal */\n  get _drawWrapper() {\n    var _a;\n    return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n  }\n  /** @internal */\n  get _drawWrapperOverride() {\n    return this._mainDrawWrapperOverride;\n  }\n  /**\n   * @internal\n   */\n  _setMainDrawWrapperOverride(wrapper) {\n    this._mainDrawWrapperOverride = wrapper;\n  }\n  /**\n   * Sets associated effect (effect used to render this submesh)\n   * @param effect defines the effect to associate with\n   * @param defines defines the set of defines used to compile this effect\n   * @param materialContext material context associated to the effect\n   * @param resetContext true to reset the draw context\n   */\n  setEffect(effect, defines = null, materialContext, resetContext = true) {\n    const drawWrapper = this._drawWrapper;\n    drawWrapper.setEffect(effect, defines, resetContext);\n    if (materialContext !== undefined) {\n      drawWrapper.materialContext = materialContext;\n    }\n    if (!effect) {\n      drawWrapper.defines = null;\n      drawWrapper.materialContext = undefined;\n    }\n  }\n  /**\n   * Resets the draw wrappers cache\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n  resetDrawCache(passId) {\n    if (this._drawWrappers) {\n      if (passId !== undefined) {\n        this._removeDrawWrapper(passId);\n        return;\n      } else {\n        for (const drawWrapper of this._drawWrappers) {\n          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n        }\n      }\n    }\n    this._drawWrappers = [];\n  }\n  /**\n   * Add a new submesh to a mesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns the new submesh\n   */\n  static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n  /**\n   * Creates a new submesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\n   */\n  constructor( /** the material index to use */\n  materialIndex, /** vertex index start */\n  verticesStart, /** vertices count */\n  verticesCount, /** index start */\n  indexStart, /** indices count */\n  indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true) {\n    this.materialIndex = materialIndex;\n    this.verticesStart = verticesStart;\n    this.verticesCount = verticesCount;\n    this.indexStart = indexStart;\n    this.indexCount = indexCount;\n    this._mainDrawWrapperOverride = null;\n    /** @internal */\n    this._linesIndexCount = 0;\n    this._linesIndexBuffer = null;\n    /** @internal */\n    this._lastColliderWorldVertices = null;\n    /** @internal */\n    this._lastColliderTransformMatrix = null;\n    /** @internal */\n    this._wasDispatched = false;\n    /** @internal */\n    this._renderId = 0;\n    /** @internal */\n    this._alphaIndex = 0;\n    /** @internal */\n    this._distanceToCamera = 0;\n    this._currentMaterial = null;\n    this._mesh = mesh;\n    this._renderingMesh = renderingMesh || mesh;\n    if (addToMesh) {\n      mesh.subMeshes.push(this);\n    }\n    this._engine = this._mesh.getScene().getEngine();\n    this.resetDrawCache();\n    this._trianglePlanes = [];\n    this._id = mesh.subMeshes.length - 1;\n    if (createBoundingBox) {\n      this.refreshBoundingInfo();\n      mesh.computeWorldMatrix(true);\n    }\n  }\n  /**\n   * Returns true if this submesh covers the entire parent mesh\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get IsGlobal() {\n    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\n  }\n  /**\n   * Returns the submesh BoundingInfo object\n   * @returns current bounding info (or mesh's one if the submesh is global)\n   */\n  getBoundingInfo() {\n    if (this.IsGlobal || this._mesh.hasThinInstances) {\n      return this._mesh.getBoundingInfo();\n    }\n    return this._boundingInfo;\n  }\n  /**\n   * Sets the submesh BoundingInfo\n   * @param boundingInfo defines the new bounding info to use\n   * @returns the SubMesh\n   */\n  setBoundingInfo(boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  }\n  /**\n   * Returns the mesh of the current submesh\n   * @returns the parent mesh\n   */\n  getMesh() {\n    return this._mesh;\n  }\n  /**\n   * Returns the rendering mesh of the submesh\n   * @returns the rendering mesh (could be different from parent mesh)\n   */\n  getRenderingMesh() {\n    return this._renderingMesh;\n  }\n  /**\n   * Returns the replacement mesh of the submesh\n   * @returns the replacement mesh (could be different from parent mesh)\n   */\n  getReplacementMesh() {\n    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n  }\n  /**\n   * Returns the effective mesh of the submesh\n   * @returns the effective mesh (could be different from parent mesh)\n   */\n  getEffectiveMesh() {\n    const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    return replacementMesh ? replacementMesh : this._renderingMesh;\n  }\n  /**\n   * Returns the submesh material\n   * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\n   * @returns null or the current material\n   */\n  getMaterial(getDefaultMaterial = true) {\n    var _a;\n    const rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;\n    if (!rootMaterial) {\n      return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\n    } else if (this._isMultiMaterial(rootMaterial)) {\n      const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n      if (this._currentMaterial !== effectiveMaterial) {\n        this._currentMaterial = effectiveMaterial;\n        this.resetDrawCache();\n      }\n      return effectiveMaterial;\n    }\n    return rootMaterial;\n  }\n  _isMultiMaterial(material) {\n    return material.getSubMaterial !== undefined;\n  }\n  // Methods\n  /**\n   * Sets a new updated BoundingInfo object to the submesh\n   * @param data defines an optional position array to use to determine the bounding info\n   * @returns the SubMesh\n   */\n  refreshBoundingInfo(data = null) {\n    this._lastColliderWorldVertices = null;\n    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n      return this;\n    }\n    if (!data) {\n      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\n    }\n    if (!data) {\n      this._boundingInfo = this._mesh.getBoundingInfo();\n      return this;\n    }\n    const indices = this._renderingMesh.getIndices();\n    let extend;\n    //is this the only submesh?\n    if (this.indexStart === 0 && this.indexCount === indices.length) {\n      const boundingInfo = this._renderingMesh.getBoundingInfo();\n      //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n      extend = {\n        minimum: boundingInfo.minimum.clone(),\n        maximum: boundingInfo.maximum.clone()\n      };\n    } else {\n      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n    }\n    if (this._boundingInfo) {\n      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n    } else {\n      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _checkCollision(collider) {\n    const boundingInfo = this.getBoundingInfo();\n    return boundingInfo._checkCollision(collider);\n  }\n  /**\n   * Updates the submesh BoundingInfo\n   * @param world defines the world matrix to use to update the bounding info\n   * @returns the submesh\n   */\n  updateBoundingInfo(world) {\n    let boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      this.refreshBoundingInfo();\n      boundingInfo = this.getBoundingInfo();\n    }\n    if (boundingInfo) {\n      boundingInfo.update(world);\n    }\n    return this;\n  }\n  /**\n   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is intersecting with the frustum\n   */\n  isInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n  }\n  /**\n   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is inside the frustum\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  }\n  /**\n   * Renders the submesh\n   * @param enableAlphaMode defines if alpha needs to be used\n   * @returns the submesh\n   */\n  render(enableAlphaMode) {\n    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _getLinesIndexBuffer(indices, engine) {\n    if (!this._linesIndexBuffer) {\n      const linesIndices = [];\n      for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n      }\n      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n      this._linesIndexCount = linesIndices.length;\n    }\n    return this._linesIndexBuffer;\n  }\n  /**\n   * Checks if the submesh intersects with a ray\n   * @param ray defines the ray to test\n   * @returns true is the passed ray intersects the submesh bounding box\n   */\n  canIntersects(ray) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return ray.intersectsBox(boundingInfo.boundingBox);\n  }\n  /**\n   * Intersects current submesh with a ray\n   * @param ray defines the ray to test\n   * @param positions defines mesh's positions array\n   * @param indices defines mesh's indices array\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns intersection info or null if no intersection\n   */\n  intersects(ray, positions, indices, fastCheck, trianglePredicate) {\n    const material = this.getMaterial();\n    if (!material) {\n      return null;\n    }\n    let step = 3;\n    let checkStopper = false;\n    switch (material.fillMode) {\n      case 3:\n      case 5:\n      case 6:\n      case 8:\n        return null;\n      case 7:\n        step = 1;\n        checkStopper = true;\n        break;\n      default:\n        break;\n    }\n    // LineMesh first as it's also a Mesh...\n    if (material.fillMode === 4) {\n      // Check if mesh is unindexed\n      if (!indices.length) {\n        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n      }\n      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n    } else {\n      // Check if mesh is unindexed\n      if (!indices.length && this._mesh._unIndexed) {\n        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n      }\n      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n    }\n  }\n  /**\n   * @internal\n   */\n  _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null;\n    // Line test\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n      const p0 = positions[indices[index]];\n      const p1 = positions[indices[index + 1]];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n      if (length < 0) {\n        continue;\n      }\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null;\n    // Line test\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n      if (length < 0) {\n        continue;\n      }\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n    let intersectInfo = null;\n    // Triangles test\n    let faceId = -1;\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n      faceId++;\n      const indexA = indices[index];\n      const indexB = indices[index + 1];\n      const indexC = indices[index + 2];\n      if (checkStopper && indexC === 0xffffffff) {\n        index += 2;\n        continue;\n      }\n      const p0 = positions[indexA];\n      const p1 = positions[indexB];\n      const p2 = positions[indexC];\n      // stay defensive and don't check against undefined positions.\n      if (!p0 || !p1 || !p2) {\n        continue;\n      }\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\n        continue;\n      }\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = faceId;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {\n    let intersectInfo = null;\n    // Triangles test\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const p2 = positions[index + 2];\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\n        continue;\n      }\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = index / 3;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._linesIndexBuffer) {\n      this._linesIndexBuffer = null;\n    }\n  }\n  // Clone\n  /**\n   * Creates a new submesh from the passed mesh\n   * @param newMesh defines the new hosting mesh\n   * @param newRenderingMesh defines an optional rendering mesh\n   * @returns the new submesh\n   */\n  clone(newMesh, newRenderingMesh) {\n    const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n    if (!this.IsGlobal) {\n      const boundingInfo = this.getBoundingInfo();\n      if (!boundingInfo) {\n        return result;\n      }\n      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n    return result;\n  }\n  // Dispose\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._linesIndexBuffer) {\n      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n      this._linesIndexBuffer = null;\n    }\n    // Remove from mesh\n    const index = this._mesh.subMeshes.indexOf(this);\n    this._mesh.subMeshes.splice(index, 1);\n    this.resetDrawCache();\n  }\n  /**\n   * Gets the class name\n   * @returns the string \"SubMesh\".\n   */\n  getClassName() {\n    return \"SubMesh\";\n  }\n  // Statics\n  /**\n   * Creates a new submesh from indices data\n   * @param materialIndex the index of the main mesh material\n   * @param startIndex the index where to start the copy in the mesh indices array\n   * @param indexCount the number of indices to copy then from the startIndex\n   * @param mesh the main mesh to create the submesh from\n   * @param renderingMesh the optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns a new submesh\n   */\n  static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    let minVertexIndex = Number.MAX_VALUE;\n    let maxVertexIndex = -Number.MAX_VALUE;\n    const whatWillRender = renderingMesh || mesh;\n    const indices = whatWillRender.getIndices();\n    for (let index = startIndex; index < startIndex + indexCount; index++) {\n      const vertexIndex = indices[index];\n      if (vertexIndex < minVertexIndex) {\n        minVertexIndex = vertexIndex;\n      }\n      if (vertexIndex > maxVertexIndex) {\n        maxVertexIndex = vertexIndex;\n      }\n    }\n    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n}","map":{"version":3,"names":["VertexBuffer","IntersectionInfo","BoundingInfo","extractMinAndMaxIndexed","DrawWrapper","SubMesh","materialDefines","_mainDrawWrapperOverride","defines","_a","_getDrawWrapper","drawWrapper","undefined","passId","createIfNotExisting","_engine","currentRenderPassId","_drawWrappers","_mesh","getScene","getEngine","_removeDrawWrapper","disposeWrapper","dispose","effect","_b","_drawWrapper","_drawWrapperOverride","_setMainDrawWrapperOverride","wrapper","setEffect","materialContext","resetContext","resetDrawCache","AddToMesh","materialIndex","verticesStart","verticesCount","indexStart","indexCount","mesh","renderingMesh","createBoundingBox","constructor","addToMesh","_linesIndexCount","_linesIndexBuffer","_lastColliderWorldVertices","_lastColliderTransformMatrix","_wasDispatched","_renderId","_alphaIndex","_distanceToCamera","_currentMaterial","_renderingMesh","subMeshes","push","_trianglePlanes","_id","length","refreshBoundingInfo","computeWorldMatrix","IsGlobal","getTotalVertices","getTotalIndices","getBoundingInfo","hasThinInstances","_boundingInfo","setBoundingInfo","boundingInfo","getMesh","getRenderingMesh","getReplacementMesh","_internalAbstractMeshDataInfo","_actAsRegularMesh","getEffectiveMesh","replacementMesh","getMaterial","getDefaultMaterial","rootMaterial","getMaterialForRenderPass","material","defaultMaterial","_isMultiMaterial","effectiveMaterial","getSubMaterial","data","geometry","getVerticesData","PositionKind","indices","getIndices","extend","minimum","clone","maximum","boundingBias","reConstruct","_checkCollision","collider","updateBoundingInfo","world","update","isInFrustum","frustumPlanes","cullingStrategy","isCompletelyInFrustum","render","enableAlphaMode","_getLinesIndexBuffer","engine","linesIndices","index","createIndexBuffer","canIntersects","ray","intersectsBox","boundingBox","intersects","positions","fastCheck","trianglePredicate","step","checkStopper","fillMode","_intersectUnIndexedLines","intersectionThreshold","_intersectLines","_unIndexed","_intersectUnIndexedTriangles","_intersectTriangles","intersectInfo","p0","p1","intersectionSegment","distance","faceId","indexA","indexB","indexC","p2","currentIntersectInfo","intersectsTriangle","_rebuild","newMesh","newRenderingMesh","result","_releaseBuffer","indexOf","splice","getClassName","CreateFromIndices","startIndex","minVertexIndex","Number","MAX_VALUE","maxVertexIndex","whatWillRender","vertexIndex"],"sources":["../../../../dev/core/src/Meshes/subMesh.ts"],"sourcesContent":["import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { AbstractMesh } from \"./abstractMesh\";\r\nimport type { Mesh } from \"./mesh\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: Engine;\r\n    /** @internal */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true) {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose();\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     */\r\n    public resetDrawCache(passId?: number): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @internal */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @internal */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @internal */\r\n    public _trianglePlanes: Plane[];\r\n    /** @internal */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /** @internal */\r\n    public _renderId = 0;\r\n    /** @internal */\r\n    public _alphaIndex: number = 0;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal || this._mesh.hasThinInstances) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @returns the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(getDefaultMaterial = true): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (!rootMaterial) {\r\n            return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const linesIndices = [];\r\n\r\n            for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender!.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n"],"mappings":";AAGA,SAASA,YAAY,QAAQ,sBAAoB;AACjD,SAASC,gBAAgB,QAAQ,mCAAiC;AAElE,SAASC,YAAY,QAAQ,4BAA0B;AAIvD,SAASC,uBAAuB,QAAQ,4BAA0B;AAElE,SAASC,WAAW,QAAQ,6BAA2B;AAYvD;;;AAGA,OAAM,MAAOC,OAAO;EAMhB;;;EAGA,IAAWC,eAAeA,CAAA;;IACtB,OAAO,IAAI,CAACC,wBAAwB,GAAI,IAAI,CAACA,wBAAwB,CAACC,OAA2B,GAAI,CAAAC,EAAA,OAAI,CAACC,eAAe,EAAE,cAAAD,EAAA,uBAAAA,EAAA,CAAED,OAAqC;EACtK;EAEA;;;EAGA,IAAWF,eAAeA,CAACE,OAAkC;;IACzD,MAAMG,WAAW,GAAG,CAAAF,EAAA,OAAI,CAACF,wBAAwB,cAAAE,EAAA,cAAAA,EAAA,GAAI,IAAI,CAACC,eAAe,CAACE,SAAS,EAAE,IAAI,CAAE;IAC3FD,WAAW,CAACH,OAAO,GAAGA,OAAO;EACjC;EAEA;;;EAGOE,eAAeA,CAACG,MAAe,EAAEC,mBAAmB,GAAG,KAAK;IAC/DD,MAAM,GAAGA,MAAM,aAANA,MAAM,cAANA,MAAM,GAAI,IAAI,CAACE,OAAO,CAACC,mBAAmB;IACnD,IAAIL,WAAW,GAAG,IAAI,CAACM,aAAa,CAACJ,MAAM,CAAC;IAC5C,IAAI,CAACF,WAAW,IAAIG,mBAAmB,EAAE;MACrC,IAAI,CAACG,aAAa,CAACJ,MAAM,CAAC,GAAGF,WAAW,GAAG,IAAIP,WAAW,CAAC,IAAI,CAACc,KAAK,CAACC,QAAQ,EAAE,CAACC,SAAS,EAAE,CAAC;;IAEjG,OAAOT,WAAW;EACtB;EAEA;;;EAGOU,kBAAkBA,CAACR,MAAc,EAAES,cAAc,GAAG,IAAI;;IAC3D,IAAIA,cAAc,EAAE;MAChB,CAAAb,EAAA,OAAI,CAACQ,aAAa,CAACJ,MAAM,CAAC,cAAAJ,EAAA,uBAAAA,EAAA,CAAEc,OAAO,EAAE;;IAEzC,IAAI,CAACN,aAAa,CAACJ,MAAM,CAAC,GAAGD,SAAgB;EACjD;EAEA;;;EAGA,IAAWY,MAAMA,CAAA;;IACb,OAAO,IAAI,CAACjB,wBAAwB,GAAG,IAAI,CAACA,wBAAwB,CAACiB,MAAM,GAAG,CAAAC,EAAA,IAAAhB,EAAA,OAAI,CAACC,eAAe,EAAE,cAAAD,EAAA,uBAAAA,EAAA,CAAEe,MAAM,cAAAC,EAAA,cAAAA,EAAA,GAAI,IAAI;EACxH;EAEA;EACA,IAAWC,YAAYA,CAAA;;IACnB,OAAO,CAAAjB,EAAA,OAAI,CAACF,wBAAwB,cAAAE,EAAA,cAAAA,EAAA,GAAI,IAAI,CAACC,eAAe,CAACE,SAAS,EAAE,IAAI,CAAE;EAClF;EAEA;EACA,IAAWe,oBAAoBA,CAAA;IAC3B,OAAO,IAAI,CAACpB,wBAAwB;EACxC;EAEA;;;EAGOqB,2BAA2BA,CAACC,OAA8B;IAC7D,IAAI,CAACtB,wBAAwB,GAAGsB,OAAO;EAC3C;EAEA;;;;;;;EAOOC,SAASA,CAACN,MAAwB,EAAEhB,OAAA,GAA8C,IAAI,EAAEuB,eAAkC,EAAEC,YAAY,GAAG,IAAI;IAClJ,MAAMrB,WAAW,GAAG,IAAI,CAACe,YAAY;IACrCf,WAAW,CAACmB,SAAS,CAACN,MAAM,EAAEhB,OAAO,EAAEwB,YAAY,CAAC;IACpD,IAAID,eAAe,KAAKnB,SAAS,EAAE;MAC/BD,WAAW,CAACoB,eAAe,GAAGA,eAAe;;IAEjD,IAAI,CAACP,MAAM,EAAE;MACTb,WAAW,CAACH,OAAO,GAAG,IAAI;MAC1BG,WAAW,CAACoB,eAAe,GAAGnB,SAAS;;EAE/C;EAEA;;;;EAIOqB,cAAcA,CAACpB,MAAe;IACjC,IAAI,IAAI,CAACI,aAAa,EAAE;MACpB,IAAIJ,MAAM,KAAKD,SAAS,EAAE;QACtB,IAAI,CAACS,kBAAkB,CAACR,MAAM,CAAC;QAC/B;OACH,MAAM;QACH,KAAK,MAAMF,WAAW,IAAI,IAAI,CAACM,aAAa,EAAE;UAC1CN,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEY,OAAO,EAAE;;;;IAIlC,IAAI,CAACN,aAAa,GAAG,EAAE;EAC3B;EA4BA;;;;;;;;;;;;EAYO,OAAOiB,SAASA,CACnBC,aAAqB,EACrBC,aAAqB,EACrBC,aAAqB,EACrBC,UAAkB,EAClBC,UAAkB,EAClBC,IAAkB,EAClBC,aAAoB,EACpBC,iBAAA,GAA6B,IAAI;IAEjC,OAAO,IAAIrC,OAAO,CAAC8B,aAAa,EAAEC,aAAa,EAAEC,aAAa,EAAEC,UAAU,EAAEC,UAAU,EAAEC,IAAI,EAAEC,aAAa,EAAEC,iBAAiB,CAAC;EACnI;EAEA;;;;;;;;;;;;EAYAC,YAAA,CACI;EACOR,aAAqB,EAC5B;EACOC,aAAqB,EAC5B;EACOC,aAAqB,EAC5B;EACOC,UAAkB,EACzB;EACOC,UAAkB,EACzBC,IAAkB,EAClBC,aAAoB,EACpBC,iBAAA,GAA6B,IAAI,EACjCE,SAAS,GAAG,IAAI;IAZT,KAAAT,aAAa,GAAbA,aAAa;IAEb,KAAAC,aAAa,GAAbA,aAAa;IAEb,KAAAC,aAAa,GAAbA,aAAa;IAEb,KAAAC,UAAU,GAAVA,UAAU;IAEV,KAAAC,UAAU,GAAVA,UAAU;IA7Kb,KAAAhC,wBAAwB,GAA0B,IAAI;IAoG9D;IACO,KAAAsC,gBAAgB,GAAW,CAAC;IAI3B,KAAAC,iBAAiB,GAAyB,IAAI;IACtD;IACO,KAAAC,0BAA0B,GAAwB,IAAI;IAG7D;IACO,KAAAC,4BAA4B,GAAqB,IAAI;IAC5D;IACO,KAAAC,cAAc,GAAG,KAAK;IAE7B;IACO,KAAAC,SAAS,GAAG,CAAC;IACpB;IACO,KAAAC,WAAW,GAAW,CAAC;IAC9B;IACO,KAAAC,iBAAiB,GAAW,CAAC;IAI5B,KAAAC,gBAAgB,GAAuB,IAAI;IAuD/C,IAAI,CAACnC,KAAK,GAAGsB,IAAI;IACjB,IAAI,CAACc,cAAc,GAAGb,aAAa,IAAUD,IAAI;IACjD,IAAII,SAAS,EAAE;MACXJ,IAAI,CAACe,SAAS,CAACC,IAAI,CAAC,IAAI,CAAC;;IAG7B,IAAI,CAACzC,OAAO,GAAG,IAAI,CAACG,KAAK,CAACC,QAAQ,EAAE,CAACC,SAAS,EAAE;IAChD,IAAI,CAACa,cAAc,EAAE;IACrB,IAAI,CAACwB,eAAe,GAAG,EAAE;IAEzB,IAAI,CAACC,GAAG,GAAGlB,IAAI,CAACe,SAAS,CAACI,MAAM,GAAG,CAAC;IAEpC,IAAIjB,iBAAiB,EAAE;MACnB,IAAI,CAACkB,mBAAmB,EAAE;MAC1BpB,IAAI,CAACqB,kBAAkB,CAAC,IAAI,CAAC;;EAErC;EAEA;;;;EAIA;EACA,IAAWC,QAAQA,CAAA;IACf,OAAO,IAAI,CAAC1B,aAAa,KAAK,CAAC,IAAI,IAAI,CAACC,aAAa,KAAK,IAAI,CAACnB,KAAK,CAAC6C,gBAAgB,EAAE,IAAI,IAAI,CAACzB,UAAU,KAAK,CAAC,IAAI,IAAI,CAACC,UAAU,KAAK,IAAI,CAACrB,KAAK,CAAC8C,eAAe,EAAE;EACxK;EAEA;;;;EAIOC,eAAeA,CAAA;IAClB,IAAI,IAAI,CAACH,QAAQ,IAAI,IAAI,CAAC5C,KAAK,CAACgD,gBAAgB,EAAE;MAC9C,OAAO,IAAI,CAAChD,KAAK,CAAC+C,eAAe,EAAE;;IAGvC,OAAO,IAAI,CAACE,aAAa;EAC7B;EAEA;;;;;EAKOC,eAAeA,CAACC,YAA0B;IAC7C,IAAI,CAACF,aAAa,GAAGE,YAAY;IACjC,OAAO,IAAI;EACf;EAEA;;;;EAIOC,OAAOA,CAAA;IACV,OAAO,IAAI,CAACpD,KAAK;EACrB;EAEA;;;;EAIOqD,gBAAgBA,CAAA;IACnB,OAAO,IAAI,CAACjB,cAAc;EAC9B;EAEA;;;;EAIOkB,kBAAkBA,CAAA;IACrB,OAAO,IAAI,CAACtD,KAAK,CAACuD,6BAA6B,CAACC,iBAAiB,GAAG,IAAI,CAACxD,KAAK,GAAG,IAAI;EACzF;EAEA;;;;EAIOyD,gBAAgBA,CAAA;IACnB,MAAMC,eAAe,GAAG,IAAI,CAAC1D,KAAK,CAACuD,6BAA6B,CAACC,iBAAiB,GAAG,IAAI,CAACxD,KAAK,GAAG,IAAI;IAEtG,OAAO0D,eAAe,GAAGA,eAAe,GAAG,IAAI,CAACtB,cAAc;EAClE;EAEA;;;;;EAKOuB,WAAWA,CAACC,kBAAkB,GAAG,IAAI;;IACxC,MAAMC,YAAY,GAAG,CAAAtE,EAAA,OAAI,CAAC6C,cAAc,CAAC0B,wBAAwB,CAAC,IAAI,CAACjE,OAAO,CAACC,mBAAmB,CAAC,cAAAP,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAC6C,cAAc,CAAC2B,QAAQ;IAEnI,IAAI,CAACF,YAAY,EAAE;MACf,OAAOD,kBAAkB,GAAG,IAAI,CAAC5D,KAAK,CAACC,QAAQ,EAAE,CAAC+D,eAAe,GAAG,IAAI;KAC3E,MAAM,IAAI,IAAI,CAACC,gBAAgB,CAACJ,YAAY,CAAC,EAAE;MAC5C,MAAMK,iBAAiB,GAAGL,YAAY,CAACM,cAAc,CAAC,IAAI,CAAClD,aAAa,CAAC;MAEzE,IAAI,IAAI,CAACkB,gBAAgB,KAAK+B,iBAAiB,EAAE;QAC7C,IAAI,CAAC/B,gBAAgB,GAAG+B,iBAAiB;QACzC,IAAI,CAACnD,cAAc,EAAE;;MAGzB,OAAOmD,iBAAiB;;IAG5B,OAAOL,YAAY;EACvB;EAEQI,gBAAgBA,CAACF,QAAkB;IACvC,OAAQA,QAA0B,CAACI,cAAc,KAAKzE,SAAS;EACnE;EAEA;EAEA;;;;;EAKOgD,mBAAmBA,CAAC0B,IAAA,GAA6B,IAAI;IACxD,IAAI,CAACvC,0BAA0B,GAAG,IAAI;IAEtC,IAAI,IAAI,CAACe,QAAQ,IAAI,CAAC,IAAI,CAACR,cAAc,IAAI,CAAC,IAAI,CAACA,cAAc,CAACiC,QAAQ,EAAE;MACxE,OAAO,IAAI;;IAGf,IAAI,CAACD,IAAI,EAAE;MACPA,IAAI,GAAG,IAAI,CAAChC,cAAc,CAACkC,eAAe,CAACxF,YAAY,CAACyF,YAAY,CAAC;;IAGzE,IAAI,CAACH,IAAI,EAAE;MACP,IAAI,CAACnB,aAAa,GAAG,IAAI,CAACjD,KAAK,CAAC+C,eAAe,EAAE;MACjD,OAAO,IAAI;;IAGf,MAAMyB,OAAO,GAAiB,IAAI,CAACpC,cAAc,CAACqC,UAAU,EAAE;IAC9D,IAAIC,MAA8C;IAElD;IACA,IAAI,IAAI,CAACtD,UAAU,KAAK,CAAC,IAAI,IAAI,CAACC,UAAU,KAAKmD,OAAO,CAAC/B,MAAM,EAAE;MAC7D,MAAMU,YAAY,GAAG,IAAI,CAACf,cAAc,CAACW,eAAe,EAAE;MAE1D;MACA2B,MAAM,GAAG;QAAEC,OAAO,EAAExB,YAAY,CAACwB,OAAO,CAACC,KAAK,EAAE;QAAEC,OAAO,EAAE1B,YAAY,CAAC0B,OAAO,CAACD,KAAK;MAAE,CAAE;KAC5F,MAAM;MACHF,MAAM,GAAGzF,uBAAuB,CAACmF,IAAI,EAAEI,OAAO,EAAE,IAAI,CAACpD,UAAU,EAAE,IAAI,CAACC,UAAU,EAAE,IAAI,CAACe,cAAc,CAACiC,QAAQ,CAACS,YAAY,CAAC;;IAGhI,IAAI,IAAI,CAAC7B,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAAC8B,WAAW,CAACL,MAAM,CAACC,OAAO,EAAED,MAAM,CAACG,OAAO,CAAC;KACjE,MAAM;MACH,IAAI,CAAC5B,aAAa,GAAG,IAAIjE,YAAY,CAAC0F,MAAM,CAACC,OAAO,EAAED,MAAM,CAACG,OAAO,CAAC;;IAEzE,OAAO,IAAI;EACf;EAEA;;;EAGOG,eAAeA,CAACC,QAAkB;IACrC,MAAM9B,YAAY,GAAG,IAAI,CAACJ,eAAe,EAAE;IAE3C,OAAOI,YAAY,CAAC6B,eAAe,CAACC,QAAQ,CAAC;EACjD;EAEA;;;;;EAKOC,kBAAkBA,CAACC,KAA4B;IAClD,IAAIhC,YAAY,GAAG,IAAI,CAACJ,eAAe,EAAE;IAEzC,IAAI,CAACI,YAAY,EAAE;MACf,IAAI,CAACT,mBAAmB,EAAE;MAC1BS,YAAY,GAAG,IAAI,CAACJ,eAAe,EAAE;;IAEzC,IAAII,YAAY,EAAE;MACCA,YAAa,CAACiC,MAAM,CAACD,KAAK,CAAC;;IAE9C,OAAO,IAAI;EACf;EAEA;;;;;EAKOE,WAAWA,CAACC,aAAsB;IACrC,MAAMnC,YAAY,GAAG,IAAI,CAACJ,eAAe,EAAE;IAE3C,IAAI,CAACI,YAAY,EAAE;MACf,OAAO,KAAK;;IAEhB,OAAOA,YAAY,CAACkC,WAAW,CAACC,aAAa,EAAE,IAAI,CAACtF,KAAK,CAACuF,eAAe,CAAC;EAC9E;EAEA;;;;;EAKOC,qBAAqBA,CAACF,aAAsB;IAC/C,MAAMnC,YAAY,GAAG,IAAI,CAACJ,eAAe,EAAE;IAE3C,IAAI,CAACI,YAAY,EAAE;MACf,OAAO,KAAK;;IAEhB,OAAOA,YAAY,CAACqC,qBAAqB,CAACF,aAAa,CAAC;EAC5D;EAEA;;;;;EAKOG,MAAMA,CAACC,eAAwB;IAClC,IAAI,CAACtD,cAAc,CAACqD,MAAM,CAAC,IAAI,EAAEC,eAAe,EAAE,IAAI,CAAC1F,KAAK,CAACuD,6BAA6B,CAACC,iBAAiB,GAAG,IAAI,CAACxD,KAAK,GAAGN,SAAS,CAAC;IACtI,OAAO,IAAI;EACf;EAEA;;;EAGOiG,oBAAoBA,CAACnB,OAAqB,EAAEoB,MAAc;IAC7D,IAAI,CAAC,IAAI,CAAChE,iBAAiB,EAAE;MACzB,MAAMiE,YAAY,GAAG,EAAE;MAEvB,KAAK,IAAIC,KAAK,GAAG,IAAI,CAAC1E,UAAU,EAAE0E,KAAK,GAAG,IAAI,CAAC1E,UAAU,GAAG,IAAI,CAACC,UAAU,EAAEyE,KAAK,IAAI,CAAC,EAAE;QACrFD,YAAY,CAACvD,IAAI,CAACkC,OAAO,CAACsB,KAAK,CAAC,EAAEtB,OAAO,CAACsB,KAAK,GAAG,CAAC,CAAC,EAAEtB,OAAO,CAACsB,KAAK,GAAG,CAAC,CAAC,EAAEtB,OAAO,CAACsB,KAAK,GAAG,CAAC,CAAC,EAAEtB,OAAO,CAACsB,KAAK,GAAG,CAAC,CAAC,EAAEtB,OAAO,CAACsB,KAAK,CAAC,CAAC;;MAGrI,IAAI,CAAClE,iBAAiB,GAAGgE,MAAM,CAACG,iBAAiB,CAACF,YAAY,CAAC;MAC/D,IAAI,CAAClE,gBAAgB,GAAGkE,YAAY,CAACpD,MAAM;;IAE/C,OAAO,IAAI,CAACb,iBAAiB;EACjC;EAEA;;;;;EAKOoE,aAAaA,CAACC,GAAQ;IACzB,MAAM9C,YAAY,GAAG,IAAI,CAACJ,eAAe,EAAE;IAE3C,IAAI,CAACI,YAAY,EAAE;MACf,OAAO,KAAK;;IAEhB,OAAO8C,GAAG,CAACC,aAAa,CAAC/C,YAAY,CAACgD,WAAW,CAAC;EACtD;EAEA;;;;;;;;;EASOC,UAAUA,CAACH,GAAQ,EAAEI,SAAoB,EAAE7B,OAAqB,EAAE8B,SAAmB,EAAEC,iBAA4C;IACtI,MAAMxC,QAAQ,GAAG,IAAI,CAACJ,WAAW,EAAE;IACnC,IAAI,CAACI,QAAQ,EAAE;MACX,OAAO,IAAI;;IAEf,IAAIyC,IAAI,GAAG,CAAC;IACZ,IAAIC,YAAY,GAAG,KAAK;IAExB,QAAQ1C,QAAQ,CAAC2C,QAAQ;MACrB,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;QACD,OAAO,IAAI;MACf,KAAK;QACDF,IAAI,GAAG,CAAC;QACRC,YAAY,GAAG,IAAI;QACnB;MACJ;QACI;;IAGR;IACA,IAAI1C,QAAQ,CAAC2C,QAAQ,KAAK;MACtB;MACA,IAAI,CAAClC,OAAO,CAAC/B,MAAM,EAAE;QACjB,OAAO,IAAI,CAACkE,wBAAwB,CAACV,GAAG,EAAEI,SAAS,EAAE7B,OAAO,EAAG,IAAI,CAACxE,KAAa,CAAC4G,qBAAqB,EAAEN,SAAS,CAAC;;MAEvH,OAAO,IAAI,CAACO,eAAe,CAACZ,GAAG,EAAEI,SAAS,EAAE7B,OAAO,EAAG,IAAI,CAACxE,KAAa,CAAC4G,qBAAqB,EAAEN,SAAS,CAAC;KAC7G,MAAM;MACH;MACA,IAAI,CAAC9B,OAAO,CAAC/B,MAAM,IAAI,IAAI,CAACzC,KAAK,CAAC8G,UAAU,EAAE;QAC1C,OAAO,IAAI,CAACC,4BAA4B,CAACd,GAAG,EAAEI,SAAS,EAAE7B,OAAO,EAAE8B,SAAS,EAAEC,iBAAiB,CAAC;;MAGnG,OAAO,IAAI,CAACS,mBAAmB,CAACf,GAAG,EAAEI,SAAS,EAAE7B,OAAO,EAAEgC,IAAI,EAAEC,YAAY,EAAEH,SAAS,EAAEC,iBAAiB,CAAC;;EAElH;EAEA;;;EAGQM,eAAeA,CAACZ,GAAQ,EAAEI,SAAoB,EAAE7B,OAAqB,EAAEoC,qBAA6B,EAAEN,SAAmB;IAC7H,IAAIW,aAAa,GAA+B,IAAI;IAEpD;IACA,KAAK,IAAInB,KAAK,GAAG,IAAI,CAAC1E,UAAU,EAAE0E,KAAK,GAAG,IAAI,CAAC1E,UAAU,GAAG,IAAI,CAACC,UAAU,EAAEyE,KAAK,IAAI,CAAC,EAAE;MACrF,MAAMoB,EAAE,GAAGb,SAAS,CAAC7B,OAAO,CAACsB,KAAK,CAAC,CAAC;MACpC,MAAMqB,EAAE,GAAGd,SAAS,CAAC7B,OAAO,CAACsB,KAAK,GAAG,CAAC,CAAC,CAAC;MAExC,MAAMrD,MAAM,GAAGwD,GAAG,CAACmB,mBAAmB,CAACF,EAAE,EAAEC,EAAE,EAAEP,qBAAqB,CAAC;MACrE,IAAInE,MAAM,GAAG,CAAC,EAAE;QACZ;;MAGJ,IAAI6D,SAAS,IAAI,CAACW,aAAa,IAAIxE,MAAM,GAAGwE,aAAa,CAACI,QAAQ,EAAE;QAChEJ,aAAa,GAAG,IAAIlI,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE0D,MAAM,CAAC;QACxDwE,aAAa,CAACK,MAAM,GAAGxB,KAAK,GAAG,CAAC;QAChC,IAAIQ,SAAS,EAAE;UACX;;;;IAIZ,OAAOW,aAAa;EACxB;EAEA;;;EAGQN,wBAAwBA,CAACV,GAAQ,EAAEI,SAAoB,EAAE7B,OAAqB,EAAEoC,qBAA6B,EAAEN,SAAmB;IACtI,IAAIW,aAAa,GAA+B,IAAI;IAEpD;IACA,KAAK,IAAInB,KAAK,GAAG,IAAI,CAAC5E,aAAa,EAAE4E,KAAK,GAAG,IAAI,CAAC5E,aAAa,GAAG,IAAI,CAACC,aAAa,EAAE2E,KAAK,IAAI,CAAC,EAAE;MAC9F,MAAMoB,EAAE,GAAGb,SAAS,CAACP,KAAK,CAAC;MAC3B,MAAMqB,EAAE,GAAGd,SAAS,CAACP,KAAK,GAAG,CAAC,CAAC;MAE/B,MAAMrD,MAAM,GAAGwD,GAAG,CAACmB,mBAAmB,CAACF,EAAE,EAAEC,EAAE,EAAEP,qBAAqB,CAAC;MACrE,IAAInE,MAAM,GAAG,CAAC,EAAE;QACZ;;MAGJ,IAAI6D,SAAS,IAAI,CAACW,aAAa,IAAIxE,MAAM,GAAGwE,aAAa,CAACI,QAAQ,EAAE;QAChEJ,aAAa,GAAG,IAAIlI,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE0D,MAAM,CAAC;QACxDwE,aAAa,CAACK,MAAM,GAAGxB,KAAK,GAAG,CAAC;QAChC,IAAIQ,SAAS,EAAE;UACX;;;;IAKZ,OAAOW,aAAa;EACxB;EAEA;;;EAGQD,mBAAmBA,CACvBf,GAAQ,EACRI,SAAoB,EACpB7B,OAAqB,EACrBgC,IAAY,EACZC,YAAqB,EACrBH,SAAmB,EACnBC,iBAA4C;IAE5C,IAAIU,aAAa,GAA+B,IAAI;IAEpD;IACA,IAAIK,MAAM,GAAG,CAAC,CAAC;IACf,KAAK,IAAIxB,KAAK,GAAG,IAAI,CAAC1E,UAAU,EAAE0E,KAAK,GAAG,IAAI,CAAC1E,UAAU,GAAG,IAAI,CAACC,UAAU,IAAI,CAAC,GAAGmF,IAAI,CAAC,EAAEV,KAAK,IAAIU,IAAI,EAAE;MACrGc,MAAM,EAAE;MACR,MAAMC,MAAM,GAAG/C,OAAO,CAACsB,KAAK,CAAC;MAC7B,MAAM0B,MAAM,GAAGhD,OAAO,CAACsB,KAAK,GAAG,CAAC,CAAC;MACjC,MAAM2B,MAAM,GAAGjD,OAAO,CAACsB,KAAK,GAAG,CAAC,CAAC;MAEjC,IAAIW,YAAY,IAAIgB,MAAM,KAAK,UAAU,EAAE;QACvC3B,KAAK,IAAI,CAAC;QACV;;MAGJ,MAAMoB,EAAE,GAAGb,SAAS,CAACkB,MAAM,CAAC;MAC5B,MAAMJ,EAAE,GAAGd,SAAS,CAACmB,MAAM,CAAC;MAC5B,MAAME,EAAE,GAAGrB,SAAS,CAACoB,MAAM,CAAC;MAE5B;MACA,IAAI,CAACP,EAAE,IAAI,CAACC,EAAE,IAAI,CAACO,EAAE,EAAE;QACnB;;MAGJ,IAAInB,iBAAiB,IAAI,CAACA,iBAAiB,CAACW,EAAE,EAAEC,EAAE,EAAEO,EAAE,EAAEzB,GAAG,EAAEsB,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC,EAAE;QAClF;;MAGJ,MAAME,oBAAoB,GAAG1B,GAAG,CAAC2B,kBAAkB,CAACV,EAAE,EAAEC,EAAE,EAAEO,EAAE,CAAC;MAE/D,IAAIC,oBAAoB,EAAE;QACtB,IAAIA,oBAAoB,CAACN,QAAQ,GAAG,CAAC,EAAE;UACnC;;QAGJ,IAAIf,SAAS,IAAI,CAACW,aAAa,IAAIU,oBAAoB,CAACN,QAAQ,GAAGJ,aAAa,CAACI,QAAQ,EAAE;UACvFJ,aAAa,GAAGU,oBAAoB;UACpCV,aAAa,CAACK,MAAM,GAAGA,MAAM;UAE7B,IAAIhB,SAAS,EAAE;YACX;;;;;IAKhB,OAAOW,aAAa;EACxB;EAEA;;;EAGQF,4BAA4BA,CAChCd,GAAQ,EACRI,SAAoB,EACpB7B,OAAqB,EACrB8B,SAAmB,EACnBC,iBAA4C;IAE5C,IAAIU,aAAa,GAA+B,IAAI;IACpD;IACA,KAAK,IAAInB,KAAK,GAAG,IAAI,CAAC5E,aAAa,EAAE4E,KAAK,GAAG,IAAI,CAAC5E,aAAa,GAAG,IAAI,CAACC,aAAa,EAAE2E,KAAK,IAAI,CAAC,EAAE;MAC9F,MAAMoB,EAAE,GAAGb,SAAS,CAACP,KAAK,CAAC;MAC3B,MAAMqB,EAAE,GAAGd,SAAS,CAACP,KAAK,GAAG,CAAC,CAAC;MAC/B,MAAM4B,EAAE,GAAGrB,SAAS,CAACP,KAAK,GAAG,CAAC,CAAC;MAE/B,IAAIS,iBAAiB,IAAI,CAACA,iBAAiB,CAACW,EAAE,EAAEC,EAAE,EAAEO,EAAE,EAAEzB,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;QACtE;;MAGJ,MAAM0B,oBAAoB,GAAG1B,GAAG,CAAC2B,kBAAkB,CAACV,EAAE,EAAEC,EAAE,EAAEO,EAAE,CAAC;MAE/D,IAAIC,oBAAoB,EAAE;QACtB,IAAIA,oBAAoB,CAACN,QAAQ,GAAG,CAAC,EAAE;UACnC;;QAGJ,IAAIf,SAAS,IAAI,CAACW,aAAa,IAAIU,oBAAoB,CAACN,QAAQ,GAAGJ,aAAa,CAACI,QAAQ,EAAE;UACvFJ,aAAa,GAAGU,oBAAoB;UACpCV,aAAa,CAACK,MAAM,GAAGxB,KAAK,GAAG,CAAC;UAEhC,IAAIQ,SAAS,EAAE;YACX;;;;;IAKhB,OAAOW,aAAa;EACxB;EAEA;EACOY,QAAQA,CAAA;IACX,IAAI,IAAI,CAACjG,iBAAiB,EAAE;MACxB,IAAI,CAACA,iBAAiB,GAAG,IAAI;;EAErC;EAEA;EACA;;;;;;EAMOgD,KAAKA,CAACkD,OAAqB,EAAEC,gBAAuB;IACvD,MAAMC,MAAM,GAAG,IAAI7I,OAAO,CAAC,IAAI,CAAC8B,aAAa,EAAE,IAAI,CAACC,aAAa,EAAE,IAAI,CAACC,aAAa,EAAE,IAAI,CAACC,UAAU,EAAE,IAAI,CAACC,UAAU,EAAEyG,OAAO,EAAEC,gBAAgB,EAAE,KAAK,CAAC;IAE1J,IAAI,CAAC,IAAI,CAACnF,QAAQ,EAAE;MAChB,MAAMO,YAAY,GAAG,IAAI,CAACJ,eAAe,EAAE;MAE3C,IAAI,CAACI,YAAY,EAAE;QACf,OAAO6E,MAAM;;MAGjBA,MAAM,CAAC/E,aAAa,GAAG,IAAIjE,YAAY,CAACmE,YAAY,CAACwB,OAAO,EAAExB,YAAY,CAAC0B,OAAO,CAAC;;IAGvF,OAAOmD,MAAM;EACjB;EAEA;EAEA;;;EAGO3H,OAAOA,CAAA;IACV,IAAI,IAAI,CAACuB,iBAAiB,EAAE;MACxB,IAAI,CAAC5B,KAAK,CAACC,QAAQ,EAAE,CAACC,SAAS,EAAE,CAAC+H,cAAc,CAAC,IAAI,CAACrG,iBAAiB,CAAC;MACxE,IAAI,CAACA,iBAAiB,GAAG,IAAI;;IAGjC;IACA,MAAMkE,KAAK,GAAG,IAAI,CAAC9F,KAAK,CAACqC,SAAS,CAAC6F,OAAO,CAAC,IAAI,CAAC;IAChD,IAAI,CAAClI,KAAK,CAACqC,SAAS,CAAC8F,MAAM,CAACrC,KAAK,EAAE,CAAC,CAAC;IAErC,IAAI,CAAC/E,cAAc,EAAE;EACzB;EAEA;;;;EAIOqH,YAAYA,CAAA;IACf,OAAO,SAAS;EACpB;EAEA;EACA;;;;;;;;;;EAUO,OAAOC,iBAAiBA,CAC3BpH,aAAqB,EACrBqH,UAAkB,EAClBjH,UAAkB,EAClBC,IAAkB,EAClBC,aAAoB,EACpBC,iBAAA,GAA6B,IAAI;IAEjC,IAAI+G,cAAc,GAAGC,MAAM,CAACC,SAAS;IACrC,IAAIC,cAAc,GAAG,CAACF,MAAM,CAACC,SAAS;IAEtC,MAAME,cAAc,GAAGpH,aAAa,IAAID,IAAI;IAC5C,MAAMkD,OAAO,GAAGmE,cAAe,CAAClE,UAAU,EAAG;IAE7C,KAAK,IAAIqB,KAAK,GAAGwC,UAAU,EAAExC,KAAK,GAAGwC,UAAU,GAAGjH,UAAU,EAAEyE,KAAK,EAAE,EAAE;MACnE,MAAM8C,WAAW,GAAGpE,OAAO,CAACsB,KAAK,CAAC;MAElC,IAAI8C,WAAW,GAAGL,cAAc,EAAE;QAC9BA,cAAc,GAAGK,WAAW;;MAEhC,IAAIA,WAAW,GAAGF,cAAc,EAAE;QAC9BA,cAAc,GAAGE,WAAW;;;IAIpC,OAAO,IAAIzJ,OAAO,CAAC8B,aAAa,EAAEsH,cAAc,EAAEG,cAAc,GAAGH,cAAc,GAAG,CAAC,EAAED,UAAU,EAAEjH,UAAU,EAAEC,IAAI,EAAEC,aAAa,EAAEC,iBAAiB,CAAC;EAC1J"},"metadata":{},"sourceType":"module","externalDependencies":[]}