{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { LayerSceneComponent } from \"./layerSceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/layer.fragment.js\";\nimport \"../Shaders/layer.vertex.js\";\n/**\n * This represents a full screen 2d layer.\n * This can be useful to display a picture in the  background of your scene for instance.\n * @see https://www.babylonjs-playground.com/#08A2BS#1\n */\nexport class Layer {\n  /**\n   * Determines if the layer is drawn before (true) or after (false) post-processing.\n   * If the layer is background, it is always before.\n   */\n  set applyPostProcess(value) {\n    this._applyPostProcess = value;\n  }\n  get applyPostProcess() {\n    return this.isBackground || this._applyPostProcess;\n  }\n  /**\n   * Back compatibility with callback before the onDisposeObservable existed.\n   * The set callback will be triggered when the layer has been disposed.\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Back compatibility with callback before the onBeforeRenderObservable existed.\n   * The set callback will be triggered just before rendering the layer.\n   */\n  set onBeforeRender(callback) {\n    if (this._onBeforeRenderObserver) {\n      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n    }\n    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n  }\n  /**\n   * Back compatibility with callback before the onAfterRenderObservable existed.\n   * The set callback will be triggered just after rendering the layer.\n   */\n  set onAfterRender(callback) {\n    if (this._onAfterRenderObserver) {\n      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    }\n    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n  }\n  /**\n   * Instantiates a new layer.\n   * This represents a full screen 2d layer.\n   * This can be useful to display a picture in the  background of your scene for instance.\n   * @see https://www.babylonjs-playground.com/#08A2BS#1\n   * @param name Define the name of the layer in the scene\n   * @param imgUrl Define the url of the texture to display in the layer\n   * @param scene Define the scene the layer belongs to\n   * @param isBackground Defines whether the layer is displayed in front or behind the scene\n   * @param color Defines a color for the layer\n   */\n  constructor(\n  /**\n   * Define the name of the layer.\n   */\n  name, imgUrl, scene, isBackground, color) {\n    this.name = name;\n    this._applyPostProcess = true;\n    /**\n     * Define the scale of the layer in order to zoom in out of the texture.\n     */\n    this.scale = new Vector2(1, 1);\n    /**\n     * Define an offset for the layer in order to shift the texture.\n     */\n    this.offset = new Vector2(0, 0);\n    /**\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\n     */\n    this.alphaBlendingMode = 2;\n    /**\n     * Define a mask to restrict the layer to only some of the scene cameras.\n     */\n    this.layerMask = 0x0fffffff;\n    /**\n     * Define the list of render target the layer is visible into.\n     */\n    this.renderTargetTextures = [];\n    /**\n     * Define if the layer is only used in renderTarget or if it also\n     * renders in the main frame buffer of the canvas.\n     */\n    this.renderOnlyInRenderTargetTextures = false;\n    /**\n     * Define if the layer is enabled (ie. should be displayed). Default: true\n     */\n    this.isEnabled = true;\n    this._vertexBuffers = {};\n    /**\n     * An event triggered when the layer is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered before rendering the scene\n     */\n    this.onBeforeRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene\n     */\n    this.onAfterRenderObservable = new Observable();\n    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\n    this.isBackground = isBackground === undefined ? true : isBackground;\n    this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);\n    if (!layerComponent) {\n      layerComponent = new LayerSceneComponent(this._scene);\n      this._scene._addComponent(layerComponent);\n    }\n    this._scene.layers.push(this);\n    const engine = this._scene.getEngine();\n    this._drawWrapper = new DrawWrapper(engine);\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n    this._createIndexBuffer();\n  }\n  _createIndexBuffer() {\n    const engine = this._scene.getEngine();\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  }\n  /** @internal */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n  }\n  /**\n   * Checks if the layer is ready to be rendered\n   * @returns true if the layer is ready. False otherwise.\n   */\n  isReady() {\n    var _a;\n    const engine = this._scene.getEngine();\n    let defines = \"\";\n    if (this.alphaTest) {\n      defines = \"#define ALPHATEST\";\n    }\n    if (this.texture && !this.texture.gammaSpace) {\n      defines += \"\\n#define LINEAR\";\n    }\n    if (this._previousDefines !== defines) {\n      this._previousDefines = defines;\n      this._drawWrapper.effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\n    }\n    const currentEffect = this._drawWrapper.effect;\n    return (currentEffect === null || currentEffect === void 0 ? void 0 : currentEffect.isReady()) && ((_a = this.texture) === null || _a === void 0 ? void 0 : _a.isReady());\n  }\n  /**\n   * Renders the layer in the scene.\n   */\n  render() {\n    if (!this.isEnabled) {\n      return;\n    }\n    const engine = this._scene.getEngine();\n    // Check\n    if (!this.isReady()) {\n      return;\n    }\n    const currentEffect = this._drawWrapper.effect;\n    this.onBeforeRenderObservable.notifyObservers(this);\n    // Render\n    engine.enableEffect(this._drawWrapper);\n    engine.setState(false);\n    // Texture\n    currentEffect.setTexture(\"textureSampler\", this.texture);\n    currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\n    // Color\n    currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\n    // Scale / offset\n    currentEffect.setVector2(\"offset\", this.offset);\n    currentEffect.setVector2(\"scale\", this.scale);\n    // VBOs\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\n    // Draw order\n    if (!this.alphaTest) {\n      engine.setAlphaMode(this.alphaBlendingMode);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      engine.setAlphaMode(0);\n    } else {\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    this.onAfterRenderObservable.notifyObservers(this);\n  }\n  /**\n   * Disposes and releases the associated resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n    // Clean RTT list\n    this.renderTargetTextures = [];\n    // Remove from scene\n    const index = this._scene.layers.indexOf(this);\n    this._scene.layers.splice(index, 1);\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderObservable.clear();\n  }\n}","map":{"version":3,"names":["Observable","Vector2","Color4","EngineStore","VertexBuffer","Material","Texture","SceneComponentConstants","LayerSceneComponent","DrawWrapper","Layer","applyPostProcess","value","_applyPostProcess","isBackground","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","onBeforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","onAfterRender","_onAfterRenderObserver","onAfterRenderObservable","constructor","name","imgUrl","scene","color","scale","offset","alphaBlendingMode","layerMask","renderTargetTextures","renderOnlyInRenderTargetTextures","isEnabled","_vertexBuffers","texture","undefined","_scene","LastCreatedScene","layerComponent","_getComponent","NAME_LAYER","_addComponent","layers","push","engine","getEngine","_drawWrapper","vertices","vertexBuffer","PositionKind","_createIndexBuffer","indices","_indexBuffer","createIndexBuffer","_rebuild","vb","isReady","defines","alphaTest","gammaSpace","_previousDefines","effect","createEffect","currentEffect","_a","render","notifyObservers","enableEffect","setState","setTexture","setMatrix","getTextureMatrix","setFloat4","r","g","b","a","setVector2","bindBuffers","setAlphaMode","drawElementsType","TriangleFillMode","dispose","_releaseBuffer","index","indexOf","splice","clear"],"sources":["../../../../dev/core/src/Layers/layer.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { LayerSceneComponent } from \"./layerSceneComponent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/layer.fragment\";\r\nimport \"../Shaders/layer.vertex\";\r\n\r\n/**\r\n * This represents a full screen 2d layer.\r\n * This can be useful to display a picture in the  background of your scene for instance.\r\n * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n */\r\nexport class Layer {\r\n    /**\r\n     * Define the texture the layer should display.\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Is the layer in background or foreground.\r\n     */\r\n    public isBackground: boolean;\r\n\r\n    private _applyPostProcess: boolean = true;\r\n    /**\r\n     * Determines if the layer is drawn before (true) or after (false) post-processing.\r\n     * If the layer is background, it is always before.\r\n     */\r\n    public set applyPostProcess(value: boolean) {\r\n        this._applyPostProcess = value;\r\n    }\r\n    public get applyPostProcess(): boolean {\r\n        return this.isBackground || this._applyPostProcess;\r\n    }\r\n\r\n    /**\r\n     * Define the color of the layer (instead of texture).\r\n     */\r\n    public color: Color4;\r\n\r\n    /**\r\n     * Define the scale of the layer in order to zoom in out of the texture.\r\n     */\r\n    public scale = new Vector2(1, 1);\r\n\r\n    /**\r\n     * Define an offset for the layer in order to shift the texture.\r\n     */\r\n    public offset = new Vector2(0, 0);\r\n\r\n    /**\r\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\r\n     */\r\n    public alphaBlendingMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Define if the layer should alpha test or alpha blend with the rest of the scene.\r\n     * Alpha test will not mix with the background color in case of transparency.\r\n     * It will either use the texture color or the background depending on the alpha value of the current pixel.\r\n     */\r\n    public alphaTest: boolean;\r\n\r\n    /**\r\n     * Define a mask to restrict the layer to only some of the scene cameras.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * Define the list of render target the layer is visible into.\r\n     */\r\n    public renderTargetTextures: RenderTargetTexture[] = [];\r\n\r\n    /**\r\n     * Define if the layer is only used in renderTarget or if it also\r\n     * renders in the main frame buffer of the canvas.\r\n     */\r\n    public renderOnlyInRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Define if the layer is enabled (ie. should be displayed). Default: true\r\n     */\r\n    public isEnabled = true;\r\n\r\n    private _scene: Scene;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _drawWrapper: DrawWrapper;\r\n    private _previousDefines: string;\r\n\r\n    /**\r\n     * An event triggered when the layer is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<Layer>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onDisposeObservable existed.\r\n     * The set callback will be triggered when the layer has been disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the scene\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Layer>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onBeforeRenderObservable existed.\r\n     * The set callback will be triggered just before rendering the layer.\r\n     */\r\n    public set onBeforeRender(callback: () => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the scene\r\n     */\r\n    public onAfterRenderObservable = new Observable<Layer>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onAfterRenderObservable existed.\r\n     * The set callback will be triggered just after rendering the layer.\r\n     */\r\n    public set onAfterRender(callback: () => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new layer.\r\n     * This represents a full screen 2d layer.\r\n     * This can be useful to display a picture in the  background of your scene for instance.\r\n     * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n     * @param name Define the name of the layer in the scene\r\n     * @param imgUrl Define the url of the texture to display in the layer\r\n     * @param scene Define the scene the layer belongs to\r\n     * @param isBackground Defines whether the layer is displayed in front or behind the scene\r\n     * @param color Defines a color for the layer\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the layer.\r\n         */\r\n        public name: string,\r\n        imgUrl: Nullable<string>,\r\n        scene: Nullable<Scene>,\r\n        isBackground?: boolean,\r\n        color?: Color4\r\n    ) {\r\n        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\r\n        this.isBackground = isBackground === undefined ? true : isBackground;\r\n        this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\r\n\r\n        this._scene = <Scene>(scene || EngineStore.LastCreatedScene);\r\n        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER) as LayerSceneComponent;\r\n        if (!layerComponent) {\r\n            layerComponent = new LayerSceneComponent(this._scene);\r\n            this._scene._addComponent(layerComponent);\r\n        }\r\n        this._scene.layers.push(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._drawWrapper = new DrawWrapper(engine);\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Checks if the layer is ready to be rendered\r\n     * @returns true if the layer is ready. False otherwise.\r\n     */\r\n    public isReady() {\r\n        const engine = this._scene.getEngine();\r\n\r\n        let defines = \"\";\r\n\r\n        if (this.alphaTest) {\r\n            defines = \"#define ALPHATEST\";\r\n        }\r\n\r\n        if (this.texture && !this.texture.gammaSpace) {\r\n            defines += \"\\n#define LINEAR\";\r\n        }\r\n\r\n        if (this._previousDefines !== defines) {\r\n            this._previousDefines = defines;\r\n            this._drawWrapper.effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\r\n        }\r\n\r\n        const currentEffect = this._drawWrapper.effect;\r\n\r\n        return currentEffect?.isReady() && this.texture?.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the layer in the scene.\r\n     */\r\n    public render(): void {\r\n        if (!this.isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Check\r\n        if (!this.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const currentEffect = this._drawWrapper.effect!;\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        engine.setState(false);\r\n\r\n        // Texture\r\n        currentEffect.setTexture(\"textureSampler\", this.texture);\r\n        currentEffect.setMatrix(\"textureMatrix\", this.texture!.getTextureMatrix());\r\n\r\n        // Color\r\n        currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\r\n\r\n        // Scale / offset\r\n        currentEffect.setVector2(\"offset\", this.offset);\r\n        currentEffect.setVector2(\"scale\", this.scale);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Draw order\r\n        if (!this.alphaTest) {\r\n            engine.setAlphaMode(this.alphaBlendingMode);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        } else {\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Disposes and releases the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            this.texture = null;\r\n        }\r\n\r\n        // Clean RTT list\r\n        this.renderTargetTextures = [];\r\n\r\n        // Remove from scene\r\n        const index = this._scene.layers.indexOf(this);\r\n        this._scene.layers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}