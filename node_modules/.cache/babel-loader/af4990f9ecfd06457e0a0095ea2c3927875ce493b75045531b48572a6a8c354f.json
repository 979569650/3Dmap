{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * A module that will enable pointer selection for motion controllers of XR Input Sources\n */\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\n  /**\n   * constructs a new background remover module\n   * @param _xrSessionManager the session manager for this module\n   * @param _options read-only options to be used in this module\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      const {\n        laserPointer,\n        selectionMesh\n      } = this._generateNewMeshPair(xrController.pointer);\n      // get two new meshes\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        laserPointer,\n        selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n      if (this._attachedController) {\n        if (!this._options.enablePointerSelectionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {\n          this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!this._options.enablePointerSelectionOnAllControllers) {\n          this._attachedController = xrController.uniqueId;\n        }\n      }\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return this._attachTrackedPointerRayMode(xrController);\n        case \"gaze\":\n          return this._attachGazeMode(xrController);\n        case \"screen\":\n          return this._attachScreenRayMode(xrController);\n      }\n    };\n    this._controllers = {};\n    this._tmpVectorForPickCompare = new Vector3();\n    /**\n     * Disable lighting on the laser pointer (so it will always be visible)\n     */\n    this.disablePointerLighting = true;\n    /**\n     * Disable lighting on the selection mesh (so it will always be visible)\n     */\n    this.disableSelectionMeshLighting = true;\n    /**\n     * Should the laser pointer be displayed\n     */\n    this.displayLaserPointer = true;\n    /**\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\n     */\n    this.displaySelectionMesh = true;\n    /**\n     * This color will be set to the laser pointer when selection is triggered\n     */\n    this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);\n    /**\n     * Default color of the laser pointer\n     */\n    this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);\n    /**\n     * default color of the selection ring\n     */\n    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\n     * This color will be applied to the selection ring when selection is triggered\n     */\n    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    this._identityMatrix = Matrix.Identity();\n    this._screenCoordinatesRef = Vector3.Zero();\n    this._viewportRef = new Viewport(0, 0, 0, 0);\n    this._scene = this._xrSessionManager.scene;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n    if (this._options.gazeCamera) {\n      const webXRCamera = this._options.gazeCamera;\n      const {\n        laserPointer,\n        selectionMesh\n      } = this._generateNewMeshPair(webXRCamera);\n      this._controllers[\"camera\"] = {\n        webXRCamera,\n        laserPointer,\n        selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n      this._attachGazeMode();\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    return true;\n  }\n  /**\n   * Will get the mesh under a specific pointer.\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\n   * @param controllerId the controllerId to check\n   * @returns The mesh under pointer or null if no mesh is under the pointer\n   */\n  getMeshUnderPointer(controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the xr controller that correlates to the pointer id in the pointer event\n   *\n   * @param id the pointer id to search for\n   * @returns the controller that correlates to this id or null if not found\n   */\n  getXRControllerByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  _getPointerSelectionDisabledByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].disabledByNearInteraction;\n      }\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _setPointerSelectionDisabledByPointerId(id, state) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        this._controllers[keys[i]].disabledByNearInteraction = state;\n        return;\n      }\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    Object.keys(this._controllers).forEach(id => {\n      // only do this for the selected pointer\n      const controllerData = this._controllers[id];\n      if (!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController || controllerData.disabledByNearInteraction) {\n        controllerData.selectionMesh.isVisible = false;\n        controllerData.laserPointer.isVisible = false;\n        controllerData.pick = null;\n        return;\n      }\n      controllerData.laserPointer.isVisible = this.displayLaserPointer;\n      let controllerGlobalPosition;\n      // Every frame check collisions/input\n      if (controllerData.xrController) {\n        controllerGlobalPosition = controllerData.xrController.pointer.position;\n        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\n      } else if (controllerData.webXRCamera) {\n        controllerGlobalPosition = controllerData.webXRCamera.position;\n        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\n      } else {\n        return;\n      }\n      if (this._options.maxPointerDistance) {\n        controllerData.tmpRay.length = this._options.maxPointerDistance;\n      }\n      // update pointerX and pointerY of the scene. Only if the flag is set to true!\n      if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\n        const scene = this._xrSessionManager.scene;\n        const camera = this._options.xrInput.xrCamera;\n        if (camera) {\n          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\n          Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\n          // stay safe\n          if (typeof this._screenCoordinatesRef.x === \"number\" && typeof this._screenCoordinatesRef.y === \"number\" && !isNaN(this._screenCoordinatesRef.x) && !isNaN(this._screenCoordinatesRef.y)) {\n            scene.pointerX = this._screenCoordinatesRef.x;\n            scene.pointerY = this._screenCoordinatesRef.y;\n            controllerData.screenCoordinates = {\n              x: this._screenCoordinatesRef.x,\n              y: this._screenCoordinatesRef.y\n            };\n          }\n        }\n      }\n      let utilityScenePick = null;\n      if (this._utilityLayerScene) {\n        utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\n      }\n      const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\n      if (!utilityScenePick || !utilityScenePick.hit) {\n        // No hit in utility scene\n        controllerData.pick = originalScenePick;\n      } else if (!originalScenePick || !originalScenePick.hit) {\n        // No hit in original scene\n        controllerData.pick = utilityScenePick;\n      } else if (utilityScenePick.distance < originalScenePick.distance) {\n        // Hit is closer in utility scene\n        controllerData.pick = utilityScenePick;\n      } else {\n        // Hit is closer in original scene\n        controllerData.pick = originalScenePick;\n      }\n      if (controllerData.pick && controllerData.xrController) {\n        controllerData.pick.aimTransform = controllerData.xrController.pointer;\n        controllerData.pick.gripTransform = controllerData.xrController.grip || null;\n      }\n      const pick = controllerData.pick;\n      if (pick && pick.pickedPoint && pick.hit) {\n        // Update laser state\n        this._updatePointerDistance(controllerData.laserPointer, pick.distance);\n        // Update cursor state\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\n        // To avoid z-fighting\n        const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\n        const deltaFighting = 0.001;\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        if (pickNormal) {\n          const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          const axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\n          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\n        }\n        controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\n        controllerData.meshUnderPointer = pick.pickedMesh;\n      } else {\n        controllerData.selectionMesh.isVisible = false;\n        this._updatePointerDistance(controllerData.laserPointer, 1);\n        controllerData.meshUnderPointer = null;\n      }\n    });\n  }\n  get _utilityLayerScene() {\n    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n  }\n  _attachGazeMode(xrController) {\n    const controllerData = this._controllers[xrController && xrController.uniqueId || \"camera\"];\n    // attached when touched, detaches when raised\n    const timeToSelect = this._options.timeToSelect || 3000;\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\n    let oldPick = new PickingInfo();\n    const discMesh = CreateTorus(\"selection\", {\n      diameter: 0.0035 * 15,\n      thickness: 0.0025 * 6,\n      tessellation: 20\n    }, sceneToRenderTo);\n    discMesh.isVisible = false;\n    discMesh.isPickable = false;\n    discMesh.parent = controllerData.selectionMesh;\n    let timer = 0;\n    let downTriggered = false;\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      if (!controllerData.pick) {\n        return;\n      }\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      controllerData.laserPointer.material.alpha = 0;\n      discMesh.isVisible = false;\n      if (controllerData.pick.hit) {\n        if (!this._pickingMoved(oldPick, controllerData.pick)) {\n          if (timer > timeToSelect / 10) {\n            discMesh.isVisible = true;\n          }\n          timer += this._scene.getEngine().getDeltaTime();\n          if (timer >= timeToSelect) {\n            this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n            // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\n            downTriggered = true;\n            // pointer up right after down, if disable on touch out\n            if (this._options.disablePointerUpOnTouchOut) {\n              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n            discMesh.isVisible = false;\n          } else {\n            const scaleFactor = 1 - timer / timeToSelect;\n            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\n          }\n        } else {\n          if (downTriggered) {\n            if (!this._options.disablePointerUpOnTouchOut) {\n              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n          }\n          downTriggered = false;\n          timer = 0;\n        }\n      } else {\n        downTriggered = false;\n        timer = 0;\n      }\n      this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      oldPick = controllerData.pick;\n    });\n    if (this._options.renderingGroupId !== undefined) {\n      discMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n    if (xrController) {\n      xrController.onDisposeObservable.addOnce(() => {\n        if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.finalPointerUpTriggered = true;\n        }\n        discMesh.dispose();\n      });\n    }\n  }\n  _attachScreenRayMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    let downTriggered = false;\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      if (!controllerData.pick || this._options.disablePointerUpOnTouchOut && downTriggered) {\n        return;\n      }\n      if (!downTriggered) {\n        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n        controllerData.pointerDownTriggered = true;\n        downTriggered = true;\n        if (this._options.disablePointerUpOnTouchOut) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n        }\n      } else {\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n    xrController.onDisposeObservable.addOnce(() => {\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      this._xrSessionManager.runInXRFrame(() => {\n        if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.finalPointerUpTriggered = true;\n        }\n      });\n    });\n  }\n  _attachTrackedPointerRayMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    if (this._options.forceGazeMode) {\n      return this._attachGazeMode(xrController);\n    }\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      controllerData.laserPointer.material.disableLighting = this.disablePointerLighting;\n      controllerData.selectionMesh.material.disableLighting = this.disableSelectionMeshLighting;\n      if (controllerData.pick) {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n    if (xrController.inputSource.gamepad) {\n      const init = motionController => {\n        if (this._options.overrideButtonId) {\n          controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\n        }\n        if (!controllerData.selectionComponent) {\n          controllerData.selectionComponent = motionController.getMainComponent();\n        }\n        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(component => {\n          if (component.changes.pressed) {\n            const pressed = component.changes.pressed.current;\n            if (controllerData.pick) {\n              if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                if (pressed) {\n                  this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                  controllerData.pointerDownTriggered = true;\n                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n                  controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n                } else {\n                  this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n                  controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n                }\n              }\n            } else {\n              if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\n                this._attachedController = xrController.uniqueId;\n              }\n            }\n          }\n        });\n      };\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      const selectStartListener = event => {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n          controllerData.pointerDownTriggered = true;\n          controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n          controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n        }\n      };\n      const selectEndListener = event => {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n          controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n        }\n      };\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  }\n  _convertNormalToDirectionOfRay(normal, ray) {\n    if (normal) {\n      const angle = Math.acos(Vector3.Dot(normal, ray.direction));\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n    return normal;\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(eventName => {\n        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n        if (func) {\n          // For future reference - this is an issue in the WebXR typings.\n          this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n    if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\n      // Stay safe and fire a pointerup, in case it wasn't already triggered\n      const pointerEventInit = {\n        pointerId: controllerData.id,\n        pointerType: \"xr\"\n      };\n      this._xrSessionManager.runInXRFrame(() => {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\n        controllerData.finalPointerUpTriggered = true;\n      });\n    }\n    this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\n      try {\n        controllerData.selectionMesh.dispose();\n        controllerData.laserPointer.dispose();\n        // remove from the map\n        delete this._controllers[xrControllerUniqueId];\n        if (this._attachedController === xrControllerUniqueId) {\n          // check for other controllers\n          const keys = Object.keys(this._controllers);\n          if (keys.length) {\n            this._attachedController = keys[0];\n          } else {\n            this._attachedController = \"\";\n          }\n        }\n      } catch (e) {\n        Tools.Warn(\"controller already detached.\");\n      }\n    });\n  }\n  _generateNewMeshPair(meshParent) {\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    const laserPointer = this._options.customLasterPointerMeshGenerator ? this._options.customLasterPointerMeshGenerator() : CreateCylinder(\"laserPointer\", {\n      height: 1,\n      diameterTop: 0.0002,\n      diameterBottom: 0.004,\n      tessellation: 20,\n      subdivisions: 1\n    }, sceneToRenderTo);\n    laserPointer.parent = meshParent;\n    const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\n    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\n    laserPointerMaterial.alpha = 0.7;\n    laserPointer.material = laserPointerMaterial;\n    laserPointer.rotation.x = Math.PI / 2;\n    this._updatePointerDistance(laserPointer, 1);\n    laserPointer.isPickable = false;\n    laserPointer.isVisible = false;\n    // Create a gaze tracker for the  XR controller\n    const selectionMesh = this._options.customSelectionMeshGenerator ? this._options.customSelectionMeshGenerator() : CreateTorus(\"gazeTracker\", {\n      diameter: 0.0035 * 3,\n      thickness: 0.0025 * 3,\n      tessellation: 20\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n    if (this._options.renderingGroupId !== undefined) {\n      laserPointer.renderingGroupId = this._options.renderingGroupId;\n      selectionMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n    return {\n      laserPointer,\n      selectionMesh\n    };\n  }\n  _pickingMoved(oldPick, newPick) {\n    var _a;\n    if (!oldPick.hit || !newPick.hit) {\n      return true;\n    }\n    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\n      return true;\n    }\n    if (oldPick.pickedMesh !== newPick.pickedMesh) {\n      return true;\n    }\n    (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\n    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\n    const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\n    const length = this._tmpVectorForPickCompare.length();\n    if (length > delta) {\n      return true;\n    }\n    return false;\n  }\n  _updatePointerDistance(_laserPointer, distance = 100) {\n    _laserPointer.scaling.y = distance;\n    // a bit of distance from the controller\n    if (this._scene.useRightHandedSystem) {\n      distance *= -1;\n    }\n    _laserPointer.position.z = distance / 2 + 0.05;\n  }\n  _augmentPointerInit(pointerEventInit, id, screenCoordinates) {\n    pointerEventInit.pointerId = id;\n    pointerEventInit.pointerType = \"xr\";\n    if (screenCoordinates) {\n      pointerEventInit.screenX = screenCoordinates.x;\n      pointerEventInit.screenY = screenCoordinates.y;\n    }\n  }\n  /** @internal */\n  get lasterPointerDefaultColor() {\n    // here due to a typo\n    return this.laserPointerDefaultColor;\n  }\n}\nWebXRControllerPointerSelection._IdCounter = 200;\n/**\n * The module's name\n */\nWebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRControllerPointerSelection.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerPointerSelection(xrSessionManager, options);\n}, WebXRControllerPointerSelection.Version, true);","map":{"version":3,"names":["WebXRFeaturesManager","WebXRFeatureName","Matrix","Vector3","Color3","Axis","StandardMaterial","CreateCylinder","CreateTorus","Ray","PickingInfo","WebXRAbstractFeature","UtilityLayerRenderer","Viewport","Tools","WebXRControllerPointerSelection","constructor","_xrSessionManager","_options","_attachController","xrController","_controllers","uniqueId","laserPointer","selectionMesh","_generateNewMeshPair","pointer","meshUnderPointer","pick","tmpRay","disabledByNearInteraction","id","_IdCounter","_attachedController","enablePointerSelectionOnAllControllers","preferredHandedness","inputSource","handedness","targetRayMode","_attachTrackedPointerRayMode","_attachGazeMode","_attachScreenRayMode","_tmpVectorForPickCompare","disablePointerLighting","disableSelectionMeshLighting","displayLaserPointer","displaySelectionMesh","laserPointerPickedColor","laserPointerDefaultColor","selectionMeshDefaultColor","selectionMeshPickedColor","_identityMatrix","Identity","_screenCoordinatesRef","Zero","_viewportRef","_scene","scene","attach","xrInput","controllers","forEach","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","constantlyUpdateMeshUnderPointer","gazeCamera","webXRCamera","detach","Object","keys","controllerId","getMeshUnderPointer","getXRControllerByPointerId","i","length","_getPointerSelectionDisabledByPointerId","_setPointerSelectionDisabledByPointerId","state","_onXRFrame","_xrFrame","controllerData","isVisible","controllerGlobalPosition","position","getWorldPointerRayToRef","getForwardRayToRef","maxPointerDistance","disableScenePointerVectorUpdate","camera","xrCamera","viewport","toGlobalToRef","getEngine","getRenderWidth","getRenderHeight","ProjectToRef","getTransformMatrix","x","y","isNaN","pointerX","pointerY","screenCoordinates","utilityScenePick","_utilityLayerScene","pickWithRay","pointerMovePredicate","raySelectionPredicate","originalScenePick","hit","distance","aimTransform","gripTransform","grip","pickedPoint","_updatePointerDistance","copyFrom","scaling","Math","sqrt","z","pickNormal","_convertNormalToDirectionOfRay","getNormal","deltaFighting","axis1","Cross","Y","axis2","RotationFromAxisToRef","rotation","addInPlace","scale","pickedMesh","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","timeToSelect","sceneToRenderTo","useUtilityLayer","oldPick","discMesh","diameter","thickness","tessellation","isPickable","parent","timer","downTriggered","pointerEventInit","pointerId","pointerType","onFrameObserver","onXRFrameObservable","add","_augmentPointerInit","material","alpha","_pickingMoved","getDeltaTime","simulatePointerDown","disablePointerUpOnTouchOut","simulatePointerUp","scaleFactor","set","simulatePointerMove","renderingGroupId","undefined","onDisposeObservable","addOnce","finalPointerUpTriggered","dispose","pointerDownTriggered","runInXRFrame","forceGazeMode","disableLighting","gamepad","init","motionController","overrideButtonId","selectionComponent","getComponent","getMainComponent","onButtonChangedObserver","onButtonStateChangedObservable","component","changes","pressed","current","emissiveColor","disableSwitchOnClick","onMotionControllerInitObservable","selectStartListener","event","selectEndListener","eventListeners","selectend","selectstart","session","addEventListener","normal","ray","angle","acos","Dot","direction","PI","scaleInPlace","xrControllerUniqueId","remove","eventName","func","removeEventListener","onBeforeRenderObservable","e","Warn","meshParent","customLasterPointerMeshGenerator","height","diameterTop","diameterBottom","subdivisions","laserPointerMaterial","customSelectionMeshGenerator","bakeCurrentTransformIntoVertices","targetMat","specularColor","Black","backFaceCulling","newPick","_a","subtractToRef","abs","delta","gazeModePointerMovedFactor","_laserPointer","useRightHandedSystem","screenX","screenY","lasterPointerDefaultColor","Name","POINTER_SELECTION","Version","AddWebXRFeature","xrSessionManager","options"],"sources":["../../../../../dev/core/src/XR/features/WebXRControllerPointerSelection.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n\r\n    /**\r\n     * A function that will be called when a new selection mesh is generated.\r\n     * This function should return a mesh that will be used as the selection mesh.\r\n     * The default is a torus with a 0.01 diameter and 0.0075 thickness .\r\n     */\r\n    customSelectionMeshGenerator?: () => Mesh;\r\n\r\n    /**\r\n     * A function that will be called when a new laser pointer mesh is generated.\r\n     * This function should return a mesh that will be used as the laser pointer mesh.\r\n     * The height (y) of the mesh must be 1.\r\n     */\r\n    customLasterPointerMeshGenerator?: () => AbstractMesh;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            disabledByNearInteraction: false,\r\n            id: WebXRControllerPointerSelection._IdCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enablePointerSelectionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            disabledByNearInteraction: boolean;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n            screenCoordinates?: { x: number; y: number };\r\n            pointerDownTriggered?: boolean;\r\n            finalPointerUpTriggered?: boolean;\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPointerSelectionOptions) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                disabledByNearInteraction: false,\r\n                id: WebXRControllerPointerSelection._IdCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getPointerSelectionDisabledByPointerId(id: number): boolean {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].disabledByNearInteraction;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setPointerSelectionDisabledByPointerId(id: number, state: boolean) {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                this._controllers[keys[i]].disabledByNearInteraction = state;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition = controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n                    // stay safe\r\n                    if (\r\n                        typeof this._screenCoordinatesRef.x === \"number\" &&\r\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\r\n                        !isNaN(this._screenCoordinatesRef.x) &&\r\n                        !isNaN(this._screenCoordinatesRef.y)\r\n                    ) {\r\n                        scene.pointerX = this._screenCoordinatesRef.x;\r\n                        scene.pointerY = this._screenCoordinatesRef.y;\r\n\r\n                        controllerData.screenCoordinates = {\r\n                            x: this._screenCoordinatesRef.x,\r\n                            y: this._screenCoordinatesRef.y,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            let utilityScenePick = null;\r\n            if (this._utilityLayerScene) {\r\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\r\n            }\r\n\r\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n            if (!utilityScenePick || !utilityScenePick.hit) {\r\n                // No hit in utility scene\r\n                controllerData.pick = originalScenePick;\r\n            } else if (!originalScenePick || !originalScenePick.hit) {\r\n                // No hit in original scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                // Hit is closer in utility scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else {\r\n                // Hit is closer in original scene\r\n                controllerData.pick = originalScenePick;\r\n            }\r\n\r\n            if (controllerData.pick && controllerData.xrController) {\r\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\r\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\r\n            }\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                const deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        const discMesh = CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                controllerData.pointerDownTriggered = true;\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                                    controllerData.pointerDownTriggered = true;\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.pointerDownTriggered = true;\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    // For future reference - this is an issue in the WebXR typings.\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\r\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\r\n                controllerData.finalPointerUpTriggered = true;\r\n            });\r\n        }\r\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\r\n            try {\r\n                controllerData.selectionMesh.dispose();\r\n                controllerData.laserPointer.dispose();\r\n                // remove from the map\r\n                delete this._controllers[xrControllerUniqueId];\r\n                if (this._attachedController === xrControllerUniqueId) {\r\n                    // check for other controllers\r\n                    const keys = Object.keys(this._controllers);\r\n                    if (keys.length) {\r\n                        this._attachedController = keys[0];\r\n                    } else {\r\n                        this._attachedController = \"\";\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Tools.Warn(\"controller already detached.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = this._options.customLasterPointerMeshGenerator\r\n            ? this._options.customLasterPointerMeshGenerator()\r\n            : CreateCylinder(\r\n                  \"laserPointer\",\r\n                  {\r\n                      height: 1,\r\n                      diameterTop: 0.0002,\r\n                      diameterBottom: 0.004,\r\n                      tessellation: 20,\r\n                      subdivisions: 1,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        laserPointer.parent = meshParent;\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n        laserPointer.isVisible = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = this._options.customSelectionMeshGenerator\r\n            ? this._options.customSelectionMeshGenerator()\r\n            : CreateTorus(\r\n                  \"gazeTracker\",\r\n                  {\r\n                      diameter: 0.0035 * 3,\r\n                      thickness: 0.0025 * 3,\r\n                      tessellation: 20,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    private _augmentPointerInit(pointerEventInit: PointerEventInit, id: number, screenCoordinates?: { x: number; y: number }): void {\r\n        pointerEventInit.pointerId = id;\r\n        pointerEventInit.pointerType = \"xr\";\r\n        if (screenCoordinates) {\r\n            pointerEventInit.screenX = screenCoordinates.x;\r\n            pointerEventInit.screenY = screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}