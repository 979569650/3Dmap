{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\n */\nexport class FramingBehavior {\n  constructor() {\n    /**\n     * An event triggered when the animation to zoom on target mesh has ended\n     */\n    this.onTargetFramingAnimationEndObservable = new Observable();\n    this._mode = FramingBehavior.FitFrustumSidesMode;\n    this._radiusScale = 1.0;\n    this._positionScale = 0.5;\n    this._defaultElevation = 0.3;\n    this._elevationReturnTime = 1500;\n    this._elevationReturnWaitTime = 1000;\n    this._zoomStopsAnimation = false;\n    this._framingTime = 1500;\n    /**\n     * Define if the behavior should automatically change the configured\n     * camera limits and sensibilities.\n     */\n    this.autoCorrectCameraLimitsAndSensibility = true;\n    this._isPointerDown = false;\n    this._lastInteractionTime = -Infinity;\n    // Framing control\n    this._animatables = new Array();\n    this._betaIsAnimating = false;\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"Framing\";\n  }\n  /**\n   * Sets the current mode used by the behavior\n   */\n  set mode(mode) {\n    this._mode = mode;\n  }\n  /**\n   * Gets current mode used by the behavior.\n   */\n  get mode() {\n    return this._mode;\n  }\n  /**\n   * Sets the scale applied to the radius (1 by default)\n   */\n  set radiusScale(radius) {\n    this._radiusScale = radius;\n  }\n  /**\n   * Gets the scale applied to the radius\n   */\n  get radiusScale() {\n    return this._radiusScale;\n  }\n  /**\n   * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n   */\n  set positionScale(scale) {\n    this._positionScale = scale;\n  }\n  /**\n   * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n   */\n  get positionScale() {\n    return this._positionScale;\n  }\n  /**\n   * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\n   * behaviour is triggered, in radians.\n   */\n  set defaultElevation(elevation) {\n    this._defaultElevation = elevation;\n  }\n  /**\n   * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\n   * behaviour is triggered, in radians.\n   */\n  get defaultElevation() {\n    return this._defaultElevation;\n  }\n  /**\n   * Sets the time (in milliseconds) taken to return to the default beta position.\n   * Negative value indicates camera should not return to default.\n   */\n  set elevationReturnTime(speed) {\n    this._elevationReturnTime = speed;\n  }\n  /**\n   * Gets the time (in milliseconds) taken to return to the default beta position.\n   * Negative value indicates camera should not return to default.\n   */\n  get elevationReturnTime() {\n    return this._elevationReturnTime;\n  }\n  /**\n   * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\n   */\n  set elevationReturnWaitTime(time) {\n    this._elevationReturnWaitTime = time;\n  }\n  /**\n   * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\n   */\n  get elevationReturnWaitTime() {\n    return this._elevationReturnWaitTime;\n  }\n  /**\n   * Sets the flag that indicates if user zooming should stop animation.\n   */\n  set zoomStopsAnimation(flag) {\n    this._zoomStopsAnimation = flag;\n  }\n  /**\n   * Gets the flag that indicates if user zooming should stop animation.\n   */\n  get zoomStopsAnimation() {\n    return this._zoomStopsAnimation;\n  }\n  /**\n   * Sets the transition time when framing the mesh, in milliseconds\n   */\n  set framingTime(time) {\n    this._framingTime = time;\n  }\n  /**\n   * Gets the transition time when framing the mesh, in milliseconds\n   */\n  get framingTime() {\n    return this._framingTime;\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    const scene = this._attachedCamera.getScene();\n    FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(pointerInfoPre => {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        this._isPointerDown = true;\n        return;\n      }\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        this._isPointerDown = false;\n      }\n    });\n    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(mesh => {\n      if (mesh) {\n        this.zoomOnMesh(mesh, undefined, () => {\n          this.onTargetFramingAnimationEndObservable.notifyObservers();\n        });\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      this._applyUserInteraction();\n      // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\n      // back to the default position after a given timeout\n      this._maintainCameraAboveGround();\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    const scene = this._attachedCamera.getScene();\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n    this._attachedCamera = null;\n  }\n  /**\n   * Targets the given mesh and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMesh(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {\n    mesh.computeWorldMatrix(true);\n    const boundingBox = mesh.getBoundingInfo().boundingBox;\n    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the given mesh with its children and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMeshHierarchy(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {\n    mesh.computeWorldMatrix(true);\n    const boundingBox = mesh.getHierarchyBoundingVectors(true);\n    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the given meshes with their children and updates zoom level accordingly.\n   * @param meshes  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMeshesHierarchy(meshes, focusOnOriginXZ = false, onAnimationEnd = null) {\n    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    for (let i = 0; i < meshes.length; i++) {\n      const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\n      Vector3.CheckExtends(boundingInfo.min, min, max);\n      Vector3.CheckExtends(boundingInfo.max, min, max);\n    }\n    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the bounding box info defined by its extends and updates zoom level accordingly.\n   * @param minimumWorld Determines the smaller position of the bounding box extend\n   * @param maximumWorld Determines the bigger position of the bounding box extend\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   * @returns true if the zoom was done\n   */\n  zoomOnBoundingInfo(minimumWorld, maximumWorld, focusOnOriginXZ = false, onAnimationEnd = null) {\n    let zoomTarget;\n    if (!this._attachedCamera) {\n      return false;\n    }\n    // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\n    const bottom = minimumWorld.y;\n    const top = maximumWorld.y;\n    const zoomTargetY = bottom + (top - bottom) * this._positionScale;\n    const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\n    if (focusOnOriginXZ) {\n      zoomTarget = new Vector3(0, zoomTargetY, 0);\n    } else {\n      const centerWorld = minimumWorld.add(radiusWorld);\n      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\n    }\n    if (!this._vectorTransition) {\n      this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\n    }\n    this._betaIsAnimating = true;\n    let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n    // sets the radius and lower radius bounds\n    // Small delta ensures camera is not always at lower zoom limit.\n    let radius = 0;\n    if (this._mode === FramingBehavior.FitFrustumSidesMode) {\n      const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n      if (this.autoCorrectCameraLimitsAndSensibility) {\n        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\n      }\n      radius = position;\n    } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\n        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\n      }\n    }\n    // Set sensibilities\n    if (this.autoCorrectCameraLimitsAndSensibility) {\n      const extend = maximumWorld.subtract(minimumWorld).length();\n      this._attachedCamera.panningSensibility = 5000 / extend;\n      this._attachedCamera.wheelPrecision = 100 / radius;\n    }\n    // transition to new radius\n    if (!this._radiusTransition) {\n      this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n    }\n    animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\n      this.stopAllAnimations();\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n      if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\n        this._attachedCamera.storeState();\n      }\n    });\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n    return true;\n  }\n  /**\n   * Calculates the lowest radius for the camera based on the bounding box of the mesh.\n   * @param minimumWorld\n   * @param maximumWorld\n   * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\n   *\t\t to fully enclose the mesh in the viewing frustum.\n   */\n  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld) {\n    const camera = this._attachedCamera;\n    if (!camera) {\n      return 0;\n    }\n    let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);\n    if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      // Don't exceed the requested limit\n      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\n    }\n    // Don't exceed the upper radius limit\n    if (camera.upperRadiusLimit) {\n      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\n    }\n    return distance;\n  }\n  /**\n   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\n   * is automatically returned to its default position (expected to be above ground plane).\n   */\n  _maintainCameraAboveGround() {\n    if (this._elevationReturnTime < 0) {\n      return;\n    }\n    const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\n    const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\n    const limitBeta = Math.PI * 0.5;\n    // Bring the camera back up if below the ground plane\n    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\n      this._betaIsAnimating = true;\n      //Transition to new position\n      this.stopAllAnimations();\n      if (!this._betaTransition) {\n        this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n      }\n      const animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, () => {\n        this._clearAnimationLocks();\n        this.stopAllAnimations();\n      });\n      if (animatabe) {\n        this._animatables.push(animatabe);\n      }\n    }\n  }\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\n   */\n  _clearAnimationLocks() {\n    this._betaIsAnimating = false;\n  }\n  /**\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\n   */\n  _applyUserInteraction() {\n    if (this.isUserIsMoving) {\n      this._lastInteractionTime = PrecisionDate.Now;\n      this.stopAllAnimations();\n      this._clearAnimationLocks();\n    }\n  }\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n  stopAllAnimations() {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n    while (this._animatables.length) {\n      if (this._animatables[0]) {\n        this._animatables[0].onAnimationEnd = null;\n        this._animatables[0].stop();\n      }\n      this._animatables.shift();\n    }\n  }\n  /**\n   * Gets a value indicating if the user is moving the camera\n   */\n  get isUserIsMoving() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n  }\n}\n/**\n * The easing function used by animations\n */\nFramingBehavior.EasingFunction = new ExponentialEase();\n/**\n * The easing mode used by animations\n */\nFramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\n// Statics\n/**\n * The camera can move all the way towards the mesh.\n */\nFramingBehavior.IgnoreBoundsSizeMode = 0;\n/**\n * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\n */\nFramingBehavior.FitFrustumSidesMode = 1;","map":{"version":3,"names":["ExponentialEase","EasingFunction","Observable","PointerEventTypes","PrecisionDate","Vector3","Animation","FramingBehavior","constructor","onTargetFramingAnimationEndObservable","_mode","FitFrustumSidesMode","_radiusScale","_positionScale","_defaultElevation","_elevationReturnTime","_elevationReturnWaitTime","_zoomStopsAnimation","_framingTime","autoCorrectCameraLimitsAndSensibility","_isPointerDown","_lastInteractionTime","Infinity","_animatables","Array","_betaIsAnimating","name","mode","radiusScale","radius","positionScale","scale","defaultElevation","elevation","elevationReturnTime","speed","elevationReturnWaitTime","time","zoomStopsAnimation","flag","framingTime","init","attach","camera","_attachedCamera","scene","getScene","setEasingMode","EasingMode","_onPrePointerObservableObserver","onPrePointerObservable","add","pointerInfoPre","type","POINTERDOWN","POINTERUP","_onMeshTargetChangedObserver","onMeshTargetChangedObservable","mesh","zoomOnMesh","undefined","notifyObservers","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_applyUserInteraction","_maintainCameraAboveGround","detach","remove","focusOnOriginXZ","onAnimationEnd","computeWorldMatrix","boundingBox","getBoundingInfo","zoomOnBoundingInfo","minimumWorld","maximumWorld","zoomOnMeshHierarchy","getHierarchyBoundingVectors","min","max","zoomOnMeshesHierarchy","meshes","Number","MAX_VALUE","i","length","boundingInfo","CheckExtends","zoomTarget","bottom","y","top","zoomTargetY","radiusWorld","subtract","centerWorld","x","z","_vectorTransition","CreateAnimation","ANIMATIONTYPE_VECTOR3","animatable","TransitionTo","push","position","_calculateLowerRadiusFromModelBoundingSphere","lowerRadiusLimit","minZ","IgnoreBoundsSizeMode","extend","panningSensibility","wheelPrecision","_radiusTransition","ANIMATIONTYPE_FLOAT","stopAllAnimations","useInputToRestoreState","storeState","distance","upperRadiusLimit","timeSinceInteraction","Now","defaultBeta","Math","PI","limitBeta","beta","_betaTransition","animatabe","_clearAnimationLocks","isUserIsMoving","animations","stop","shift","inertialAlphaOffset","inertialBetaOffset","inertialRadiusOffset","inertialPanningX","inertialPanningY","EASINGMODE_EASEINOUT"],"sources":["../../../../../dev/core/src/Behaviors/Cameras/framingBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the animation to zoom on target mesh has ended\r\n     */\r\n    public onTargetFramingAnimationEndObservable = new Observable<void>();\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n            if (mesh) {\r\n                this.zoomOnMesh(mesh, undefined, () => {\r\n                    this.onTargetFramingAnimationEndObservable.notifyObservers();\r\n                });\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     * @returns true if the zoom was done\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): boolean {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        const bottom = minimumWorld.y;\r\n        const top = maximumWorld.y;\r\n        const zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            const centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\r\n            this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n\r\n            if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                this._attachedCamera.storeState();\r\n            }\r\n        });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param minimumWorld\r\n     * @param maximumWorld\r\n     * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        const limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            const animatabe = Animation.TransitionTo(\r\n                \"beta\",\r\n                defaultBeta,\r\n                this._attachedCamera,\r\n                this._attachedCamera.getScene(),\r\n                60,\r\n                this._betaTransition,\r\n                this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                }\r\n            );\r\n\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}