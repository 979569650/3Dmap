{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock.js\";\nimport { FlowGraphVariableDefinitions } from \"./flowGraphVariableDefinitions.js\";\nimport { FlowGraphContext } from \"./flowGraphContext.js\";\nimport { FlowGraphBlock } from \"./flowGraphBlock.js\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock.js\";\nexport var FlowGraphState;\n(function (FlowGraphState) {\n  /**\n   * The graph is stopped\n   */\n  FlowGraphState[FlowGraphState[\"Stopped\"] = 0] = \"Stopped\";\n  /**\n   * The graph is running\n   */\n  FlowGraphState[FlowGraphState[\"Started\"] = 1] = \"Started\";\n})(FlowGraphState || (FlowGraphState = {}));\n/**\n * @experimental\n * Class used to represent a flow graph.\n * A flow graph is a graph of blocks that can be used to create complex logic.\n * Blocks can be added to the graph and connected to each other.\n * The graph can then be started, which will init and start all of its event blocks.\n */\nexport class FlowGraph {\n  /**\n   * Construct a Flow Graph\n   * @param params construction parameters. currently only the scene\n   */\n  constructor(params) {\n    /**\n     * The variables defined for this graph\n     */\n    this.variableDefinitions = new FlowGraphVariableDefinitions();\n    /** @internal */\n    this._eventBlocks = [];\n    this._executionContexts = [];\n    /**\n     * The state of the graph\n     */\n    this.state = FlowGraphState.Stopped;\n    this._scene = params.scene;\n    this._eventCoordinator = params.eventCoordinator;\n    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => this.dispose());\n  }\n  /**\n   * Create a context. A context represents one self contained execution for the graph, with its own variables.\n   * @returns the context, where you can get and set variables\n   */\n  createContext() {\n    const context = this.variableDefinitions.generateContext({\n      scene: this._scene,\n      eventCoordinator: this._eventCoordinator\n    });\n    this._executionContexts.push(context);\n    return context;\n  }\n  /**\n   * Add an event block. When the graph is started, it will start listening to events\n   * from the block and execute the graph when they are triggered.\n   * @param block\n   */\n  addEventBlock(block) {\n    this._eventBlocks.push(block);\n  }\n  /**\n   * Starts the flow graph. Initializes the event blocks and starts listening to events.\n   */\n  start() {\n    if (this.state === FlowGraphState.Started) {\n      return;\n    }\n    this.state = FlowGraphState.Started;\n    if (this._executionContexts.length === 0) {\n      this.createContext();\n    }\n    for (const context of this._executionContexts) {\n      for (const block of this._eventBlocks) {\n        block._startPendingTasks(context);\n      }\n    }\n  }\n  /**\n   * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\n   */\n  dispose() {\n    if (this.state === FlowGraphState.Stopped) {\n      return;\n    }\n    this.state = FlowGraphState.Stopped;\n    for (const context of this._executionContexts) {\n      context._clearPendingBlocks();\n    }\n    this._executionContexts.length = 0;\n    this._eventBlocks.length = 0;\n    this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    this._sceneDisposeObserver = null;\n  }\n  /**\n   * Executes a function in all blocks of a flow graph, starting with the event blocks.\n   * @param visitor the function to execute.\n   */\n  visitAllBlocks(visitor) {\n    const visitList = [];\n    const idsAddedToVisitList = new Set();\n    for (const block of this._eventBlocks) {\n      visitList.push(block);\n      idsAddedToVisitList.add(block.uniqueId);\n    }\n    while (visitList.length > 0) {\n      const block = visitList.pop();\n      visitor(block);\n      for (const dataIn of block.dataInputs) {\n        for (const connection of dataIn._connectedPoint) {\n          if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\n            visitList.push(connection._ownerBlock);\n            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\n          }\n        }\n      }\n      if (block instanceof FlowGraphExecutionBlock) {\n        for (const signalOut of block.signalOutputs) {\n          for (const connection of signalOut._connectedPoint) {\n            if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\n              visitList.push(connection._ownerBlock);\n              idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Serializes a graph\n   * @param serializationObject the object to write the values in\n   * @param valueSerializeFunction a function to serialize complex values\n   */\n  serialize(serializationObject = {}, valueSerializeFunction) {\n    serializationObject.variableDefinitions = {};\n    this.variableDefinitions.serialize(serializationObject.variableDefinitions);\n    serializationObject.allBlocks = [];\n    this.visitAllBlocks(block => {\n      const serializedBlock = {};\n      block.serialize(serializedBlock);\n      serializationObject.allBlocks.push(serializedBlock);\n    });\n    serializationObject.executionContexts = [];\n    for (const context of this._executionContexts) {\n      const serializedContext = {};\n      context.serialize(serializedContext, valueSerializeFunction);\n      serializationObject.executionContexts.push(serializedContext);\n    }\n  }\n  /**\n   * Given a list of blocks, find an output data connection that has a specific unique id\n   * @param blocks\n   * @param uniqueId\n   * @returns\n   */\n  static GetDataOutConnectionByUniqueId(blocks, uniqueId) {\n    for (const block of blocks) {\n      for (const dataOut of block.dataOutputs) {\n        if (dataOut.uniqueId === uniqueId) {\n          return dataOut;\n        }\n      }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n  }\n  /**\n   * Given a list of blocks, find an input signal connection that has a specific unique id\n   * @param blocks\n   * @param uniqueId\n   * @returns\n   */\n  static GetSignalInConnectionByUniqueId(blocks, uniqueId) {\n    for (const block of blocks) {\n      if (block instanceof FlowGraphExecutionBlock) {\n        for (const signalIn of block.signalInputs) {\n          if (signalIn.uniqueId === uniqueId) {\n            return signalIn;\n          }\n        }\n      }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n  }\n  /**\n   * Parses a graph from a given serialization object\n   * @param serializationObject the object where the values are written\n   * @param coordinator the flow graph coordinator\n   * @param valueParseFunction a function to parse complex values in a scene\n   * @returns\n   */\n  static Parse(serializationObject, coordinator, valueParseFunction) {\n    const graph = coordinator.createGraph();\n    graph.variableDefinitions.deserialize(serializationObject.variableDefinitions);\n    const blocks = [];\n    // Parse all blocks\n    for (const serializedBlock of serializationObject.allBlocks) {\n      const block = FlowGraphBlock.Parse(serializedBlock);\n      blocks.push(block);\n      if (block instanceof FlowGraphEventBlock) {\n        graph.addEventBlock(block);\n      }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n      for (const dataIn of block.dataInputs) {\n        for (const serializedConnection of dataIn.connectedPointIds) {\n          const connection = FlowGraph.GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n          dataIn.connectTo(connection);\n        }\n      }\n      if (block instanceof FlowGraphExecutionBlock) {\n        for (const signalOut of block.signalOutputs) {\n          for (const serializedConnection of signalOut.connectedPointIds) {\n            const connection = FlowGraph.GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n            signalOut.connectTo(connection);\n          }\n        }\n      }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n      FlowGraphContext.Parse(serializedContext, graph, valueParseFunction);\n    }\n    return graph;\n  }\n}","map":{"version":3,"names":["FlowGraphEventBlock","FlowGraphVariableDefinitions","FlowGraphContext","FlowGraphBlock","FlowGraphExecutionBlock","FlowGraphState","FlowGraph","constructor","params","variableDefinitions","_eventBlocks","_executionContexts","state","Stopped","_scene","scene","_eventCoordinator","eventCoordinator","_sceneDisposeObserver","onDisposeObservable","add","dispose","createContext","context","generateContext","push","addEventBlock","block","start","Started","length","_startPendingTasks","_clearPendingBlocks","remove","visitAllBlocks","visitor","visitList","idsAddedToVisitList","Set","uniqueId","pop","dataIn","dataInputs","connection","_connectedPoint","has","_ownerBlock","signalOut","signalOutputs","serialize","serializationObject","valueSerializeFunction","allBlocks","serializedBlock","executionContexts","serializedContext","GetDataOutConnectionByUniqueId","blocks","dataOut","dataOutputs","Error","GetSignalInConnectionByUniqueId","signalIn","signalInputs","Parse","coordinator","valueParseFunction","graph","createGraph","deserialize","serializedConnection","connectedPointIds","connectTo"],"sources":["../../../../dev/core/src/FlowGraph/flowGraph.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\r\nimport { FlowGraphVariableDefinitions } from \"./flowGraphVariableDefinitions\";\r\nimport { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphEventCoordinator } from \"./flowGraphEventCoordinator\";\r\nimport { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\n\r\nexport enum FlowGraphState {\r\n    /**\r\n     * The graph is stopped\r\n     */\r\n    Stopped,\r\n    /**\r\n     * The graph is running\r\n     */\r\n    Started,\r\n}\r\n\r\n/**\r\n * @experimental\r\n * Parameters used to create a flow graph.\r\n */\r\nexport interface FlowGraphParams {\r\n    /**\r\n     * The scene that the flow graph belongs to.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph.\r\n     */\r\n    eventCoordinator: FlowGraphEventCoordinator;\r\n}\r\n/**\r\n * @experimental\r\n * Class used to represent a flow graph.\r\n * A flow graph is a graph of blocks that can be used to create complex logic.\r\n * Blocks can be added to the graph and connected to each other.\r\n * The graph can then be started, which will init and start all of its event blocks.\r\n */\r\nexport class FlowGraph {\r\n    /**\r\n     * The variables defined for this graph\r\n     */\r\n    public variableDefinitions: FlowGraphVariableDefinitions = new FlowGraphVariableDefinitions();\r\n\r\n    /** @internal */\r\n    public _eventBlocks: FlowGraphEventBlock[] = [];\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    /**\r\n     * @internal\r\n     */\r\n    public readonly _scene: Scene;\r\n    private _eventCoordinator: FlowGraphEventCoordinator;\r\n    private _executionContexts: FlowGraphContext[] = [];\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    state: FlowGraphState = FlowGraphState.Stopped;\r\n\r\n    /**\r\n     * Construct a Flow Graph\r\n     * @param params construction parameters. currently only the scene\r\n     */\r\n    public constructor(params: FlowGraphParams) {\r\n        this._scene = params.scene;\r\n        this._eventCoordinator = params.eventCoordinator;\r\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => this.dispose());\r\n    }\r\n\r\n    /**\r\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\r\n     * @returns the context, where you can get and set variables\r\n     */\r\n    public createContext() {\r\n        const context = this.variableDefinitions.generateContext({ scene: this._scene, eventCoordinator: this._eventCoordinator });\r\n        this._executionContexts.push(context);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Add an event block. When the graph is started, it will start listening to events\r\n     * from the block and execute the graph when they are triggered.\r\n     * @param block\r\n     */\r\n    public addEventBlock(block: FlowGraphEventBlock): void {\r\n        this._eventBlocks.push(block);\r\n    }\r\n\r\n    /**\r\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\r\n     */\r\n    public start() {\r\n        if (this.state === FlowGraphState.Started) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Started;\r\n        if (this._executionContexts.length === 0) {\r\n            this.createContext();\r\n        }\r\n        for (const context of this._executionContexts) {\r\n            for (const block of this._eventBlocks) {\r\n                block._startPendingTasks(context);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\r\n     */\r\n    public dispose() {\r\n        if (this.state === FlowGraphState.Stopped) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Stopped;\r\n        for (const context of this._executionContexts) {\r\n            context._clearPendingBlocks();\r\n        }\r\n        this._executionContexts.length = 0;\r\n        this._eventBlocks.length = 0;\r\n        this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        this._sceneDisposeObserver = null;\r\n    }\r\n\r\n    /**\r\n     * Executes a function in all blocks of a flow graph, starting with the event blocks.\r\n     * @param visitor the function to execute.\r\n     */\r\n    public visitAllBlocks(visitor: (block: FlowGraphBlock) => void) {\r\n        const visitList: FlowGraphBlock[] = [];\r\n        const idsAddedToVisitList = new Set<string>();\r\n        for (const block of this._eventBlocks) {\r\n            visitList.push(block);\r\n            idsAddedToVisitList.add(block.uniqueId);\r\n        }\r\n\r\n        while (visitList.length > 0) {\r\n            const block = visitList.pop()!;\r\n            visitor(block);\r\n\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const connection of dataIn._connectedPoint) {\r\n                    if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                        visitList.push(connection._ownerBlock);\r\n                        idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                    }\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const connection of signalOut._connectedPoint) {\r\n                        if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                            visitList.push(connection._ownerBlock);\r\n                            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes a graph\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializeFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject.variableDefinitions = {};\r\n        this.variableDefinitions.serialize(serializationObject.variableDefinitions);\r\n        serializationObject.allBlocks = [];\r\n        this.visitAllBlocks((block) => {\r\n            const serializedBlock: any = {};\r\n            block.serialize(serializedBlock);\r\n            serializationObject.allBlocks.push(serializedBlock);\r\n        });\r\n        serializationObject.executionContexts = [];\r\n        for (const context of this._executionContexts) {\r\n            const serializedContext: any = {};\r\n            context.serialize(serializedContext, valueSerializeFunction);\r\n            serializationObject.executionContexts.push(serializedContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a list of blocks, find an output data connection that has a specific unique id\r\n     * @param blocks\r\n     * @param uniqueId\r\n     * @returns\r\n     */\r\n    public static GetDataOutConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphDataConnection<any> {\r\n        for (const block of blocks) {\r\n            for (const dataOut of block.dataOutputs) {\r\n                if (dataOut.uniqueId === uniqueId) {\r\n                    return dataOut;\r\n                }\r\n            }\r\n        }\r\n        throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\r\n    }\r\n\r\n    /**\r\n     * Given a list of blocks, find an input signal connection that has a specific unique id\r\n     * @param blocks\r\n     * @param uniqueId\r\n     * @returns\r\n     */\r\n    public static GetSignalInConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphSignalConnection {\r\n        for (const block of blocks) {\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalIn of block.signalInputs) {\r\n                    if (signalIn.uniqueId === uniqueId) {\r\n                        return signalIn;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\r\n    }\r\n\r\n    /**\r\n     * Parses a graph from a given serialization object\r\n     * @param serializationObject the object where the values are written\r\n     * @param coordinator the flow graph coordinator\r\n     * @param valueParseFunction a function to parse complex values in a scene\r\n     * @returns\r\n     */\r\n    public static Parse(serializationObject: any, coordinator: FlowGraphCoordinator, valueParseFunction?: (key: string, serializationObject: any, scene: Scene) => any): FlowGraph {\r\n        const graph = coordinator.createGraph();\r\n        graph.variableDefinitions.deserialize(serializationObject.variableDefinitions);\r\n        const blocks: FlowGraphBlock[] = [];\r\n        // Parse all blocks\r\n        for (const serializedBlock of serializationObject.allBlocks) {\r\n            const block = FlowGraphBlock.Parse(serializedBlock);\r\n            blocks.push(block);\r\n            if (block instanceof FlowGraphEventBlock) {\r\n                graph.addEventBlock(block);\r\n            }\r\n        }\r\n        // After parsing all blocks, connect them\r\n        for (const block of blocks) {\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const serializedConnection of dataIn.connectedPointIds) {\r\n                    const connection = FlowGraph.GetDataOutConnectionByUniqueId(blocks, serializedConnection);\r\n                    dataIn.connectTo(connection);\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const serializedConnection of signalOut.connectedPointIds) {\r\n                        const connection = FlowGraph.GetSignalInConnectionByUniqueId(blocks, serializedConnection);\r\n                        signalOut.connectTo(connection);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (const serializedContext of serializationObject.executionContexts) {\r\n            FlowGraphContext.Parse(serializedContext, graph, valueParseFunction);\r\n        }\r\n        return graph;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}