{"ast":null,"code":"import { PointerDragBehavior } from \"./pointerDragBehavior.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be scaled\n */\nexport class MultiPointerScaleBehavior {\n  /**\n   * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\n   */\n  constructor() {\n    this._startDistance = 0;\n    this._initialScale = new Vector3(0, 0, 0);\n    this._targetScale = new Vector3(0, 0, 0);\n    this._sceneRenderObserver = null;\n    this._dragBehaviorA = new PointerDragBehavior({});\n    this._dragBehaviorA.moveAttached = false;\n    this._dragBehaviorB = new PointerDragBehavior({});\n    this._dragBehaviorB.moveAttached = false;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"MultiPointerScale\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  _getCurrentDistance() {\n    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n  }\n  /**\n   * Attaches the scale behavior the passed in mesh\n   * @param ownerNode The mesh that will be scaled around once attached\n   */\n  attach(ownerNode) {\n    this._ownerNode = ownerNode;\n    // Create 2 drag behaviors such that each will only be triggered by a separate pointer\n    this._dragBehaviorA.onDragStartObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n          this._dragBehaviorA.releaseDrag();\n        } else {\n          this._initialScale.copyFrom(ownerNode.scaling);\n          this._startDistance = this._getCurrentDistance();\n        }\n      }\n    });\n    this._dragBehaviorB.onDragStartObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n          this._dragBehaviorB.releaseDrag();\n        } else {\n          this._initialScale.copyFrom(ownerNode.scaling);\n          this._startDistance = this._getCurrentDistance();\n        }\n      }\n    });\n    // Once both drag behaviors are active scale based on the distance between the two pointers\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(behavior => {\n      behavior.onDragObservable.add(() => {\n        if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n          const ratio = this._getCurrentDistance() / this._startDistance;\n          this._initialScale.scaleToRef(ratio, this._targetScale);\n        }\n      });\n    });\n    ownerNode.addBehavior(this._dragBehaviorA);\n    ownerNode.addBehavior(this._dragBehaviorB);\n    // On every frame move towards target scaling to avoid jitter caused by vr controllers\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\n        if (change.length() > 0.01) {\n          ownerNode.scaling.addInPlace(change);\n        }\n      }\n    });\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(behavior => {\n      behavior.onDragStartObservable.clear();\n      behavior.onDragObservable.clear();\n      this._ownerNode.removeBehavior(behavior);\n    });\n  }\n}","map":{"version":3,"names":["PointerDragBehavior","Vector3","MultiPointerScaleBehavior","constructor","_startDistance","_initialScale","_targetScale","_sceneRenderObserver","_dragBehaviorA","moveAttached","_dragBehaviorB","name","init","_getCurrentDistance","lastDragPosition","subtract","length","attach","ownerNode","_ownerNode","onDragStartObservable","add","dragging","currentDraggingPointerId","releaseDrag","copyFrom","scaling","forEach","behavior","onDragObservable","ratio","scaleToRef","addBehavior","getScene","onBeforeRenderObservable","change","scaleInPlace","addInPlace","detach","remove","clear","removeBehavior"],"sources":["../../../../../dev/core/src/Behaviors/Meshes/multiPointerScaleBehavior.ts"],"sourcesContent":["import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport { PointerDragBehavior } from \"./pointerDragBehavior\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be scaled\r\n */\r\nexport class MultiPointerScaleBehavior implements Behavior<Mesh> {\r\n    private _dragBehaviorA: PointerDragBehavior;\r\n    private _dragBehaviorB: PointerDragBehavior;\r\n    private _startDistance = 0;\r\n    private _initialScale = new Vector3(0, 0, 0);\r\n    private _targetScale = new Vector3(0, 0, 0);\r\n    private _ownerNode: Mesh;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\r\n     */\r\n    constructor() {\r\n        this._dragBehaviorA = new PointerDragBehavior({});\r\n        this._dragBehaviorA.moveAttached = false;\r\n        this._dragBehaviorB = new PointerDragBehavior({});\r\n        this._dragBehaviorB.moveAttached = false;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"MultiPointerScale\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    private _getCurrentDistance() {\r\n        return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\r\n    }\r\n\r\n    /**\r\n     * Attaches the scale behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be scaled around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n\r\n        // Create 2 drag behaviors such that each will only be triggered by a separate pointer\r\n        this._dragBehaviorA.onDragStartObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\r\n                    this._dragBehaviorA.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n        this._dragBehaviorB.onDragStartObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\r\n                    this._dragBehaviorB.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n\r\n        // Once both drag behaviors are active scale based on the distance between the two pointers\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragObservable.add(() => {\r\n                if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                    const ratio = this._getCurrentDistance() / this._startDistance;\r\n                    this._initialScale.scaleToRef(ratio, this._targetScale);\r\n                }\r\n            });\r\n        });\r\n\r\n        ownerNode.addBehavior(this._dragBehaviorA);\r\n        ownerNode.addBehavior(this._dragBehaviorB);\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\r\n                if (change.length() > 0.01) {\r\n                    ownerNode.scaling.addInPlace(change);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragStartObservable.clear();\r\n            behavior.onDragObservable.clear();\r\n            this._ownerNode.removeBehavior(behavior);\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}