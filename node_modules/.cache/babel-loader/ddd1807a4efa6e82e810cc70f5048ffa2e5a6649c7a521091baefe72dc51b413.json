{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess.js\";\nimport { BlurPostProcess } from \"./blurPostProcess.js\";\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n/**\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\n */\nexport class BloomEffect extends PostProcessRenderEffect {\n  /**\n   * The luminance threshold to find bright areas of the image to bloom.\n   */\n  get threshold() {\n    return this._downscale.threshold;\n  }\n  set threshold(value) {\n    this._downscale.threshold = value;\n  }\n  /**\n   * The strength of the bloom.\n   */\n  get weight() {\n    return this._merge.weight;\n  }\n  set weight(value) {\n    this._merge.weight = value;\n  }\n  /**\n   * Specifies the size of the bloom blur kernel, relative to the final output size\n   */\n  get kernel() {\n    return this._blurX.kernel / this._bloomScale;\n  }\n  set kernel(value) {\n    this._blurX.kernel = value * this._bloomScale;\n    this._blurY.kernel = value * this._bloomScale;\n  }\n  /**\n   * Creates a new instance of @see BloomEffect\n   * @param scene The scene the effect belongs to.\n   * @param _bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\n   * @param bloomWeight The the strength of bloom.\n   * @param bloomKernel The size of the kernel to be used when applying the blur.\n   * @param pipelineTextureType The type of texture to be used when performing the post processing.\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\n   */\n  constructor(scene, _bloomScale, bloomWeight, bloomKernel, pipelineTextureType = 0, blockCompilation = false) {\n    super(scene.getEngine(), \"bloom\", () => {\n      return this._effects;\n    }, true);\n    this._bloomScale = _bloomScale;\n    /**\n     * @internal Internal\n     */\n    this._effects = [];\n    this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), 10.0, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    this._blurX.alwaysForcePOT = true;\n    this._blurX.autoClear = false;\n    this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), 10.0, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    this._blurY.alwaysForcePOT = true;\n    this._blurY.autoClear = false;\n    this.kernel = bloomKernel;\n    this._effects = [this._downscale, this._blurX, this._blurY];\n    this._merge = new BloomMergePostProcess(\"bloomMerge\", this._downscale, this._blurY, bloomWeight, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    this._merge.autoClear = false;\n    this._effects.push(this._merge);\n  }\n  /**\n   * Disposes each of the internal effects for a given camera.\n   * @param camera The camera to dispose the effect on.\n   */\n  disposeEffects(camera) {\n    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].dispose(camera);\n    }\n  }\n  /**\n   * @internal Internal\n   */\n  _updateEffects() {\n    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].updateEffect();\n    }\n  }\n  /**\n   * Internal\n   * @returns if all the contained post processes are ready.\n   * @internal\n   */\n  _isReady() {\n    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      if (!this._effects[effectIndex].isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["PostProcessRenderEffect","ExtractHighlightsPostProcess","BlurPostProcess","BloomMergePostProcess","Vector2","Texture","BloomEffect","threshold","_downscale","value","weight","_merge","kernel","_blurX","_bloomScale","_blurY","constructor","scene","bloomWeight","bloomKernel","pipelineTextureType","blockCompilation","getEngine","_effects","BILINEAR_SAMPLINGMODE","undefined","alwaysForcePOT","autoClear","push","disposeEffects","camera","effectIndex","length","dispose","_updateEffects","updateEffect","_isReady","isReady"],"sources":["../../../../dev/core/src/PostProcesses/bloomEffect.ts"],"sourcesContent":["import { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess\";\r\nimport { BlurPostProcess } from \"./blurPostProcess\";\r\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\r\nexport class BloomEffect extends PostProcessRenderEffect {\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _effects: Array<PostProcess> = [];\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _downscale: ExtractHighlightsPostProcess;\r\n    private _blurX: BlurPostProcess;\r\n    private _blurY: BlurPostProcess;\r\n    private _merge: BloomMergePostProcess;\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public get threshold(): number {\r\n        return this._downscale.threshold;\r\n    }\r\n    public set threshold(value: number) {\r\n        this._downscale.threshold = value;\r\n    }\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public get weight(): number {\r\n        return this._merge.weight;\r\n    }\r\n    public set weight(value: number) {\r\n        this._merge.weight = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    public get kernel(): number {\r\n        return this._blurX.kernel / this._bloomScale;\r\n    }\r\n    public set kernel(value: number) {\r\n        this._blurX.kernel = value * this._bloomScale;\r\n        this._blurY.kernel = value * this._bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of @see BloomEffect\r\n     * @param scene The scene the effect belongs to.\r\n     * @param _bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n     * @param bloomWeight The the strength of bloom.\r\n     * @param bloomKernel The size of the kernel to be used when applying the blur.\r\n     * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(scene: Scene, private _bloomScale: number, bloomWeight: number, bloomKernel: number, pipelineTextureType = 0, blockCompilation = false) {\r\n        super(\r\n            scene.getEngine(),\r\n            \"bloom\",\r\n            () => {\r\n                return this._effects;\r\n            },\r\n            true\r\n        );\r\n        this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\r\n\r\n        this._blurX = new BlurPostProcess(\r\n            \"horizontal blur\",\r\n            new Vector2(1.0, 0),\r\n            10.0,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            undefined,\r\n            blockCompilation\r\n        );\r\n        this._blurX.alwaysForcePOT = true;\r\n        this._blurX.autoClear = false;\r\n\r\n        this._blurY = new BlurPostProcess(\r\n            \"vertical blur\",\r\n            new Vector2(0, 1.0),\r\n            10.0,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            undefined,\r\n            blockCompilation\r\n        );\r\n        this._blurY.alwaysForcePOT = true;\r\n        this._blurY.autoClear = false;\r\n\r\n        this.kernel = bloomKernel;\r\n\r\n        this._effects = [this._downscale, this._blurX, this._blurY];\r\n\r\n        this._merge = new BloomMergePostProcess(\r\n            \"bloomMerge\",\r\n            this._downscale,\r\n            this._blurY,\r\n            bloomWeight,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            blockCompilation\r\n        );\r\n        this._merge.autoClear = false;\r\n        this._effects.push(this._merge);\r\n    }\r\n\r\n    /**\r\n     * Disposes each of the internal effects for a given camera.\r\n     * @param camera The camera to dispose the effect on.\r\n     */\r\n    public disposeEffects(camera: Camera) {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].dispose(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _updateEffects() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal\r\n     * @returns if all the contained post processes are ready.\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            if (!this._effects[effectIndex].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}